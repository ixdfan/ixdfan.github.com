---
layout: post
title:  TCP的拥塞控制
description: 
modified: 
categories: 
- NETWORK
tags:
- 拥塞控制
- TCP

---

##### 拥塞控制四种算法:
1. 慢开始
2. 拥塞避免
3. 快速重传
4. 快速恢复


发送方维持一个叫做拥塞窗口cwnd的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，发送方让自己的发送窗口为min(cwnd,rwnd);

###### 发送方控制拥塞窗口的原则是:

只要网络没有出现拥塞，拥塞窗口就再增大一些，一遍把更多的分组发送出去;

只要网络出现阻塞，拥塞窗口就减小一些，以减少注入到网络中的分组数;



###### 发送方如何知道网络发生拥塞?

当网络发生拥塞时,路由器就要丢弃分组，因此只要发送方没有按时收到应当到达的确认报文，就可以猜想网络可能出现了拥塞。


##### 慢启动算法的思路:
当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就可能引起网络阻塞，因为现在并不清楚网络的负荷情况。

比较好的方法是先探测一下，也就是**由小到大发送窗口**，也就是**由小到大增大拥塞窗口值**:



通常在刚刚开始发送报文段时，先将拥塞窗口cwnd设置为一个最大报文段MSS的数值，而在每收到一个对新报文段的确认后，把拥塞窗口添加一个MSS的数值，用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理;


###### 使用慢开始算法后，每经过一个传输轮次，拥塞窗口cwnd就加倍;

![001]({{ site.img_url }}/2014/03/001.gif)


##### 轮次传输:
一个轮次所经历的时间其实就是往返时间RTT，不过"传输轮次"中:把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。

例如:

拥塞窗口cwnd的大小是4个报文段，那么这时的往返时间RTT就是发送方连续发送4个报文段，并收到这4个报文段的确认总共经历的时间。


#### 慢开始门限:
为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量:

* 当cwnd < ssthresh时，使用慢开始算法;
* 当cwnd > ssthresh时，停止使用慢开始算法改用拥塞避免算法;
* 当cwnd < ssthresh时，既可以使用慢开始算法，也可以使用拥塞避免算法


#### 拥塞避免算法:
拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，也就是每经过一个轮次就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按**线性规律缓慢增长**，比慢开始算法的拥塞窗口增长速率慢的多；


##### 注意:
**无论是慢开始阶段还是拥塞避免阶段**一旦出现网络拥塞，那么执行下面两步:
1. 将慢开始门限ssthresh设置为出现拥塞时发送方窗口值的一半(但是不能小于2);
2. 将拥塞窗口cwnd设置为1，执行慢开始算法;

**这样做的目的**:迅速减少主机发送到网络中的分组数，是的发生拥塞的路由器有足够的事件把队列中积压的分组处理完毕。

#### 慢开始:
1. TCP连接初始化，设置拥塞窗口初始，不能大于两个报文段，一般为cwnd=1MSS，设置慢启动门限初值(cwnd为拥塞窗口);
2. TCP开始发送过程，发送窗口swnd按照swnd = min(cwnd, rwnd)来计算，一般通告窗口rwnd足够大，所以实际上swnd=cwnd;
3. 每次传输都调节一次拥塞窗口，从而调节了发送窗口的大小。cwnd从初值1开始，每收到一个对新报文段的确认ACK，则cwnd = cwnd + 1.这样第一次传输完，受到1个ACK，cwnd增加到2;第二次传输完，受到2个ACK，cwnd增加到4(2+1+1);因此cwnd按照指数规律增长，也就是说每传输1次，cwnd加倍，直到cwnd>ssthresh(ssthresh为慢启动门限)，进入拥塞避免;
4. 当在某时刻发生了拥塞，则设置ssthresh = max(swnd/2, 2),也就是说ssthresh降到拥塞发生时swnd的一半，但是不能小于2,并设置cwnd为1,重新开始慢启动过程。

##### 注意:
* "慢启动"指每出现一次超时，拥塞窗口降低到1,使报文慢慢注入网络;
* "拥塞避免"指超过门限窗口后指数增长率降为线性增长率;

###### 慢的含义:
不是指拥塞窗口增长速率慢，而是在TCP开始发送报文段时先设置cwnd = 1，使得发送方在开始时只发送一个报文段(目的是试探一下网络拥塞情况)，然后再逐渐增大cwnd，这当然比按照大的cwnd一下子将许多报文段突然注入到网络中要慢的很多！

拥塞窗口的单位是:报文段MSS的大小而不是1个字节


##### 慢开始与拥塞控制的完整过程
![002]({{ site.img_url }}/2014/03/002.jpg)


0.TCP连接进行初始化时候，将拥塞窗口设置为1,，图中的窗口单位不使用字节而使用报文段。慢开始门限的初始值设置为16个**报文段**，ssthresh = 16；

1.在执行慢开始算法时，拥塞窗口cwnd初值为1，发送第一个报文段M0.

2.发送端每接收到一个确认，就把cwnd加1。于是发送端可以接着发送M1和M2两个报文段

3.接收端共发回两个确认，发送端每收到一个对新报文段的确认，就把发送端的cwnd加1，此时cwnd从2增大到4，并可接着发送后面的4个报文段

4.发送端每收到一个对新报文段的确认，就把发送端的拥塞窗口加1，因此拥塞窗口cwnd随着传输轮次按指数规律递增。

5.当拥塞窗口cwnd增长到慢开始门限值ssthresh时(也就是当cwnd = 16时候)，就改为执行拥塞避免算法，拥塞窗口按线性规律增长。

6.嘉定拥塞窗口的数值增长到24时。网络出现拥塞了。则执行两步操作:
	1.将ssthresh的值变为max(swnd/2, 2) = 12；
	2.将cwnd设置为1，执行慢开始算法；

7.当cwnd = 12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时延就增加一个MSS的大小

#### 特别注意:
如果在慢开始阶段(指数增长阶段)，如果2 * cwnd > ssthresh,则下一个RTT的cwnd应该等于ssthresh，而不是2*cwnd，也就是说cwnd不能越过ssthresh值，例如图中第16个轮次cwnd=8，ssthresh=12，第17轮次时，cwnd=12，而不是16

##### 乘法减小:
不论在慢开始阶段还是拥塞避免阶段，只要出现超时(很可能是因为网络拥塞)，就将慢开始门限值ssthresh设置为当前拥塞窗口的一半，与此同时，执行慢开始算法

当网络频繁出现拥塞时，ssthresh值就下降的很快，以大大减少注入到网络中的分组数

##### 加法增大:
在执行拥塞避免算法后，在收到对所有报文段的确认后(经过一个RTT)，就将拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，防止网络过早出现拥塞；


上面的两种算法合起来成为AIMD算法(加法增大乘法减小)

##### 注意:
拥塞避免并非能够完全避免拥塞，而是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络不容易出现拥塞。


#### 快重传

