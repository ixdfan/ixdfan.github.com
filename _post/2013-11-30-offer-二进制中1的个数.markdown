---
layout: post
title: 二进制中1的个数
categories:
- 剑指offer
---

二进制中1个个数

实现一个函数，输入一个整数，输出该数中二进制中1的个数，例如9的二进制1001,1的个数就是2

    
    /*我的解法*/
    int NumberOf1(int n)
    {
    	int count = 0;
    	while(n != 0){
    		if(n < 0){
    			++count;
    		}
    		n <<= 1;
    	}
    	return count;
    }


如果求0的个数，我们可以直接使用32-1的个数获得；

=======================================================================================

书上的思路是：

如果一个整数不为0，那么整数的二进制表示中至少有一位1；

先假设这个数的最右边一位(最后1位)是1，那么减去1的时候，最后一位变成了0而其他所有位都保持不变，相当于是最后一位做了取反操作，由1变0；

假设最后一位不是1而是0，如果这个数字中的最靠近左边的1于第m位，那么减1操作会使得第m位由1变0，第m位之后的所有0都变1，整数m位之前的所有位都保持不变。

例如二进制1100，他的第2位(从第0位开始)是最靠近右边的1，减去1后，变成了1011，第2位变成了0，第二位后面的两位都变成了1， 前面位没有变化。

在这两种情况中把一个整数减去1，都是把最靠近右边的1位变成了0，如果这个位置之后还有0的话，就将0全部变为1，而他左边位全部保持不变。

**将n与(n-1)做位与运算，相等于把他最右边的1变成0**，例如1100 & 1011得到结果是1000,是将1100最右边的1变成了0。
所以把一个整数减去1，在和原来整数做与运算，会把该整数最右边一个1变成0，那么一个整数中的二进制中有多少个1就能做多少次这样的操作。

    
    /*书中的解法*/
    int NumberOf1(int n)
    {
    	int count = 0;
    	while(n){
    		++count;
    		n = n & (n-1);
    	}
    	return count;
    }


##### 总结：

把一个整数减去1之后再与原来的整数做位与运算，得到的结果相当于是将整数的二进制中最右边的一个1变成了0。

=======================================================================================

##### 相关题目:

使用一条语句判断一个整数是不是2的整数次方。//不得不说原来书中所写是为下文做铺垫，如果使用我的方法，真的完成不了这个问题.

如果一个整数是2的n次方，我们可以找到规律，那个数的二进制中只有1个1，所以我们可以使用之前提到的方法去做
n & (n-1) 结果为0，则表示是2的次方！

=======================================================================================

输入两个整数m和n，计算需要改变吗的二进制中多少位才能得到n，比如10的二进制1010,13的二进制1101，需要改变1010中的三位才能得到1101！

思路是统计m和n的二进制中有多少位是不相同的！所以我们要使用异或，来使得不相同的那些位变成1，最后在来统计1的个数

我们可以将分两步：

1. m与n求异或
2. 统计异或中有多少个1，就知道到底有几位是不相同的了！

=======================================================================================

测试用例：
	正数:(边界值1、0x7FFFFFFF)
	负数:(边界值0x80000000、0xFFFFFFFF)
	0
=======================================================================================

剑指offer这本书让我感觉最好的就是他会在每个题目后面跟上测试用例，让你不知不觉就会养成测试的习惯！

=======================================================================================

刚刚看了《编程之美》中的这个问题，以前每次看到《编程之美》中的这个解答的时候我都有种将他写下来的冲动，感觉真的是太……，我也不知道到用什么来形容，总是怕将这种方法忘了，但是实际上还是忘记了！

对于一字节的无符号整形变量，求二进制中1的个数，这个限制了是无符号整形，所以我的方法就失效了，但是仍然可以使用之前作者的n & (n-1)的方法来求！

查表法：

这个解法的时间复杂度能够**让人高山仰止**了——书上原话，我也是这样认为的！

    
    int countTable[256] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4……/*太多了，自己写吧*/
    }；
    
    int Count(BYTE v)
    {
    	return countTable[v];
    }


每次看到这个查表法，我都认为这个方法很让人高山仰止，无法形容的。

还有一种分支法：

    
    int Count(BYTE v)
    {
    	int num = 0;
    	switch (v)
    	{
    		case: 0x0
    			num = 0;
    			break;
    		case:0x1
    		case:0x2
    		case:0x4
    		case:0x8
    		case:0x10
    		case:0x20
    		case:0x40
    		case:0x80
    			num = 1;
    			break;
    		case:0x3
    		case:0x6
    		case:0xc
    		case:0x18
    		case:0x30
    		case:0x60
    		case:0xc0
    			num = 2;
    			break;
    
    	}
    	return num;
    }


这种方法的效率可能会很低，因为分支语句的执行情况要看具体的值，如果a=0，那么只要1此比较，如果a=255，那要255次比较
