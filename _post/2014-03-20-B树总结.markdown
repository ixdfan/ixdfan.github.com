---
layout: post
title:  B树总结
description: 
modified: 
categories: 
-  
tags:
- 

---



##### B树的特性:

一颗m阶B树:
* 树中每个节点至多含有m颗子树(也就是m个子节点)也就是每个节点最多有m-1个关键字
* 若根节点不是终端节点，则至少有两颗子树，至多m
* 除根节点外的所有非叶子节点至少有m/2(取上)颗子树(也就是至少包含(m/2)-1个关键字,m/2取上)
* 所有非叶节点的结构图
```
	-------------------------------------------------------------------------
	|   n	|   p0	|   k1	|   p1	|   k2	|   p2	| . . .	|   kn	|   pn	|
	-------------------------------------------------------------------------
```	
	ki(i=0-n)为节点的关键字，并且满足k1<k2<...<kn;
	pi(i=0-n)为指向子树根节点的指针，且指针pi-1所指的子树中所有的节点的关键字均小于ki，pi所指子树的所有节点的关键字均大于ki
	节点个数为n(（m/2)-1 <= n <= m-1), m/2取上

* 所有叶节点都出现在同一层次上，并且为空(也就是NULL)，没有任何信息

##### B树是所有节点的平衡因子等于0的多路查找树

#### B树的叶节点对应着查找失败的情况，对有n个关键字的查找集合进行查找，失败的可能有n+1种类

##### B树的高度:

对于任意一颗含有n个关键字、高度为h、阶数为m的B树:
*因为B树中每个节点最多有m颗子树，m-1个关键字，所以的高度为h的m阶B树中 关键字的个数应该满足
	`n <= (m-1) * (1+m^2+m^3+...+m^h-1)`
	`h >= logm (n+1)`
	每层都有m-1个个关键字的时候h为最小值
*如果让每个节点中的关键字个数达到最小，则容纳同样多关键字的B树的高度可以达到最大。

由于B树中定义:
> 第一层至少1个节点；
> 第二层至少2个节点；
> 除根节点以外的每个非终端节点至少有(m/2)(取上)颗子树，则第三层至少有2(m/2)个节点...第h层至少有2(m/2)^(h-1)个节点；

对关键字个数为n的B树叶节点(也就是查找不成功的节点)为n+1，所以
	`n+1 >= 2(m/2)^(h-1)`
	`h <= log(m/2) (((n+1)/2)+1)   `

#### B树的叶节点对应着查找失败的情况，对有n个关键字的查找集合进行查找，失败的可能有n+1种类

##### 注意:
第h+1层是不包含任何信息的叶节点。

例如:一颗3阶B树，共有8个关键字，则其高度范围是 **2 <= h <= 3.17**

##### B树的查找:

B树上进行查找于二叉树查找很相似，知识每个节点都是多个关键字的有序表。在每个节点上所做的不是两路分支决定，而是根据该节点的子树所做的多路分支决定；
B树的查找包含两部分操作:

* 在B树中找节点
* 在节点内找关键字

在B树上查找到某个节点后，现在有序表中进行查找，若找到则查找成功，否则按照对应的指针信息到所指的子树中区查找。
例如:在找到第一层的第一个节点后，若发现关键字大于18小于33则在这个节点上查找失败，根据18与33之间的指针到节点的第二个子树上继续查找。


![006](\uploads\2014\03\006.jpg)


#### B树的插入:
#####1.定位:利用B树的查找算法，找出插入该关键字的最底层中某个非叶节点(注意:B树插入关键字一定是插入在最底层中某个非叶节点内)
#####2.插入:在B树中每个非失败节点中的关键字个数都在(m/2-1, m-1)之间。
* 当插入后节点关键字个数小于m，则可以直接插入
* 插入后节点关键字个数如果大于m-1,则必须对节点进行分裂
分裂方法是:
*取一个新节点，将插入key后的节点从中间位置将其中的关键字分为两部分，左部分不动，右部分包含的关键字放到新的节点中去；同时中间位置(m/2)的节点插入到原节点的父节点中.如果此时导致父节点的关键字个数也超过了上限，则继续进行这种分裂操作，直到整个过程传到根节点为止，这样导致B树高度增加1；

![007](\uploads\2014\03\007.jpg)


##### B树的删除:
B树中的删除于插入操作类似，要使的删除后节点个数>=(m/2)-1，因此将涉及到合并；

##### 1.当删除的关键字k不在终端节点(最底层非叶子节点)中时，有以下几种情况:
* 如果小于k的子树中关键字个数>(m/2-1)，则找出k的钱去值k',并且用k'来取代k，然后递归删除k'即可
* 如果大于k的子树中关键字个数>(m/2-1)，则找出k的后继值k',并且用k'来取代k，然后递归删除k'即可
* 如果前后两个自述中关键字个数均为(m/2-1)，则直接将两个子节点合并，直接删除k即可

![008](\uploads\2014\03\008.jpg)

##### 2.当被删除的关键字k在终端节点(最底层非叶节点)中时，有以下几种情况:
* 直接删除关键字:如果被删除关键字所在节点个数>(m/2-1)个，表明删除该关键字后仍满足B树的定义，则直接删除关键字。
* 兄弟够借:如果被删除关键字所在节点删除前的关键字个数=(m/2-1),且与此节点相邻的右(左)兄弟节点的关键字个数>=m/2,需要调整该节点、右(左)兄弟节点以及其双亲节点(父子对换),以达到新的平衡
* 兄弟不够借:如果被删除关键字所在节点删除前的关键字个数=(m/2-1),且与此节点相邻的右(左)兄弟节点的关键字个数=(m/2-1),则将关键字删除后与右(左)兄弟节点及双亲节点中的关键字进行合并。就是如果都不够那么删除后加入父节点和右(左)兄弟节点。

如果在合并过程中，双亲节点中的关键字个数会减少，若其双亲节点是根节点并且关键字个数减少为0(根节点个数为1有两颗子树)，则直接将根节点删除，合并后的新节点为跟；

若双亲节点不是根节点，切关键字个数减少到了(m/2-2)，又要于他自己的兄弟节点进行调整或合并操作，重复上述过程，直至符合B树的要求为止。


![009](\uploads\2014\03\009.jpg)



##### B+树的特性:
一颗m阶的B+树需要满足下列条件:
* 每个分支节点最多有m颗子树(子节点)；
* 非叶根节点至少有两颗子树，其他每个分支节点至少有m/2颗子树；
* 节点的子树个数于关键字个数相等；
* 所有叶节点包含全部关键字以及指向相应记录的指针，而且叶节点中将关键字按大小顺序排列，并且相邻叶节点按大小顺序相互连接起来；
* 所有分支节点(可以看成是索引的索引)中仅包含他的各个子节点(也就是下一级的索引块)中关键字的最大值及指向子节点的指针。

##### B树与B+树的区别:
* 在B+树中具有n个关键字的节点只含有n颗子树(子节点)，也就是每个关键字对应一颗子树;而在B树中具有n个关键字的节点含有(n+1)颗子树(子节点)。
* 在B+树中，每个节点(非根节点)关键字个数n的范围是m/2 <= n <= m，根节点是1<=n<=m;B树中每个节点(非根节点)关键字个数n的范围是(m/2-1) <= n <= m(-1),根节点是1<=n<=m-1
* B+树中，叶节点包含信息，所有非叶节点仅仅起索引作用，非叶节点中每个索引项只含有对应子树中的最大关键字和指向该子树的指针，不含该关键字对应记录的存储地址；
* B+树中，叶节点包含了全部关键字，也就是非叶节点中出现的关键字也会出现在叶节点中;在B树中叶节点包含的关键字和其他节点中包含的关键字是不重复的！

图为一个4阶B+树的实例:

![010](\uploads\2014\03\010.jpg)



![011](\uploads\2014\03\011.jpg)

这张图片也很好的说明了B+树:
所有的关键字都在叶子节点中；
非叶节点仅仅起到了索引的作用；
非叶节点中每个索引项只含有对应子树中最大关键字和指向该子树的指针，不含有钙关键字对应记录的存储地址；
