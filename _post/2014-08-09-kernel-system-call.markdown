---
layout: post
title: 系统调用的实现过程
description:  
modified: 
categories: 
- KERNEL
tags:
- 
---

系统调用的执行过程主要包括
- 用户空间到内核空间的转换阶段
- 系统调用处理程序system_call函数到系统调用服务例程的阶段

#### 用户空间到内核空间
系统调用的执行需要一个用户空间到内核空间的状态转换，不同平台具有不同的指令可以完成这种转换，这种指令也被称为操作系统陷入。

Linux通过软中断来实现这种陷入，对X86来讲就是0x80即int $0x80汇编指令。软中断是由软件指令处罚而不是硬件引发。

通过软中断0x80，系统调用会转跳到一个预设的内核空间地址，他指向系统调用处理程序(注意:不是系统调用服务例程)，即arch/x86/kernel/entry_32.S文件中使用汇编编写的system_call函数

#### system_call函数到系统调用服务例程
所有的系统调用都会统一转跳到这个地址来执行system_call函数，system_call函数如何将其派发到各自的服务例程呢?

软中断int 0x80执行时，系统调用号会被放入eax寄存器，同时，sys_call_table每项占用4字节。所以system_call函数读取eax寄存器获取当前系统调用号，然后乘以4来生出偏移地址，然后以sys_call_table为基址，基址加上偏移地址指向的内容就是真正要执行的系统调用服务例程的地址。

系统调用如果需要的话，还需要传递一些参数到内核，例如write系统的用的服务例程

	sys_write(unsigned int fd, const char* buf, size_t count);

调用write时就需要传递fd，buf，count到内核中，ebx,ecx,edx,esi以及edi寄存器可以用于传递这些额外的参数

系统调用服务例程中的asmlinkage标记表示，编译器仅仅从堆栈中获取该函数的参数，而不需要从寄存器中获取任何参数。进入system_call函数之前，用户将对应的参数存放到对应的寄存器中，system_call函数执行时会首先将这些寄存器压入堆栈。

系统调用服务例程可以直接从system_call函数压入的堆栈中获得参数，对参数的修改也可以一直在堆栈中进行。system_call函数退出后，用户应用可以直接从寄存器中获得被修改过的参数。

并不是所有系统调用服务例程都有实际的内容，例如sys_ni_syscall除了返回-ENOSYS外不做其他工作

	216 asmlinkage long sys_ni_syscall(void)
	217 {
	218     return -ENOSYS;
	219 }

sys_ni_syscal都代表那些已经被内核淘汰的系统调用

	k636     .long sys_ni_syscall    /* old stty syscall holder */
	637     .long sys_ni_syscall    /* old gtty syscall holder */

分别代表被淘汰的stty和gtty系统调用，如果一个系统调用被淘汰，这个服务例程就要被指定为sys_ni_syscall,我们不能将他们的位置分配给其他的系统调用，因为一些老的代码可能还会是使用他们，否则如果一个用户程序试图调用这个已经被淘汰的系统调用，所得到的文件将于原来完全不同

-------------------------------------------------------------------------------

系统调用通过软中断0x80陷入内核，跳转到调用处理程序system_call函数，并执行相应的服务例程，但是由于代表的是用户进程，所以这个执行过程并不属于中断上下文，而是处于进程上下文。所以系统调用执行过程中，可以访问用户进程的许多信息，可以被其他进程抢占(因为新的进程可能使用相同的系统调用，必须保证系统调用可重入)，可以休眠(比如在系统调用阻塞时候或是显式调用schedule函数时)。

当系统调用完成后，把控制权交给发起调用的用户进程前，内核会有一次调度，如果发现有优先级更高的进程或当前进程时间片用完，那么就选择高优先级的进程或是重新选择进程运行。
