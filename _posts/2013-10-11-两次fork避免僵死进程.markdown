---
author: UCSHELL
comments: true
date: 2013-10-11 11:54:42+00:00
layout: post
slug: '%e4%b8%a4%e6%ac%a1fork%e9%81%bf%e5%85%8d%e5%83%b5%e6%ad%bb%e8%bf%9b%e7%a8%8b'
title: 两次fork避免僵死进程
wordpress_id: 832
categories:
- THE LINUX
tags:
- fork
- 僵死进程
---

APUE原文如下：


> 如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵死状态直到进程终止，实现这一要求的技巧是调用fork两次：


代码大体如下：

    
    int main()
    {
             pid_t pid;
             if((pid = fork()) < 0)
                     perror("fork error");
             else if(0 == pid)
             {
                     if((pid = fork()) < 0)                          
                             perror("fork2 error");                  
                     else if(pid > 0)
                             exit(0);
    
                     sleep(5);
                     printf("second child, parent pid = %d\n", getppid());
                     exit(0);
             }
    
             if(waitpid(pid, NULL, 0) != pid)
                     perror("waitpid error");
             exit(0);
    }


##### 僵死进程何时会出现：

除非保证**父进程先于子进程结束**或者是保证在**父进程在子进程结束前调用waitpid**进行等待！否则子进程都会成为僵死进程！

======================================================

当我们只fork()一次后，存在父进程和子进程。这时有**两种方法来避免产生僵尸进程**：
1. 父进程调用waitpid()等函数来接收子进程退出状态。
2. 父进程先结束，子进程则自动托管到init进程（pid = 1）。

======================================================

只考虑子进程先于父进程结束的情况：

1. 若父进程未处理子进程退出状态，在父进程退出前，子进程一直处于僵尸进程状态。
2. 若父进程调用waitpid()（阻塞调用确保子进程先于父进程结束）来等待子进程结束，父进程在调用waitpid()后进入睡眠状态，只有子进程结束父进程的waitpid()才会返回。

如果存在子进程结束，但父进程还未执行到waitpid()的情况，那么这段时期子进程也将处于僵尸进程状态。

======================================================

所以除非保证父进程先于子进程结束或者保证父进程在子进程结束前执行waitpid()，否则子进程均可能成为僵尸进程。

那么如何使父进程创建不会成为僵尸进程的子进程呢？这就要用两次fork()调用

======================================================

父进程一次fork()后产生一个子进程随后立即执行waitpid(子进程pid, NULL, 0)来等待子进程结束
然后子进程fork()产生孙子进程后立即exit(0)

这样子进程顺利终止（父进程仅仅给子进程收尸，并不需要子进程的返回值)

父进程继续执行。

这时的孙子进程由于失去了它的父进程（即是父进程的子进程），将被转交给init进程托管。

于是父进程与孙子进程无继承关系了，它们的父进程均为init，init进程在其子进程结束时会自动收尸，这样也就不会产生僵尸进程了。
