---
author: UCSHELL
comments: true
date: 2013-09-23 09:33:16+00:00
layout: post
slug: '%e8%9b%87%e5%bd%a2%e5%a1%ab%e6%95%b0'
title: 蛇形填数
wordpress_id: 730
categories:
- THE ALGORITHM
---

蛇形填数
在n*n方阵中填入1,2,3,4……n*n,要求填充成蛇形，例如n=4的时候方阵为

    
    10	11	12	1
     9	16	13	2
     8	15	14	3
     7	 6	 5	4


上面的方阵中多余的空格知识为了便于观察规律，不必严格输出。n<=8

============================================================

类比数学中的矩阵，我们可以使用一个二维数组来存储题目中的方阵，只要声明
int a[MAX][MAX]就可以获得一个大小为MAX*MAX的方阵。

我们从1开始填写，设坐标为(x,y)，
1的坐标为x=0,y=n-1;

============================================================

移动的轨迹为

    下、下、下；
    左、左、左；
    上、上、上；
    右、右；
    下、下；
    左；
    上；
不能走出边界，同时也不能将已经填写的内容覆盖；

所以我们可以将数组全部填充为0，这样没有写过内容的就是0；

这样就可以判断是否已经写过内容；

============================================================
代码如下：

    
    #define MAX 10
    int a[MAX][MAX];
    int main()
    {
            int n, x, y, tot = 0;
    
            scanf("%d", &n);
            printf("n = %d\n", n);
            memset(a, 0, sizeof(a));
            tot = a[x=0][y=n-1] = 1;
    
            while(tot < n*n)
            {
                    while(x+1=0 && !a[x][y-1])
                    {	a[x][--y] = ++tot;	}
                    while(x-1>=0 && !a[x-1][y])
                    {	a[--x][y] = ++tot;	}
                    while(x-1>=0 && !a[x-1][y])
                    {	a[--x][y] = ++tot;	}
                    while(y+1<n && !a[x][y+1]
                     {	a[x][++y] = ++tot;	}
            }
            for(x = 0; x < n; x++)
            {
                    for(y = 0; y < n; y++)
                            printf("%3d", a[x][y]);
                    printf("\n");
            }
            return 0;
    }


首先将tot与(0, n-1)赋值为1；

从此处开始填充

不断按照路径去走


首先是向下；

然后向左；

然后向上；

然后向右；

循环；

要求：

不能出界，同时不能覆盖已经写过的数据；

x+1 !a[x+1][y]用来判断下一步中是否填写过内容；

============================================================
