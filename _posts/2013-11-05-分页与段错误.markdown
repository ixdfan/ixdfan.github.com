---
author: UCSHELL
comments: true
date: 2013-11-05 06:15:00+00:00
layout: post
slug: '%e4%b8%80%e4%b8%aa%e8%bd%bb%e5%be%ae%e7%9a%84%e6%ae%b5%e9%94%99%e8%af%af'
title: 分页与段错误
wordpress_id: 911
categories:
- GDB
tags:
- GDB
---


    int q[200];
    int main()
    {
            int i;
            for(i=0; i<2000; i++)
                    q[i] = i;
            return 0;
    }
    


编译运行:

    
    
    [root@localhost 02]# cc page.c -omain -g
    [root@localhost 02]# ulimit -c
    0
    [root@localhost 02]# ulimit -c unlimited
    [root@localhost 02]# ./main
    段错误 (core dumped)
    
    [root@localhost 02]# gdb main core.3323  
    Program terminated with signal 11, Segmentation fault.
    #0  0x080483a9 in main () at page.c:7
    7                       q[i] = i;
    (gdb) p i
    $1 = 616
    (gdb) p &q;[199]
    $2 = (int *) 0x804997c
    


===========================================================================================

可以看到当i = 616(每次运行结果可能不同)时候才遇到了段错误，q[199]的结束地址为0x804997c
我们知道Linux系统的默认分页是4096字节(可以使用getpagesize函数查看)

**一个虚地址被分解成为一个20位的页号和一个12位的偏移量。**

在本次调试中的页号就是0x8049，偏移量就是0x97c = 2428字节。
分配来q的内存页上仍然有4096-2428=1668字节，可以存放1668/4=417个整形变量的长度，因为当前分配的页上我们具有写权限，所以即使我们越界写数据程序也不会报错的！
当i=615时，使用的仍然是当前分配给q的页，因此对q[615]的写操作仍然是合法的，但是当i变成来616时，q[i]要开始使用一个新的页(不是原来为q分配的页)，这时候我们就没有写权限，虚拟内存检测到这一点，并触发一个段错误

===========================================================================================

由于整个整数变量都存储在4个字节中，所以这个页包含了400个额外的"幻影"元素。
所以一直到q[615]元素都是合法的，但是对616元素访问时，会遇到新页，我们可能拥有也可能没有对他的访问权限。在这里我们是没有对该页的访问权限的，所以发生来段错误。
然而如果我们拥有对下一页的访问权限，我们甚至可以有更多的"幻影"元素

===========================================================================================



