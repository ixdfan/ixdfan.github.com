---
layout: post
title: 单一职责原则
description:  
modified: 
categories: 
- DESIGN-MODE
tags:
- 
---

看到了一个非常好的例子来形容单一职责原则,特将它记录下来

超人也是人

假设世界就是一个程序,程序员们为例维护世界和平,设计出了一个超人,来维护世界和平!既然是超人,就应该是非常强大的,于是程序员给了超人各种各样的能力!来看看超人每天的工作吧!

"超人,快来救我",原来是一个小女孩找不到家了,听到召唤的超人立刻出现,动用自己的超能力将小女孩送到了父母哪里!

"超人,有人抢银行",几分钟后,监狱里多了几个被超人送进去的坏人.抹了一把头上的汗,超人觉得非常有成就感.好像又有人求助,超人还没有来得及喘口气,就马不停蹄的来到求助者身边

"超人,我年纪大了,衣服拧不动了,比帮我拧一下吧!"大婶举着刚刚洗好还在滴水的衣服对着超人说,既然群众有要求,那就要满足,于是超人发挥超能力迅速将衣服甩干了,因此也得到了大婶的盛赞.告别了大婶,超人又踏上了帮助弱小群众的路程.

"超人,帮我除一下后院的草"

"超人,帮我做家庭作业吧"

"超人,帮我写代码吧"

"超人,我饿了!"

晚上,超人一身疲惫的回到了基地.

又是一个晴朗的早晨,但是超人却怎么也高兴不起来,事情是这样的,超人在帮助上学的小朋友过马路时,被小朋友们缠住,结果没有来得及抽身去挽救本可以阻止的一场交通事故.由此引来民众对超人的指责.超人很是郁闷的想程序员求助.

程序员为了帮助超人解决这个问题可谓是煞费苦心,首先将超人设计成了可以分身(多线程)的超人二代,然后又为超人增加了很多奇妙的功能,比如写代码啦!找bug啦!装系统什么的!

	class SuperMan
	{	
	public:
		void 维护世界和平()
		{
			/*	超人在维护世界和平	*/
			...
		}

		void 除草()
		{
			/*	超人在除草	*/
			...
		}

		void 写代码()
		{
			/*	超人化身为程序员	*/
			...
		}
	
		void 写作业()
		{
			/*	超人在帮小朋友写作业 */
			...
		}

		void ...
		...
	}
	

忙完了上面这些,程序员自豪的看着眼前的超人二代,功能齐全,样样都能干的完美作品啊!

超人也似乎很高兴自己的变化,它终于拥有了众多能力,打开窗户嗖的飞出去继续维护世界和平去了;

然而事情并没有超人和程序员想得那么容易,没有多久新的问题就出现了.程序员发现超人洗衣服的功能设计的不是很好,于是不得不将超人叫回来重新修改代码,但是修改代码需要时间,在超人被召回的这段时间,很多罪恶的事情发生了,超人却抽不开身去管.

程序员也叹了口气:"看来不应该把超人设计的这么复杂啊"

程序员开始重新考虑设计超人的问题,既然是超人,那么其肩负的任务应该是维护世界,而不是连保姆的活的干了,也就是说超人担负了过多的职责,超人把精力都用在了杂七杂八的事情上,真正只有超人才能干的活,比如处理坏人,维护世界和平等,超人反而就没有时间处理了!!

还好有一个面向对象原则可以帮助程序员,那就是单一职责原则;

#### 单一职责原则:对于一个类,应该只有一个引起它变化的原因.

为什么类应该满足单一职责原则呢?首先易于维护和高度可复用性是面向对象开发的两个优点.如果一个类的职责过于庞大,那么维护起来肯定也更加麻烦,同时这个类的可复用性随之降低,而尽量多创造复用代码是面向对象的基本原则之一,也是最需要掌握的编程思想,所以当类的职责过于庞大时,就与面向对象的丝线背道而驰了,类的合理性也就成了无稽之谈.

所以说把超人当作一个类的话,那么其职责应该是单一的维护世界和平,而不应该去参杂其他职责,不然一旦其中某一项功能出现问题,那么程序员们"修改"超人时就没有人站出来维护世界和平了!

程序员按照单一职责原则给超人做了一次彻底性减负,保留了与维护世界和平有关的技能,保姆的活就不要超人去做啦!

	class SuperMan
	{
	public:
		void 维护世界和平()
		{
			/*	超人在维护世界和平	*/
			...
		}
	}
