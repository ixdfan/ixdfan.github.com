---
author: UCSHELL
comments: true
date: 2013-11-29 02:44:48+00:00
layout: post
slug: '%e5%bf%ab%e9%80%9f%e8%ae%a1%e7%ae%97%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6'
title: 快速计算时间复杂度
wordpress_id: 1134
categories:
- ALGORITHM
tags:
- 时间复杂度
---

算法时间复杂度的几种计算方法

算法中**所有语句的频度之和记为T(n),算法中的基本运算的频度与T(n)同数量级**。

平均时间复杂度是所有可能**输入实例在等概率**出现的情况下，算法的期望运行时间。

最坏时间复杂度是在最坏情况下算法的时间复杂度。

时间复杂度的运算规则：

加法规则:

    
    T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))


乘法规则：

    
    T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))


===============================================================================

一种是循环主体中的变量参与循环条件的判断，对于这种类型题目应该找出主体语句中与T(n)成正比的循环变量，将之带入条件中计算.
例如：

    
    1.	int i = 1;
    	while(i <= n){
    		i = i * 2;	
    	}


例子中i*2的次数等于主体语句执行的次数T(n),所以2^T(n)<=n;则T(n)<= log2 N;

    
    2	int y = 5;
    	while((y+1) * (y+1) < n){
    		y = y + 1;	
    	}


在2中，y+1的次数为T(n),则y = T(n) - 5(因为y从5开始)，则(T(n)+1) * (T(n)+1) < n;
则T(n) < (根号n) - 6，所以T(n) = O(根号n)；

    
    3	void fun(int n){
    		int i = 0;
    		while(i * i * i <= n){
    			i++;	
    		}
    	}


程序的时间复杂度为O(n开立方)，基本操作是i++，T(n)为程序执行的次数，则T(n) = i,
则T(n) * T(n) * T(n) <= n,则T(n) <= n开立方 = O(n开立方)

===============================================================================

二是循环主体中的变量与循环条件无关，这种题目一般采取数学归纳法或直接累计循环次数；

对于递归算法的数学分析：

1.对于任意非负数n，计算阶乘函数F(n) = n!的值；因为

    
    	当n>=1时， n != 1 * 2 * …… * (n-1) * n = (n-1)! * n;


根据定义 0 != 1,我们可以使用递归算法计算 F(n) = F(n-1)*n；

    
    算法：	F(n)	//递归计算n！
    	if n = 0 return 1
    	else return F(n-1) * n


该算法的基本操作是乘法，它的执行次数为T(n)

    
    n > 0, F(n) = F(n-1) * n
    n > 0, T(n) = T(n-1) + 1


其中T(n-1)是计算F(n-1)中乘法的次数，+1表示的是计算F(n-1)与n的乘法；

计算F(n-1)需要T(n-1)此乘法，还要一次乘法把F(n-1)乘以n；

    
    T(n)= T(n-1) + 1
    	= T(n-2) + 2
    	= T(n-3) + 3
    	= T(n-n) + n
    	= n


=================================================================================
