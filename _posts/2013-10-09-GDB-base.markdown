---
layout: post
title: GDB调试(一)
categories:
- GDB
tags:
- GDB
---

GDB软件调试

===================================================================

r 后接参数，如果要重用老的命令参数，再次运行时不输入参数直接run即可

===================================================================

GDB的TUI模式：

gdb -tui main

Ctrl+x+a用来打开关闭TUI模式

在没有进入TUI模式的情况下使用Ctrl+x+a

进入TUI模式后可以使用Ctrl+x+a退出TUI模式

===================================================================

next:不会进入函数内部

step:会进入函数内部

对于一般的函数我们可以使用next执行后在打印出传入函数的参数，以便查看函数是否正确运行了。

如果没有正确运行再使用step进入函数调试,这样就不必浪费时间进入函数进行调试了

===================================================================

    break: 设置断点
    clear: 清除断点
    info break 来查询要查找的断点号
    break 30 表示在第30行设置断点
    break sort 表示在sort函数的第一行设置断点，这样有一个好处，假如修改了程序代码可能sort函数不在原来的行上，那么这种方式是非常的高效的！

break sort (假设此处断点号为3)

condition 3 num == 5 表示只有满足条件num ==5的时候GDB才会在断点号为3的地方停止

##### 注意：
condition后只接受断点号而不是行号，我们可以使用info break 来查询要查找的断点号。

break 30 if num == 5

使用break与if将break condtion组成了一个命令

===================================================================

continue：继续执行直到遇到下一个断点为止

tbreak：设置临时断点，断点的有效期限只到首次到达所指定的行为止。

===================================================================

设置监视点以应对变量值的改变

在程序执行期间，假设要在变量z改变值时查看程序的状态，可以执行如下命令：
	
    (gdb) watch z

当运行程序时，每当z的值发生改变的时候GDB都会暂停。

更好的方法是，可以给予条件表达式来设置监视点。

例如：假设要查找程序执行期间z的值大于28的第一个位置，可以设置基于一个表达式（z>28）来监视

	(gdb) watch (z>28)

===================================================================

**frame与backtraces**

在函数调用期间，与调用相关的运行时信息被存储在栈帧的内存区域中，帧中包含函数的局部变量的值，
形参，以及调用该函数的位置信息。


每次发生函数调用时都会创建一个新帧，并将其推到一个系统维护的栈上；

栈最上方的帧表示当前正在执行的函数。

函数退出时，这个帧被弹出并且释放。

比如我们在Mysort与sort函数上设置了断点并且Mysort调用了sort函数，那么当运行至Mysort时，我们继续运行至sort断点，此时我可可能想看sort的帧

	(gdb) frame 0
    
我们也可能想要查看sort的父帧Mysort
	
    (gdb) frame 1

GDB的frame中当前正在执行的函数的帧被编号为0，其父帧(也就是该函数的调用者的帧)编号为1，父帧的父帧别编号为2，以此类推。
up命令将跳到调用栈中的下一个父帧，例如从帧0到帧1，down则想相反方向。

GDB的把吹空调桡侧会显示整个栈，显示所在的所有帧集合。

backtraces命令会显示整个栈，即当前存在的所有帧的集合！

===================================================================

当我们使用gdb的p打印某个变量时候总是看到的是$1 = …… $2 = ……等等，其中$1标签意味着正视你要求输出的第一个值。($1 $2 $3……这些称为调试回话的值历史，这个值历史是非常的有用的！)

===================================================================

段错误的原因：程序试图访问不允许访问的内存，通常是由于数组下标越界、采用了错误的指针值、也可能是由于没有显式地包含指针或数组变量的内存引用！
比如scanf("%d", num);缺少了&符号

===================================================================

GDB的暂停机制

有三种方式可以通知GDB暂停程序的执行

断点: 通知GDB在程序中特定位置暂停执行

监视点: 通知GDB当特定内存位置(或设计一个或多个位置的表达式)的值发生变化时暂停执行

捕获点: 通知GDB当特定时间发生时暂停执行，可以捕获抛出异常、捕获异常、发出信号等等事件

这三个机制都称为断点；

delete可以删除这些断点；

clear仅清除break的断点；

===================================================================
break的使用方法：
1. break function 在function()函数处设置断点
2. break line_number 在活动代码文件的line_number行处设置断点
3. break filename:line_number 对源文件filename的line_number行处设置断点。如果filename不在当前工作目录中则要给出相对路径或者是完整路径。例如：break /source/bed.c:35
4. break filename:function在文件filename的函数function()入口处设置断点。重载函数或
使用同名静态函数(c语言中的static类型函数)的程序可能需要这种方式

* break断点的有效性或持续到删除、禁用或退出GDB
* tbreak设置临时断点；临时断点就是首次到达后会被自动删除的断点
* tbreak foo.c:10 在文件foo.c的第10行设置临时断点

===================================================================

break的其他参数

1. break + offset 或break - offset可以在当前选中栈帧中正在执行的源代码行前面或后面设置断点偏移行数。
2. break *address这种形式可以用来在虚拟内存地址处设置断点。对于共享库或是当前源代码不可用时是必须的。

这两个参数以后再调试内核漏洞时可能会用到！！

===================================================================

break的一个特例：

    int main()
    {
        int i;
        i = 3;
        ……
        return 0;
    }
当在main函数处设置断点，此时断点其实并不在main函数这一行上，而是在i = 3这一行上；
因为GDB会进行一些优化，注意一下就可以了！

===================================================================

##### 注意：
如果使用GDB调试程序时候，发现了程序的错误，不必退出GDB。

重新开一个新窗口，在新窗口中修改源程序。

重新编译链接，GDB中执行run时GDB会感知到代码已修改，并加载最新的程序！非常的方便！

===================================================================

GDB的断点保存在调试源码的目录中的.gdbinit启动文件中，这样你关机之后断点仍然是保存好了的！

===================================================================

GDB中查看变量的类型:
    struct {
        char* str;
        int len;
    }CString;
    
    CString p;

想要产看p变量的类型

    
    
    (gdb) ptype p
    type = struct {
        char *str;
        int len;
    } *
    (gdb) whatis p
    type = CString *
    


===================================================================

