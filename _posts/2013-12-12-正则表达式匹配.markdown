---
author: UCSHELL
comments: true
date: 2013-12-12 07:54:23+00:00
layout: post
slug: '%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%8c%b9%e9%85%8d'
title: 正则表达式匹配
wordpress_id: 1201
categories:
- THE SHELL
tags:
- 正则表达式
---

POSIX BRE和ERE都支持的meta(元)字符

    
    =====================================================================
    字符		BRE/ERE			含义
    ---------------------------------------------------------------------------------------------
    ^		BRE,ERE			锚定行或字符串的开始。如"^grep",匹配所有以grep开头的行;
    					BRE：仅仅在正则表达式的结尾处有特殊含义；
    					ERE：在正则表达式的任何地方都有特殊含义；
    ---------------------------------------------------------------------------------------------
    $		BRE,ERE			锚定行或字符串的结束。如"grep$",匹配所有以grep结尾的行;		
    					BRE：仅仅在正则表达式的结尾处有特殊含义；
    					ERE：在正则表达式的任何地方都有特殊含义；
    ---------------------------------------------------------------------------------------------
    .		BRE,ERE			匹配任意一个非换行的字符。如"gr.p"匹配gr后接任意一个字符，之后是p
    ---------------------------------------------------------------------------------------------
    *		BRE,ERE			匹配另个或多个先前的字符。
    					如" *grep"匹配所有一个或多个空格后紧跟的grep行。				
    					注意:  .*代表匹配任意数量的不包含换行的字符；
    ---------------------------------------------------------------------------------------------
    [...]	BRE,ERE			方括号表达式，匹配方括号内任意一个字符。如"[Gg]rep"匹配Grep和grep。
    					连字符(-)表示连续字符的范围。如"[0-9]"匹配所有的单个数字;
    					^作为方括号的开始处，则表示相反的含义:不匹配方括号内的任意字符。
    					如:'[^A-FH-Z]rep'匹配不包含A-F和H-Z的作为开头，后面是rep的行。
    ---------------------------------------------------------------------------------------------
    \		BRE,ERE			转义字符，用于代开或关闭后续字符的特殊含义。如:\(\)
    =================================================================================================
    

BRE支持的meta字符
    
    
    =================================================================================================
    字符		BRE			含义
    ---------------------------------------------------------------------------------------------
    \(\)		BRE			标记匹配的字符，这个元字符将\(和\)之间的模式存储在保留空间中
    					在后续的正则表达式中可以通过转义序列应用这些匹配的模式。
    					例如:"\(grep\).*\1"就是匹配两个grep中带有任意数目的字符，
    					第二个grep使用'\'1来引用;
    					最多可以保留9个独立的模式，即'/1'到'/9';
    ---------------------------------------------------------------------------------------------
    \n		BRE			重复在\(与\)内的第n个模式，即上一个例子中的'/1'到'/9'。n是数字,n为1到9
    ---------------------------------------------------------------------------------------------
    x\{m,n\}	BRE			区间表达式，匹配x字符出现的次数区间至少出现m次，至多出现n次。
    						x\{n\}的含义是指x出现n次。				
    						x\{m,\}的含义是指x至少出现m次。	
    =================================================================================================
    



ERE支持的meta字符

    
    
    =====================================================================
    字符		BRE			含义
    ---------------------------------------------------------------------
    x{m.n}		ERE			如BRE的x\{m,n\}一样，只不过没有'\'
    ---------------------------------------------------------------------
    +		ERE			匹配前面正则表达式的一个或多个实例	
    ---------------------------------------------------------------------
    ?		ERE			匹配前面正则表达式的零个或一个实例
    ---------------------------------------------------------------------
    |		ERE			匹配'|'前面或后面的正则表达式
    ---------------------------------------------------------------------
    ()		ERE			匹配用括号括起来的正则表达式群
    =====================================================================
    


grep中可以使用-E、-F开启egrep或fgrep的功能；

GNU的grep还支持一下的meta写法

    
    
    =====================================================================
    字符		含义
    ---------------------------------------------------------------------
    /<		锚定单词的开始。如"\<grep"匹配包含以grep开头的单词的行 
    --------------------------------------------------------------------- 
    \>		锚定单词的结束。如"grep\>"匹配包含以grep结尾的单词的行
    ---------------------------------------------------------------------
    \w		匹配文字和数字字符，也就是[A-Za-z0-9]。如"G\w*p"匹配以               
    		G后面加零个或多个文字或数字字符然后是p
    ---------------------------------------------------------------------
    \W		\w的反置形式，匹配一个或多个非单词字符，如点号，句号等。
    ---------------------------------------------------------------------
    \b		单词锁定符。
    		\b不匹配这些单词字符中的任何一个，他只是匹配一个位置。
    		如"\bgrep\b"只匹配grep,\b也就是单词的分界。
    		假如你要找hi后面不远处跟着一个Lucy，应该使用"\bhi\b.*\b\Lucy\b"
    =====================================================================
    
实例
    
    过滤ls -l输出的内容，只显示以'-'开头的行
    [root@localhost workspace]# ls -l | grep '^-'	
    -rw-r--r--  1 root root 1384 Dec  9 19:23 c.c		
    -rwxr-xr-x  1 root root 5969 Dec  9 19:23 main
    -rw-r--r--  1 root root   21 Dec  9 13:12 test.c
    [root@localhost workspace]# ls | grep '^-'
    
    #过滤ls输出的内容，只显示以'a'开头的行
    [root@localhost workspace]# ls | grep '^a'	
    apue
    [root@localhost workspace]# ls | grep '^c'
    c.c
    [root@localhost workspace]# ls | grep '^C'
    C++
    CRC16
    [root@localhost workspace]# ls | grep '^[Cc]'
    C++
    c.c
    CRC16
    [root@localhost workspace]# ls | grep ^[Cc]
    C++
    c.c
    CRC16
    #显示所有以c开头的文件中包含include的行。
    [root@localhost workspace]# grep 'include' c*	
    #include 
    #include 
    
    #显示在array.cpp和cc.c中包含include的行。
    [root@localhost 01]# grep 'include' array.cpp cc.c	
    array.cpp:#include 
    array.cpp:#include 
    cc.c:#include 
    
    #显示所有包含至少有5个连续小写字符的字符串的行。
    [root@localhost 01]# grep '[a-z]\{5\}' cc.c
    #include 
            a = getchar();
            printf("a = %d\n", a);
            return 0;
    
    cc.c文件内容如下
    [root@localhost 01]# cat cc.c
    #include 
    
    int main()
    {
            int a;
            a = getchar();
            printf("a = %d\n", a);
            return 0;
    }
    
    [root@localhost 01]# grep 'w\(es\)t.*\1' test
    west   include int long west
    [root@localhost 01]# cat test
    west   include int long west



如果west被匹配，es就会被存储在内存中，并标记为1，然后匹配任意个非换行字符(.*)，这些字符后面紧跟着另外一个es(\1)，如果找到了就显示该行，也可以使用grep的-E选项，这样就直接写成'w(es)t.*\1'就可以了。

