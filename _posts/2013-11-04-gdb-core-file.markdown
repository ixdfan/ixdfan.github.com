---
layout: post
title: GDB调试(四):core文件调试
categories:
- GDB
tags:
- GDB
---

========================================================================

核心文件中包含了程序崩溃时对程序状态的详细描述:

栈的内容：程序为多线程，那么就是各个线程中的栈

CPU寄存器的内容：程序是多线程的，则是各个线程中的一组寄存器的值

程序的静态分配变量的值:全局变量与static变量

========================================================================

核心文件的查看

核心文件的命名方式比较简单，都称为core

在GNU/Linux下，开始使用core.3928，其中3928的含义是创建core文件的进程ID
如何查看那个core文件时由那个程序产生的，使用
	
    file core

某些shell可能禁止核心文件的创建，在bash中可以使用
	
    ulimit -c n

来控制核心文件的大小，其中n是核心文件的最大大小，单位是千字节，超过nKB的核心文件都不会被创建。
如果没有指定n，则shell会显示核心文件上的当前限制。
如果想要创建任意大小的核心文件，可以使用
	
    ulimit -c unlimtied

    
    [root@localhost ~]# ulimit -c
    0
    [root@localhost ~]# ulimit -c unlimited
    [root@localhost ~]# ulimit -c
    unlimited

========================================================================

GDB调试实例:

    
    Init_CString():使用c风格字符串来初始化CString
    Delete_CString():CString是堆上分配的，所以必须回收资源
    Chomp():删除和返回CString的最后一个字符
    Append_Chars_To_CString():将C风格的字符串追加到CString之后
    
    typedef struct
    {
            char* str;
            int len;
    }CString;
    
    CString* Init_CString(char* str)
    {
            CString* p = malloc(sizeof(CString));
            p->len = strlen(str);//
    
            strncpy(p->str, str, strlen(str)+1);
            return p;
    }
    
    void Delete_CString(CString* p)
    {
            free(p);
    	free(p->str);
    }
    
    char Chmop(CString* cstring)
    {
            char lastchar = *(cstring->str + cstring->len - 1);
            *(cstring->str + cstring->len - 1) = '0';//
            cstring->len = strlen(cstring->str);
    
            return lastchar;
    }
    
    CString* Append_Chars_To_CString(CString* p, char* str)
    {
            char* newstr = malloc(p->len + 1);
            p->len = p->len + strlen(str);
    
            snprintf(newstr, p->len, "%s%s", p->str, str);	
            free(p->str);
            p->str = newstr;
    
            return p;
    }
    
    int main()
    {
            CString* mystr;
            char c;
    
            mystr = Init_CString("Hello!");
            printf("Init:\n str: %s len: %d\n", mystr->str, mystr->len);
            c = Chmop(mystr);
            printf("Chmop: '%c'\n str: %s len: %d\n", c, mystr->str, mystr->len);
            mystr = Append_Chars_To_CString(mystr, " world!");
            printf("Append:\n str: %s len: %d\n", mystr->str, mystr->len);
    
            Delete_CString(mystr);
    
            return 0;
    }


========================================================================

第一步：编译并运行:

    
    [root@localhost 03]# cc -g -W -Wall cstring.c -ocstring
    [root@localhost 03]# ./cstring
    Segmentation fault (core dumped)


我们需要做的第一件事情就是找到错误是在何处发生的，我们使用GDB分析core文件

========================================================================

    
    [root@localhost 03]# gdb cstring core.7992      
    Core was generated by `./cstring'.
    Program terminated with signal 11, Segmentation fault.
    #0  strncpy (s1=0x0, s2=0x80487aa "ello!", n=7) at strncpy.c:43
    43                *++s1 = c;
    (gdb) backtrace
    #0  strncpy (s1=0x0, s2=0x80487aa "ello!", n=7) at strncpy.c:43
    #1  0x08048502 in Init_CString (str=0x80487a9 "Hello!") at cstring.c:16
    #2  0x0804861e in main () at cstring.c:52


可以看到段错误发生在Init_CString函数中的strncpy函数，我们给他传递了一个NULL指针

========================================================================

将当前帧改为调用Init_CString函数的第一帧

    
    (gdb) frame 1
    #1  0x08048502 in Init_CString (str=0x80487a9 "Hello!") at cstring.c:16
    16              strncpy(p->str, str, strlen(str)+1);
    
    (gdb) p *p
    $1 = {str = 0x0, len = 6}	#可以看到我们传递的p->str是一个空指针


========================================================================

我们只为p分配了足够的空间用来存放一个指针和一个int整形，但是我们并没有为这个指针分配空间，所以我们应该为str指针分配空间

我们应该在Init_CString函数中为str指针分配一个空间
p->str = malloc(p->len + 1);

========================================================================

再次执行，发现Chmop函数最后输出的是Hello0而不是Hello

    
    (gdb) run
    Starting program: /root/workspace/GDB/03/main
    Init:
     str: Hello! len: 6
    Chmop: '!'
     str: Hello0 len: 6
    Append:
     str: Hello0 world len: 13


========================================================================

    
    (gdb) tb Chmop 
    Temporary breakpoint 1 at 0x8048545: file cstring.c, line 29.
    (gdb) run                                              
    The program being debugged has been started already.   
    Start it from the beginning? (y or n) y
    Temporary breakpoint 1, Chmop (cstring=0x804a008) at c.c:29
    29              char lastchar = *(cstring->str + cstring->len - 1);


我们可以发现原来是
*(cstring->str + cstring->len - 1) = '0';的错误，我们将结尾字符写成了'0'而不是'\0'，导致错误

========================================================================

    
    (gdb) run
    The program being debugged has been started already.
    Start it from the beginning? (y or n) y
    `/root/workspace/GDB/03/main' has changed; re-reading symbols.
    
    Starting program: /root/workspace/GDB/03/main
    Init:
     str: Hello! len: 6
    Chmop: '!'
     str: Hello len: 5
    Append:
     str: Hello world len: 12


再次执行，发现Append中Hello world是少了一个'!'，那问题就是在Append_Chars_To_CString函数中了

========================================================================

    
    CString* Append_Chars_To_CString(CString* p, char* str)
    37      {
    38              char* newstr = malloc(p->len + 1);
    39              p->len = p->len + strlen(str);
    40
    41              snprintf(newstr, p->len, "%s%s", p->str, str);
    42              free(p->str);


问题在哪里呢？

首先我们可以知道Append中len的大小是正确的(包含'!'的长度是12)，所以问题就是snprintf中了
因为我们制定的复制的字符个数为p->len,是不包含'\0'字符的，但是snprintf复制的最后一个字符一定是'\0'，所以导致了错误.

当snprintf要复制'!'符号的时候，他会判断这是复制的第几个字符，如果是第p->len个字符，那么他就是自动将'\0'填充进去

##### 注意：
int snprintf(char *str, size_t size, const char*format, ...);

**snprintf函数要复制的字符串的字数如果小于等于size，那么他会尽最大可能的复制，但是最后一个字符一定是'\0'**

========================================================================
