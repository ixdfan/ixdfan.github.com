---
layout: post
title: md5加密算法原理
categories:
- 加密解密
tags:
-
---

MD5是一种单向散列算法(HASH算法)，利用函数将任意长度信息压缩至某个固定长度
MD5的输入可以是任意长度的消息，其输出的是128位的消息散列值，因为md5的设计是针对32位处理器的，因此MD5内所有的基本运算都是针对32位运算单元的



####md5算法过程

> 填充消息
> 添加原始长度
> 初始化MD5参数
> 处理位操作函数
> 主要变换过程
> 合并
-------------------------------------------------------------------------------

#### 填充消息
任意长度的消息首先需要进行填充，使得填充后的消息总长度对512求余为448,填充的方法是在消息后面添加一位1,1之后全部补0,直到满足要求的位数

例如有一个数字，写成2进制后48位，那么就要填充(48+x) % 512 = 448,即x=400，所以需要填充400位，那么从左向右开始填充，例如48的二进制的 m001(m代表前面有很多位二进制，具体多少我们不关心) 那么我们就要补充400位，补充之后就是这样的 m00110000..0后面一共有399个0,因为还有一个1,所以刚好400位

#### 添加原始长度
在填充消息之后添加一个64位的二进制整数，其为原始消息的长度

例如之前我们原来有48为，那么就将48的二进制反倒刚刚填充过的400位之后，48的二进制不足64位，不足的就添0，添加之后的消息的总长度是512的倍数了

#### 初始化MD5参数

MD5中有4个32位缓冲区，分别是A、B、C、D，用来存储散列计算的中间结果和最终结果，这四个值成为链接变量
将四个值分别初始化,

	A = 0x01234567
	B = 0x89abcdef
	C = 0xfedcba98
	D = 0x76543210

#### 注意：
上面写的值低字节在前，高字节在后
如果是真正用代码实现的时候不能那样写，应该这样写

	A = 0x67452301
	B = 0xefcdab89
	C = 0x98badcfe
	D = 0x10325476


#### 处理位操作函数
以512位为单位对消息进行分组，对每组进行循环散列计算，每个分组的散列循环总共4轮，每轮循环都很相似，将每组512字节再次分，分成32字节为一组，可以分成16组，对32位的组进行操作，也就是需要进行16次操作

四轮用到的方法分别是：

	第一轮使用的函数
	FF(A, B, C, D, Mj, s, ti)    表示A = B + ((A + (F(B, C, D) + Mj + ti) << s))
	第二轮使用的函数
	GG(A, B, C, D, Mj, s, ti)    表示A = B + ((A + (G(B, C, D) + Mj + ti) << s))
	第三轮使用的函数
	HH(A, B, C, D, Mj, s, ti)    表示A = B + ((A + (H(B, C, D) + Mj + ti) << s))
	第四轮使用的函数
	II(A, B, C, D, Mj, s, ti)    表示A = B + ((A + (I(B, C, D) + Mj + ti) << s))


每轮中用到的函数

	F(X, Y, Z) = (X&Y) | ((~X) & Z)
	G(X, Y, Z) = (X&Z) | (Y & (~Z))
	H(X, Y, Z) = X^Y^Z
	I(X, Y, Z) = Y^(X|(~Z))

其中ti代表的是 2^32*abs(sin(i))的整数部分，s其实是一组数据而不是一个数据，这些数据是算法本身的规定,Mj(0 < j < 16)就是32位的那个组的数据

第一轮

	FF(A, B, C, D, M0  , 7  , 0xd76aa478); 	/* 1 */
	FF(D, A, B, C, M1  , 12 , 0xe8c7b756); 	/* 2 */
	FF(C, D, A, B, M2  , 17 , 0x242070db); 	/* 3 */
	FF(B, C, D, A, M3  , 22 , 0xc1bdceee); 	/* 4 */
	FF(A, B, C, D, M4  , 7  , 0xf57c0faf); 	/* 5 */
	FF(D, A, B, C, M5  , 12 , 0x4787c62a); 	/* 6 */
	FF(C, D, A, B, M6  , 17 , 0xa8304613); 	/* 7 */
	FF(B, C, D, A, M7  , 22 , 0xfd469501); 	/* 8 */
	FF(A, B, C, D, M8  , 7  , 0x698098d8); 	/* 9 */
	FF(D, A, B, C, M9  , 12 , 0x8b44f7af); 	/* 10 */
	FF(C, D, A, B, M10 , 17 , 0xffff5bb1);	/* 11 */
	FF(B, C, D, A, M11 , 22 , 0x895cd7be);	/* 12 */
	FF(A, B, C, D, M12 , 7  , 0x6b901122);	/* 13 */
	FF(D, A, B, C, M13 , 12 , 0xfd987193);	/* 14 */
	FF(C, D, A, B, M14 , 17 , 0xa679438e);	/* 15 */
	FF(B, C, D, A, M15 , 22 , 0x49b40821);	/* 16 */

第二轮

	GG(A, B, C, D, M1  ,  5  , 0xf61e2562); 	/* 17 */
	GG(D, A, B, C, M6  ,  9  , 0xc040b340); 	/* 18 */
	GG(C, D, A, B, M11 ,  14 , 0x265e5a51);		/* 19 */
	GG(B, C, D, A, M0  ,  20 , 0xe9b6c7aa); 	/* 20 */
	GG(A, B, C, D, M5  ,  5  , 0xd62f105d); 	/* 21 */
	GG(D, A, B, C, M10 ,  9  , 0x02441453);		/* 22 */
	GG(C, D, A, B, M15 ,  14 , 0xd8a1e681);		/* 23 */
	GG(B, C, D, A, M4  ,  20 , 0xe7d3fbc8); 	/* 24 */
	GG(A, B, C, D, M9  ,  5  , 0x21e1cde6); 	/* 25 */
	GG(D, A, B, C, M14 ,  9  , 0xc33707d6);		/* 26 */
	GG(C, D, A, B, M3  ,  14 , 0xf4d50d87); 	/* 27 */
	GG(B, C, D, A, M8  ,  20 , 0x455a14ed); 	/* 28 */
	GG(A, B, C, D, M13 ,  5  , 0xa9e3e905);		/* 29 */
	GG(D, A, B, C, M2  ,  9  , 0xfcefa3f8); 	/* 30 */
	GG(C, D, A, B, M7  ,  14 , 0x676f02d9); 	/* 31 */
	GG(B, C, D, A, M12 ,  20 , 0x8d2a4c8a);		/* 32 */
	
第三轮

	HH(A, B, C, D, M5  ,  4  , 0xfffa3942); 	/* 33 */
	HH(D, A, B, C, M8  ,  11 , 0x8771f681); 	/* 34 */
	HH(C, D, A, B, M11 ,  16 , 0x6d9d6122);		/* 35 */
	HH(B, C, D, A, M14 ,  23 , 0xfde5380c);		/* 36 */
	HH(A, B, C, D, M1  ,  4  , 0xa4beea44); 	/* 37 */
	HH(D, A, B, C, M4  ,  11 , 0x4bdecfa9); 	/* 38 */
	HH(C, D, A, B, M7  ,  16 , 0xf6bb4b60); 	/* 39 */
	HH(B, C, D, A, M10 ,  23 , 0xbebfbc70);		/* 40 */
	HH(A, B, C, D, M13 ,  4  , 0x289b7ec6);		/* 41 */
	HH(D, A, B, C, M0  ,  11 , 0xeaa127fa); 	/* 42 */
	HH(C, D, A, B, M3  ,  16 , 0xd4ef3085); 	/* 43 */
	HH(B, C, D, A, M6  ,  23 , 0x04881d05); 	/* 44 */
	HH(A, B, C, D, M9  ,  4  , 0xd9d4d039); 	/* 45 */
	HH(D, A, B, C, M12 ,  11 , 0xe6db99e5);		/* 46 */
	HH(C, D, A, B, M15 ,  16 , 0x1fa27cf8);		/* 47 */
	HH(B, C, D, A, M2  ,  23 , 0xc4ac5665); 	/* 48 */

第四轮

	II(A, B, C, D, M0  , 6	, 0xf4292244); 	/* 49 */
	II(D, A, B, C, M7  , 10	, 0x432aff97); 	/* 50 */
	II(C, D, A, B, M14 , 15	, 0xab9423a7);	/* 51 */
	II(B, C, D, A, M5  , 21	, 0xfc93a039); 	/* 52 */
	II(A, B, C, D, M12 , 6	, 0x655b59c3);	/* 53 */
	II(D, A, B, C, M3  , 10	, 0x8f0ccc92); 	/* 54 */
	II(C, D, A, B, M10 , 15	, 0xffeff47d);	/* 55 */
	II(B, C, D, A, M1  , 21	, 0x85845dd1); 	/* 56 */
	II(A, B, C, D, M8  ,  6	, 0x6fa87e4f); 	/* 57 */
	II(D, A, B, C, M15 , 10	, 0xfe2ce6e0);	/* 58 */
	II(C, D, A, B, M6  , 15	, 0xa3014314); 	/* 59 */
	II(B, C, D, A, M13 , 21	, 0x4e0811a1);	/* 60 */
	II(A, B, C, D, M4  ,  6	, 0xf7537e82); 	/* 61 */
	II(D, A, B, C, M11 , 10	, 0xbd3af235);	/* 62 */
	II(C, D, A, B, M2  , 15	, 0x2ad7d2bb); 	/* 63 */
	II(B, C, D, A, M9 ,  21	, 0xeb86d391); 	/* 64 */

每一轮结束后结果进行累加
A = A1 + A2 + A3 + A4
B = B1 + B2 + B3 + B4
C = C1 + C2 + C3 + C4
D = D1 + D2 + D3 + D4

将A、B、C、D带入下一轮运算已知道四轮结束

#### 合并

四N轮运算之后的A、B、C、D组成最终的128位结果
其中A是低位，D是高位，即输出DBCA就是真正的值

可以使用一个数组int a[4]，分别存储D，C，B，A，然后以十六进制依次打印



