---
author: UCSHELL
comments: true
date: 2013-11-11 15:56:05+00:00
layout: post
slug: '%e5%ae%88%e6%8a%a4%e8%bf%9b%e7%a8%8b%e7%9a%84%e5%ae%9e%e7%8e%b0'
title: 守护进程的实现
wordpress_id: 956
categories:
- THE LINUX
tags:
- 守护进程
---

守护进程(daemon)

守护进程因为没有控制终端，所以他们是在后台运行

	ps -axj
	-a的含义为显示由其他用户所拥有的进程的状态
	-x显示没有控制终端的进程状态
	-j显示与作业有关的信息：回话ID、进程组ID、控制终端、终端进程组ID

系统进程依赖于操作系统的实现，父进程ID为0的各种进程通常是内核进程，他们作为系统自举的一部分而启动。init是此种进程的例外，他是内核在自举时启动的用户层命令。内核进程是特殊的，通常存在于系统的整个生命周期内，他们以超级用户权限运行，无控制终端，无命令行。
进程1通常是init，他是一个守护进程，负责启动个运行层次的特定的系统服务。

**注意：**
绝大部分守护进程都已超级用户(ID为0)特权运行，没有一个守护进程具有控制终端，其终端名设置为问好(?)，终端前台进程组ID设置为-1.内核守护进程以无控制终端方式启动。

用户层守护进程缺少控制终端可能是守护进程调用setsid的结果;

所有用户层守护进程都是进程组的组长进程以及会话的首进程，而且是这些进程组和会话中唯一的进程，最后应当引起注意的是大多数守护进程的父进程是init进程

守护进程的编写：

**1.使用umask将文件模式创建屏蔽字设置为0**

由继承得来的文件模式创建的屏蔽字可能会拒绝设置某些权限。

例如：若守护进程要创建以个组可读、写的文件，而继承的文件模式创建屏蔽字可能屏蔽了这两种权限，于是所要求的组可读、写就不能起作用。

**2.调用fork，然后使父进程退出(exit)**

这样实现了以下几点：

第一，如果该守护进程是作为一条简单shell命令启动的，那么父进程终止使得shell认为这条命令已经执行完毕

第二，子进程继承了父进程的进程组ID，但具有一个新的进程ID，这样就保证了子进程不是一个进程组的组长进程。对于下一步的setsid就是一个必要的前提条件。

**3.调用setsid创建一个新会话**:

(a).成为新会话的首进程

(b).成为一个新进程组的组长进程

(c).没有控制终端

##### 注意：

对于V系统来将，建议此时再次调用fork，并使父进程终止，第二个子进程作为守护进程继续运行。这样就保证了该守护进程不是会话首进程。

**4.将当前工作目录改为根目录**

从父进程处稽查过来的当前工作目录可能在一个装配文件系统中。因为守护进程通常在系统再引导之前是一直存在的，所以如果守护进程的当前工作目录在一个装配文件系统中，那么该文件系统就不能被拆卸了，拆卸了则守护进程就没有了，这个与装配文件系统的原意不符

**5.关闭不需要的文件描述符**

这使得守护进程不在持有从父进程继承来的某些文件描述符(父进程可能是shell进程，也可能是其他进程)。

6.某些守护进程打开/dev/null使其具有文件描述符0、1、2，这样任何一个试图读标准输入、写标准输出或标准出错的库程序都不会产生任何的效果。因为守护进程并不与终端设备相关，所以不能在终端设备上显示器输出，也无处从用户那里接受输入，及时守护进程是从交互式会话启动的，但是因为守护进程是在后台运行的，所以登录会话的终止并不影响守护进程，如果其他用户在同以终端登录设备我们也不会再终端上见到守护进程的输出，用户也不可期望他们在终端上的输入会有守护进程读取。


