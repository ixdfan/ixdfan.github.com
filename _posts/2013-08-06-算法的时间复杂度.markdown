---
author: UCSHELL
comments: true
date: 2013-08-06 03:13:40+00:00
layout: post
slug: '%e7%ae%97%e6%b3%95%e7%9a%84%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6%e7%9a%84%e8%ae%a1%e7%ae%97'
title: 算法的时间复杂度
wordpress_id: 462
categories:
- THE ALGORITHM
tags:
- 时间复杂度
- 空间复杂度
---

时间复杂度以前一直懒得去搞明白，今天突然想到了，然后认真研读了一番，算是搞明白了

=========================================================

在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。

算法的时间复杂度，也就是算法的时间量度，记作：T(n}=0(f(n))。
它表示随问题规模n的增大，算法执行时间的埔长率和 f(n)的埔长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f( n)是问题规模n的某个函数。

=========================================================

判定一个算法的时间复杂度，其中函数中的常数和其他次要项都可以忽略，而只关注主项(最高阶项)的阶数

推倒大O阶的方法：

**1.用常数1取代运行时间中的加法常数**

**2.修改后的运行次数函数中只保留最高阶项**

**3.若果最高阶项目不是1，则去除这个项的常数**

=========================================================

分析算法的时间复杂度，关键就是要分析循环结构的运行情况

========================================================

线性阶

========================================================

    for(i=0; i<n; i++)
    {
	    /*时间复杂度为O(1)的步骤*/
    }
    //要执行n次时间复杂度为O(1)的步骤，所以时间复杂度为O(n)

========================================================

对数阶

========================================================
    int count = 1;
    while(count < n)
    {
        count = count * 2;
        /*时间复杂度为O(1)的步骤*/
    }
    //每次执行for中内容count就乘2，也就是要执行多少次count == n?
    即2^x == n，求得x的值为x = log2 (n)，所以循环的时间复杂度为O[log n]
    
========================================================

平方阶

========================================================

    int i, j;
    for(i=0; i<n; i++)
    {
        //时间复杂度为O(n)
        for(j=0; j<n; j++)
        {
        /*时间复杂度为O(1)的步骤*/
        }
    }
相对于外层for循环，内部时间复杂度为O(n),外部再循环n次
所以时间复杂度为O(n^2)

========================================================

    int i, j;
    for(i=0; i<m; i++)
    {
        //时间复杂度为O(n)
        for(j=0; j<n; j++)
        {
        /*时间复杂度为O(1)的步骤*/
        }
    }
外部循环次数改为m次，内部时间复杂度为O(n),外部再循环m次
所以时间复杂度为O(n*m)

========================================================

**总结：循环的时间复杂度等于循环体的复杂度乘以该循环的运行次数**

========================================================

    int i;
    for(i=0; i<n; i++)
    {
        //时间复杂度为O(n)
        for(j=i; j<n; j++) //j = i,而不是0
        {
        /*时间复杂度为O(1)的步骤*/
        }
    }
    
i = 0时，内部循环为n次

i = 1时，内部循环为n-1次

……

……

……

i = n-1时,内部循环为1次

总的执行次数为：

n+(n-1)+(n-2)+……+1 = n*(n+1)/2 = n^2/2 + n/2

因此时间复杂度为O(n^2)

========================================================

    void function(int count)
    {
        printf(count);
    }
    
    int i, j;
    for(i=0; i<n; i++)
    {
        function(i)
    }
function()时间复杂度为O(1);
所以整体的时间复杂度为O(n);

========================================================
    
    void function(int count)
    {
        int j;
        for(j=count; j<n; j++)
        {
        /*时间复杂度为O(1)的步骤*/
        }
    }
    
    int i, j;
    for(i=0; i<n; i++)
    {
    	function(i)
    }
与之前平方阶第三个例子的一样，不过是将内循环放到了函数中
所以最终时间复杂度为O(n^2)

========================================================
    
    void function(int count)
    {
        int j;
        for(j=count; j<n; j++)
        {
        /*时间复杂度为O(1)的步骤*/
        }
    }
    
    n++; //执行1次
    function(n); //执行n次
    for(i=0; i<n; i++) //执行(n^2/2 + n/2)次
    {
        function(i);
    }
    for(i=0; i<n; i++) //执行(n^2/2 + n/2)次
    {
        for(j=i; j<n; j++)
        {
        /*时间复杂度为O(1)的步骤*/
        }
    }
总的执行次数 = 1+n + (n^2+n)/2 + (n^2+n)/2
= n^2 + 2n + 1

所以最终的时间复杂度也是O(n^2)

========================================================

常见的时间复杂度
执行次数函数 复杂度
12 O(1)
2n+3 O(n)
3n^2+2n+1 O(n^2)
5log2(n)+20 O(logn)
2n+3nlog2(n)+19 O(nlogn)
6n^3+2n^2+3n+4 O(n^3)
2^n O(2^n)

========================================================

时间复杂度耗费时间从小到大的排列

O(1) < O(logn) <O(n) <O(nlogn) < O(n^2) <O(n^3) < O(2^n) < O(n!) < O(n^n)

一般的对于O(n!)与O(n^n)都是不去讨论的，因为没有意义，太耗费时间了

========================================================

算法的空间复杂度

\>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

算法的空间复杂度通过计算算法所需要的存储空间实现，算法空间复杂度的计算公式为S(n) = O(f(n))
其中n为问题的规模，f(n)为语句关于n所占存储空间的函数

\>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

我们在写代码时，完全可以用空间来换取时间，比如说，要判断某某年是不是闰年，你可能会花一点心思写了一个算法，而且由于是一个算法，也就意味着，每次给一个年份，都是要通过计算得到是否是闰年的结果。还有另一个办法就是，事先建立一个有2050个元素的数组（年数略比现实多一点），然后把所有的年份按下标的数字对应，如果是闰年，此数组项的值就是1，如果不是值为0。这样，所谓的判断某一年是否是闰年，就变成了查找这个数组的某一项的值是多少的问题。此时，我们的运算是最小化了，但是硬盘上或者内存中需要存储这2050个0和1。

算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地"进行的，是节省存储的算法；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。

\>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
