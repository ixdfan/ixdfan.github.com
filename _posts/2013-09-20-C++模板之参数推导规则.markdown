---
author: UCSHELL
comments: true
date: 2013-09-20 01:40:41+00:00
layout: post
slug: c%e6%a8%a1%e6%9d%bf%e4%b9%8b%e5%8f%82%e6%95%b0%e6%8e%a8%e5%af%bc%e8%a7%84%e5%88%99
title: C++模板之参数推导规则
wordpress_id: 702
categories:
- THE C&amp;C++
tags:
- 模板
---

参数推导规则主要有一下几点：

 ================================================================================ 

1. 如果某个函数的多个形参的类型是同一个模板类型形参，推断出来的函数的这些实参类型要完全匹配 

2. 如果模板函数的形参是非引用类型，忽略const 

3. 形参如果是const 引用或者指针，实参可以使非const引用或者指针，编译器会自动转换到const 

4. 非引用类型模板形参可以将数组或函数类型的实参转换成数组指针或函数指针 

5. 引用类型模板形参不能将将数组或函数类型的实参转换成数组指针或函数指针,参数推导将出错 

6. 可以根据函数指针推断模板实参 

7. 模板实参推断顺序是从函数返回值开始，从左至右逐一推导 

8. 为防止推导失败，可以在调用函数时显式指定模板参数类型 

================================================================================

实例：根据函数指针推断模板实参

    
    #include <iostream>
    #include <typeinfo>
    #include <string>
    using namespace std;
    template <typename T>
    int compare(const T& a, const T& b)
    {
            cout << "a = " << typeid(a).name() << endl;
            cout << "b = "<< typeid(b).name() << endl;
    }
    int main()
    {
            int (*pf)(const int&, const int&) = compare;
            pf(3, 4);
            return 0;
    }


================================================================================

其中最容易犯迷惑的是 *(5)引用类型模板形参不能将将数组或函数类型的实参转换成数组指针或函数指针,参数推导将出错 *

详情请参考文章[《模板引用的错误》](http://ucshell.com/archives/691)
