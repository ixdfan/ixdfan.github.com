---
layout: post
title: 守护进程的实现(未完)
categories:
- 进程
tags:
- 守护进程
---

守护进程
守护进程又称为精灵进程(daemon)，是生存较长的一种进程，他们常常在系统自举时候启动，仅在系统关闭时才会终止，因为他们没有控制终端，所以他们是在后台运行的。

ps -axj

	-a显示由其他用户所拥有的进程的状态，
	-x显示没有控制终端的进程状态
	-j显示与作业有关的信息：会话ID、进程ID、控制终端、以及终端进程组ID

    
    [root@localhost C++]# ps -axj
     PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND             
        0     1     1     1 ?           -1 Ss       0   0:02 /sbin/init          
        0     2     0     0 ?           -1 S        0   0:00 [kthreadd]          
        2     3     0     0 ?           -1 S        0   0:00 [migration/0]       
        2     4     0     0 ?           -1 S        0   0:00 [ksoftirqd/0]

    
    PPID:父进程ID
    PID:进程ID
    PGID:进程组ID
    SID:会话ID
    TTY:终端名称
    TPGID:终端进程组ID(与该控制终端相关的前台进程组)
    STAT:进程状态
    TIME:累计CPU时间
    UID:用户ID
    COMMAND:命令字符串


======================================================================

系统进程依赖于操作系统的实现，父进程ID为0的各进程通常是内核进程，他们作为系统自举的一部分而启动:

内核进程是特殊的，通常存在于系统的整个生命周期，他们以超级用户特权运行，无控制终端，无命令行；

##### 注意:
init是用户层命令，他的进程号为1，是内核在自举时候启动的用户层命令；

他是一个系统守护进程，负责启动各运行层次特定的系统服务。

======================================================================

##### 注意:

大多数守护进程都是以超级用户(UID=0)特权运行，没有一个守护进程具有控制终端，其终端名设置为问号(?)，终端前台进程组ID设置为-1。

内核守护进程以无控制终端方式启动，用户层守护进程缺少控制终端可能是守护进程调用了setsid的结果，所有用户层守护进程都是进程组的组长进程以及会话的首进程，而且是这些进程组会话中的唯一进程。

绝大多数的守护进程的父进程是init进程。

======================================================================

编写守护进程

1.使用umask将文件模式创建屏蔽字设为0:

由于继承得来的文件模式创建屏蔽字可能会拒绝设置某些权限。例如，若守护进程要创建一组可读、写的文件，而继承的文件模式创建屏蔽字可能屏蔽这两种权限。于是所要求的组可读、写就不能起作用；

2.调用fork，然后使父进程退出(exit):
这样做的目的在于:

1. 如果该守护进程是作为一条简单shell命令启动的，那么父进程终止使得shell认为这条命令已经执行完毕；

2. 子进程继承了父进程的进程组ID，但具有一个新的进程ID，这就保证了子进程不是一个进程组的组长进程，这对于下面的setsid调用是非常必要的前提条件。

3.调用setsid以创建一个新会话。

使用setsid会产生以下三个操作：

1. 使得该进程变为新会话的首进程，此时该进程是新会话中唯一的进程。(会话的首进程是创建该会话的进程)
2. 该进程成为一个新进程组的组长进程。新进程组ID是调用进程的进程ID。
3. 该进程没有控制终端，如果在调用setsid之前该进程有一个控制终端，那么这种联系也会被中断。

##### 注意：
在基于系统V的系统中，在此时再次调用fork，并使得父进程终止。第二个子进程作为守护进程继续运行，这样就保证了该守护进程不会是会话首进程。按照V系统的规则可以防止它取得控制终端。避免取得控制终端的另一种方法是无论何时打开一个终端设备都一定要指定O_NOCTT;

4.将当前工作目录更改为根目录。

从父进程处继承过来的当前工作目录可能装在一个装配文件系统中(比如U盘)。因为守护进程通常在系统再次引导之前一直存在的，所以如果守护进程的当前工作目录在一个装配文件系统中，那么该目录就不能被拆卸，这与装配文件系统的原意不符。

另外某些守护进程可能会把当前工作目录更改到某个指定的位置，在那里做他们的工作。

5.关闭不在需要的文件描述符。

这使守护进程不在持有从其父进程继承来的某些文件描述符(父进程可能是shell进程或其他某个进程)。

可以使用open_max或getrlimit函数来判定最高文件描述符值，并关闭直到该值所有的文件描述符。

6.某些守护进程打开/dev/null使其具有文件描述符0、1、2这样任何一个试图读标准输入、写标准输出货标准出错的库历程都不会产生任何效果。

因为守护进程并不与终端设备相关联，所以不能再终端设备上显示其输出，也无处从交互式用户那里接受输入。

也就是守护进程是从交互式会话启动的，但是因为守护进程在后台运行，所以登录会话的终止并不影响守护进程；

如果其他用户在同一终端设备上登录，我们也不会在该终端上见到守护进程的输出，用户也不可期望他们在终端上的输入会由守护进程读取。

======================================================================
