---
layout: post
title: Makefile中的变量
categories:
- Makefile
---

Makefile中使用变量：

在使用变量的值时要在变量前加$，如果想显示$,那么要用$$来表示，这种应用多出现在shell变量中。

例如：使用shell中的变量$?则要写成$$?

在很多情况下，用户应将编译器及变异选项定义为变量，这样增强了Makefile的灵活性，如果代码移植到了一个新的平台上，使用新的编译器，它的好处就显现出来了；

Makefile：
   
    CC = gcc	#编译器
    FLAGS = -c	#编译选项
    objects = main.o command.o display.o	\
    	insert.o serach.o
    edit: $(objects)
    	$(CC) $(objects) -omain
    main.o:main.c main.h
    	$(CC) $(FLAGS) main.c
    command.o:command.c command.h
    	$(CC) $(FLAGS) command.c
    	……


make中的变量定义：
    
    (1)=
    (2):=
    (3)？=

===================================================================================================
=左边是变量，右侧是变量的值，**右侧的变量的值可以定义在文件的任何一处，也就是说右侧变量不一定是已经定义好了的变量，可以在之后定义**

Makefile:

    
    foo = $(bar)
    bar = $(ugh)
    ugh = Hhu?
    
    all:
    	echo $(foo)



    
    [root@localhost 01]# make -s
    Hhu?


不过这样可能会有一种递归危险

	a = $(b)
	b = $(a)

这样会让make陷入无限变量的展开过程

===================================================================================================

:=操作符定义变量的值可以避免前面递归定义的危险，使用其定义变量时，前**面的变量不能使用后面定义的变量，只能使用之前已经定义好的变量**，如果使用前面未定义的变量，则该变量的值为空

    
    y := [$(x)]
    x := foo
    
    main:
            echo $(y)
    .PHONY:main



    
    [root@localhost 01]# make -s
    []

===================================================================================================

?=的含义是：

**如果变量之前没有被定义过，那么变量的值就被定义；**

** 如果变量的值之前被定义过，那么赋值语句什么也不做；**

    
    a := hello
    b ?= world
    a ?= HELLO
    all:
            @echo $(a)
            @echo $(b)
    .PHONY:all

输出
    
    [root@localhost 01]# make
    hello
    world


变量a在a ?= HELLO之前已经定义过，所以赋值语句什么也不做

===================================================================================================

追加变量的值

Makefile允许给一个变量追加一个值，符号位"+="

    
    object = main.o foo.o bar.o utils.o
    object += anothre.o
    以上等价于
    object = main.o foo.o bar.o utils.o
    object = $(object) another.o


**如果变量之前没有定义过，那么"+="会自动变成"=";**

** 如果前一次为变量定义时使用的是":="操作符，"+="会以":="为其赋值**

    
    object := main.o foo.o bar.o utils.o
    object += anothre.o
    等价于
    object := main.o foo.o bar.o utils.o
    object := $(object) another.o

===================================================================================================

Makefile中的自动化变量

    
    ===================================================================================================
      $@	|	表示规则中的目标文件集
    ===================================================================================================
      $%	|	仅当目标是函数库文件时，表示规则中的目标成员名
    		|	例如如果一个目标是foo.a(bar.o)那么$%就是bar.o
		|	$@就是foo.a。如果目标不是函数库文件，其值为空
    ===================================================================================================
      $<	|	依赖列表中的第一个依赖的名字
    ===================================================================================================
      $?	|	所有比目标新的依赖的集合，以空格分隔
    ===================================================================================================
      $^	|	所有依赖的集合，以空格分隔。如果在依赖中有多个重复的，
		|	那么这个变量会去除重复的依赖，只保留一份
    ===================================================================================================
      $+	|	与$^类似，不过他不会去除重复的依赖
    ===================================================================================================
      $*	|	表示目标模式中"%"及其之前的部分
    ===================================================================================================


上述自动化变量中,$@ 、$< 、$% 、$*在扩展时只有一个文件，而另三个的值是一个文件列表

===================================================================================================

使用条件判断

条件表达式语法：

	endif
	或
	else
	endif

===================================================================================================

表示条件关键字，共有4个条件关键字

    
    ifeq:如果相等则执行
    ifeq (, )
    ifeq'' ''
    ifeq"" ""
    ifeq '' ""
    比较参数arg1与参数arg2是否相同，相同则表达式为真，否则为假。
    
    ifneq:如果不相等则执行
    ifneq(, )
    ifneq'' ''
    ifneq"" ""
    ifneq '' ""
    比较参数arg1与参数arg2是否不相同，不同则表达式为真，否则为假。
    
    ifdef:如果值非空则执行
    ifdef
    判断表达式variable-name的值，如果非空则为真，否则为假


##### 注意:
ifdef只测试变量是否有值，并不会把变量扩展到当前位置

    
    ifndef:如果值非空则执行
    ifndef
    判断表达式variable-name的值，如果为空则为真，否则为假
    该表达式同样不会将变量展开


##### 注意：
在的行中，允许有多个空格，但是不允许以Tab键作为开始,else与endif同样不能以Tab作为开始

Makefile

    
    var1 =
    var2 = hello
    
    all:
    ifdef $(var1)	#如果var1不为空则$(var) = hello
            var1 = hello
    endif
    
    ifeq ($(var1), $(var2))
            echo "they are equal"
    else
            echo "they are not equal"
    endif
    
    .PHONY:all



    
    [root@localhost 01]# make -s
    they are not equal


===================================================================================================
