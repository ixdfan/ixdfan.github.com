---
layout: post
title:  内存对齐的实现
description: 
modified: 
categories: 
- kernel 
tags:
- 
---


首先我们看如何计算倍数的问题:

其实这个原理是比较简单的,例如:

size = 8;

8的二进制====>1000

如果一个数是8的倍数那么它的二进制形式一定要满足至少为1000的形式,并且我们知道后面的3个0加起来最多也就是7,如果存在后面3位的话,那么一定不是8的整数倍!所以我们要做的就是将这个数的后面三位都给它变成0,那么它一定就是8的倍数了!当然整数0也算8的倍数

	9===========>1001	非8的倍数
	15==========>1111	后三位都是1的话也没有达到8,而是7,所以只要后三位上有非0的数那么他就一定不是8的倍数
	24==========>11000	8的倍数
	16==========>10000	8的倍数
	============111000	是多少自己计算吧!但是一定是8的倍数


从上面的几个可以看到,8的倍数一定满足后三位为0这个条件,当然0也是8的倍数,所以第4位也可以是0,其他位任意!


其他的也是同理:

比如4=====>0100,必须满足后两位一定是0的条件


#### 注意:
size只能是2的幂次方,比如2, 4, 8, 16, 32, 64...

================================

再看内存对齐的计算方法:

	addr_ptr addr;		/*	addr是地址指针	*/
	int size = 8;
	
如果我们要将地址addr以size对齐,那么addr地址一定是size的倍数

假设addr地址是9其二进制是1001, 那么如果想要是其变为8的倍数,只要将其后面3位变成0即可

	addr = 9 		=======>01001
	size - 1 = 7 	=======>00111
	~(size-1) 		=======>11000		/*	这个便可以将后三位置0了	*/
	addr & ~(size-1)=====> 将最后三位置0,变成了1000	即8


可以将~(size-1)成为size的对齐掩码


内核中的的上下取整:

	#define _ALIGN_UP(addr,size)    (((addr)+((size)-1))&(~((size)-1)))		
	#define _ALIGN_DOWN(addr,size)  ((addr)&(~((size)-1)))


#### 注意:

向上取整就是说原本是9,自然希望取得比9大的同时是8的倍数;

向上取整比较简单,要比9大一些,直接加上8,不久可以了吗?

但是如果原本就是8的倍数,比如原来是16,在加上8就是24了,但是应该返回的是16,这样就出错了!

所以应该退一位加上(8-1),在与size的对齐掩码进行操作即可



