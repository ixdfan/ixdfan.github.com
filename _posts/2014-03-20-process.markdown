---
layout: post
title:  操作系统的进程
description: 
modified: 
categories: 
-  THE LINUX
tags:
- process

---

##### 进程是系统资源分配的最小单位

一个进程就是一个执行程序的实例，包括程序计数器、寄存器和变量的当前值；

为了使参与并发执行的程序(含数据)能够独立的运行，必须为之配置一个专门的数据结构，称为进程控制块(PCB)，系统利用PCB来描述进程的基本情况和运行状态。

##### 程序段、相关数据段、PCB三部分构成了进程映像(进程实体)。

创建进程实际上是创建进程映像中的PCB；撤销进程是指上是撤销进程的PCB。

##### 注:
程序映像是静态的，进程则是动态的。

#### PCB是进程存在的唯一标志！


##### 注:
程序计数器:用于存放下一条指令所在单元的地址(就像汇编中的CS:IP寄存器作用类似)

每个进程拥有他自己的虚拟CPU，实际上真正的CPU在各个进程之间来回切换;

在一台多道程序计算机内存中有4道程序，这4道程序被抽象为四个各自拥有自己控制流程的进程(也就是每个程序拥有自己的程序计数器)，每个进程独立的运行；

但是实际上只有一个物理程序计数器，所以在每个程序运行时，他的逻辑程序计数器被装入实际的程序计数器中，当该程序执行结束(或暂停执行)时，屋里程序计数器被保存在内存中改程序的逻辑程序计数器中。

任何一个给定的瞬间仅有一个进程在真正运行，虽然一段时间后，所有的进程都运行了。

如果一个程序运行两遍则算作两个进程，两个进程恰好运行同一个程序，但是操作系统能够使他们共享代码，因此只有一个副本放在内存中。

在linux中可以使用fork来创建新进程，这个系统调用会创建一个与调用进程相同的副本，并且两个进程(父、子进程)拥有相同的存储映像，同样的环境字符串和同样的打开文件。通常子进程会接着执行一个execve或类似的系统调用，以修改其存储映像并运行一个新的程序。

例如:用户在shell中使用sort时候，shell就先创建一个子进程，然后这个子进程执行sort；

之所以要分两步建立进程，是为了在fork之后但在execve之前允许该子进程处理其文件描述符，这样可以完成对标准输入、标准输入、标准错误的重定向。

进程创建后，父进程和子进程有各自不同的地址空间，如果其中某个进程在其他地址空间中修改一个字，这个修改对其他进程而言是不可见的，linux中子进程的出事地址空间是父进程的一个副本，但是是两个不同的地址空间，不可写的内存区是共享的。

##### 进程的状态
	
	cat text1 text2 text3 | grep free

第一个进程运行cat，将三个文件链接并输出，第二个进程运行grep，根据两个进程的相对速度，可能会出现以下情况:grep准备就绪可以运行，但是输入还没有完成，此时必须阻塞grep，直到输入到来；

当一个进程在逻辑上不能被运行的时候他就会被阻塞，典型的例子是他在等待可以使用的输入，
还有一种情况:一个概念上可以运行的程序被迫停止，因为操作系统调度另外一个进程占用CPU；
这两种情况是完全不同的，第一种情况进程挂起是进程自身固有的原因(在键入用户命令前，无法执行命令)；
第二种情况则是由系统技术上的原因引起的(没有足够CPU，所以不能使每个程序都有一台私有的处理器)；
进程的三种状态图:

![019](\uploads\2014\03\019.jpg)

##### 进程的三种状态:
* 运行态:此时刻进程实际占有CPU
* 就绪态:可运行，但是因为其他进程正在运行而暂时停止
* 阻塞态(等待态):除非某种外部事件发生(例如等待输入输出完成)，否则进程不能运行

就绪态是指进程仅仅缺少处理机，只要获得处理机就立即执行，万事俱备，只欠东风；

等待态是进程还需要除了处理机以外的其他资源或在等待某件事情

#### 进程状态的转换:
* 就绪态->运行态:调度程序为就绪状态的进程分配处理机后，进入运行状态
* 运行态->阻塞态:正在运行的进程因需要等待某事件(例如I/O操作)而无法运行，让出处理机
* 阻塞态->就绪态:进程所等待的事情发生了(I/O操作完成或中断结束)，进程就从阻塞状态进入就绪态
* 运行态->就绪态:在这运行的进程因时间片用完而被暂停运行；或者在可抢占调度方式中，一个优先级高的进程到来后，正在运行的优先级低的进程被强制撤下处理机，转换为就绪状态；

====================================
原语就是原子操作，要么全做，要么不做，一般是通过屏蔽中断来完成的。

#### 进程创建(创建原语)

操作系统创建一个新进程的过程如下:
* 1.为进程分配一个唯一的进程标识号，并申请一个空白的PCB(PCB是有限的)，若PCB申请失败则创建失败
* 2.为进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间(在PCB中体现),注意:如果资源不足(例如内存空间)，并不是创建失败，而是出于"等待状态"或称为"阻塞状态"，等待的是内存这个资源。
* 3.初始化PCB，主要包含初始化标志信息、初始化处理机状态信息和初始化处理机控制信息以及设计进程的优先级
* 4.如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。

#### 进程终止(撤销原语)

* 1.根据被终止进程的标识符检索PCB、从中读出该进程的状态
* 2.若被终止的进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程
* 3.该进程若还有子进程，则将所有的子进程终止
* 4.将进程所拥有的全部资源归还给父进程或是操作系统
* 5.将该PCB从所在队列(链表)中删除

#### 进程阻塞(阻塞原语)

进程的阻塞时进程本身的一种主动行为，所以只有处于运行状态的进程(拥有CPU)才可能转换为阻塞状态

* 1.找到将要被阻塞进程的标识号对应的PCB
* 2.若该进程为运行状态，则保护其现场，将其状态转为阻塞态，停止运行
* 3.把该PCB插入到相应事件的等待队列中去

#### 进程唤醒(唤醒原语)

* 1.找到将要被阻塞进程的标识号对应的PCB
* 2.将其从等待队列中移除，并置其状态为就绪状态
* 3.把PCB插入就绪队列中，等待调度程序调度

##### 注意:
Block原语与Wakeup原语是一对作用相反的原语，必须成对使用；

Block原语是由被阻塞进程自我调用实现的，Wakeup原语是一个与被唤醒进程相合作或是其他相关进程调用的实现。



#### 进程切换

通常的进程，其创建、撤销、以及要求由系统设备完成的IO操作都是利用系统调用，而进入内核，再由内核中相对应处理程序予以完成。
进程切换同样是在内核的支持下实现的，可以说任何进程都是在操作系统的内核系统下支持运行的，食欲内核紧密相关的。

进程的切换是指处理机从一个进程的运行转到了另一个进程上运行，这个过程，进程的运行环境产生了实质性变化；

* 1.保存处理机上下文，包括程序计数器和其他寄存器
* 2.更新PCB信息
* 3.把进程的PCB移入相应的队列，如就绪、阻塞队里
* 4.选择另一个进程执行，并更新其PCB
* 5.更新内存管理的数据结果
* 6.恢复处理机上下文

=====================================

### 进程的组织

#### 1.进程控制块

进程创建时，操作系统就创建一个PCB结构，之后就常驻内存，任意时刻可以存放，当进程结束时删除。

创建一个进程时，系统为该进程建立一个PCB，当进程执行时，系统通过其PCB连接进程的现行状态信息，以便对其进行控制和管理，当进程结束时，系统收回其PCB，该进程随之消亡。

##### PCB是进程实体的一部分，是进程存在的唯一标识

#### 2.程序段

程序段就是能被进程调度程序调度到CPU执行的代码段

##### 注意:程序可以被多个进程共享，即多个进程可以运行同一个程序；

#### 3.数据段

一个进程的数据段，可以是进程对应的程序加工处理的原始数据，又可以是程序执行时产生的中间或最终结果。

=============

### 进程的通信

#### 1.共享存储
通信的进程之间存在一块可以直接访问的共享空间，通过对这篇共享空间进行读/写操作实行进程之间的信息交换。
在对共享空间进行读/写操作时，需要使用同步互斥工具(如P、V操作)，对共享空间的读/写进行控制。

##### 共享存储分为两种:低级的基于数据结构的共享，高级的基于存储区的共享。

##### 注意:用户进程空间一般都是独立的，想要让两个用户进程共享空间必须通过特殊的系统调用事项，而进程内的现场时共享进程空间的。

#### 2.消息传递

#### 3.管道机制
管道是指用于连接一个读进程和写进程以实现他们之间通信的一个共享文件，有名pipe文件

====================================




