---
author: UCSHELL
comments: true
date: 2013-09-28 14:41:23+00:00
layout: post
slug: '%e5%83%b5%e6%ad%bb%e8%bf%9b%e7%a8%8b%e7%9a%84%e6%b7%b1%e5%85%a5%e6%8e%a2%e8%ae%a8'
title: 僵死进程的深入探讨
wordpress_id: 778
categories:
- LINUX
tags:
- fork
- 僵死进程
---

fork之后如果不wait则会产生什么？
为什么系统不自己回收僵尸进程？
在深信服一面过程中面试官问的我一个措手不及，我从来都没有想过这个问题！！！！
在网上查找了一下，还是找到了一点的！都是让参考APUE中进程控制
我打开了APUE，惊讶的发现，这么巧，我之前恰好看到这里停止了！就刚好没有看到原因！
现在开始我一定把APUE啃完！

====================================================================

##### 僵死进程产生的条件：
如果子进程先于父进程结束并且父进程没有收尸那么子进程就会成为僵死进程；
那么又两种情况：fork之后
1. 父进程中没有收尸措施(waitpid、wait)
2. 父进程有收尸措施(waitpid、wait)，但是子进程结束时，父进程还没有运行到waitpid

====================================================================

所以有两种方法来避免僵死进程,当我们只fork()一次后，存在父进程和子进程。这时有两种方法来避免产生僵尸进程：

1. 父进程调用waitpid()等函数来接收子进程退出状态。
2. 父进程先结束，子进程则自动托管到init进程（pid = 1）。

详情参考文章《[两次fork避免僵死进程](http://ucshell.com/archives/832)》

====================================================================

ID为0的进程通常是调度进程，常常被称为交换进程。这个进程是内核的一部分，它不会执行任何的磁盘上的程序，因此也被称为系统进程

ID为1通常为init进程，在自举过程结束时由内核调用。

ID为2的进程是页守护进程，负责支持虚拟存储系统的分页操作。

====================================================================


如果子进程在父进程之前终止，那么父进程如何能够做相应的检查时得到子进程的终止状态呢？？
这个问题的答案就是：
内核为每一个终止子进程保留了一定量的信息！所以当终止进程的父进程调用wait或waitpid时候，可以得到这些信息。
这些信息至少包括:**进程ID、进程的终止状态、该进程使用的CPU的总时间**!
内核可以释放终止进程所使用的所有存储区，关闭其所有打开的文件。
一个已经终止但是父进程尚未对其进行善后处理(获取终止子进程的有关信息，释放仍占用的资源)的进程被称为僵死进程《APUE》
这就是为什么系统不会自己去回收僵尸进程的原因了！因为**父进程需要从这个僵死进程中获取某些信息**

ps命令中将僵死进程的状态打印为Z

====================================================================
如果父进程在子进程之前结束呢？
对于父进程已经终止的所有进程，他们的父进程都改变为init进程，我们称这些进程由init领养；
主要的操作过程如下(**init如何成为所有孤儿进程的父进程**)：
**在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止的进程的子进程。**
** 如果是，则将该进程的父进程ID改为1(init的进程ID)，这种处理方法保证每一个进程都有一个父进程。**

最后一个问题是：
一个由init进程领养的进程终止时会发生什么？他会不会变为僵死进程？
答案:不会因为init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得终止状态。
这样也就防止了在系统中有很多的僵死进程。

一个init的子进程可能指的是init直接产生的进程；也可能是父进程终止，由init领养的进程
====================================================================
收尸的问题：
如果父进程先于子进程终止，则子进程被init进程（linux系统下是1号进程）收养，在这种情况下，如果子进程终止，由init进程收尸。
如果子进程先于父进程终止，而父进程没有调用wait/waitpid进行收尸，则子进程会出于僵尸进程状态，直到父进程终止后，处于僵尸进程状态的子进程被init进程收养，然后由init负责收尸。

**init进程负责为其下所有子进程收尸**
====================================================================
