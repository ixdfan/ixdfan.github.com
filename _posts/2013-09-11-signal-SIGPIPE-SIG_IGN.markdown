---
author: UCSHELL
comments: true
date: 2013-09-11 01:55:46+00:00
layout: post
slug: sigpipe%e4%bf%a1%e5%8f%b7%e4%b8%8esig_ign%e7%9a%84%e4%bd%bf%e7%94%a8
title: SIGPIPE信号与SIG_IGN的使用
wordpress_id: 561
categories:
- 信号
tags:
- 信号
---

前几天写的客户端程序今天在修改错误，客户端一但链接到服务器，发送数据就产生SIGPIPE信号

======================================================================

当服务器close一个连接时，若client端接着发数据。根据TCP协议的规定，会收到一个RST响应，client再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不要再写了。

又或者当一个进程向某个已经收到RST的socket执行写操作是，内核向该进程发送一个SIGPIPE信号。该
信号的缺省学位是终止进程，因此进程必须捕获它以免不情愿的被终止。

======================================================================

对于产生信号，我们可以在产生信号前利用方法 signal(int signum, sighandler_t handler) 设置信号的处理。如果没有调用此方法，系统就会调用默认处理方法：中止程序，显示提示信息(就是我们经常遇到的问题)。我们可以调用系统的处理方法，也可以自定义处理方法。

======================================================================
系统里边定义了三种处理方法：

1.SIG_DFL信号专用的默认动作:
* 如果默认动作是暂停线程，则该线程的执行被暂时挂起。当线程暂停期间，发送给线程的任何附加信号都不交付，直到该线程开始执行，但是SIGKILL除外。
* 把挂起信号的信号动作设置成SIG_DFL，且其默认动作是忽略信号 (SIGCHLD)。

2.SIG_IGN忽略信号
* 该信号的交付对线程没有影响
* 系统不允许把SIGKILL或SIGTOP信号的动作设置为SIG_DFL

3.SIG_ERR

======================================================================

使用signal(SIGPIPE, SIG_IGN), 这样产生 SIGPIPE 信号时就不会中止程序，直接把这个信号忽略掉。

======================================================================

调用以下代码，即可安全的屏蔽SIGPIPE：

    
    struct sigaction action;
    action.sa_handler = handle_pipe;
    sigemptyset(&action.sa_mask);
    action.sa_flags = 0;
    sigaction(SIGPIPE, &action, NULL);
    void handle_pipe(int sig)
    {
    //不做任何处理即可
    }


signal设置的信号句柄只能起一次作用，信号被捕获一次后，信号句柄就会被还原成默认值了。

sigaction设置的信号句柄，可以一直有效，直到你再次改变它的设置。

RST的含义为“复位”，它是TCP在某些错误情况下所发出的一种TCP分节。有三个条件可以产生RST:

1. SYN到达某端口但此端口上没有正在监听的服务器。
2. TCP想取消一个已有连接
3. TCP接收了一个根本不存在的连接上的分节。
