<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">高手之路</title>
<generator uri="https://github.com/jekyll/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml" />
<link rel="alternate" type="text/html" href="http://localhost:4000" />
<updated>2014-06-06T00:10:17+00:00</updated>
<id>http://localhost:4000/</id>
<author>
  <name>Neo</name>
  <uri>http://localhost:4000/</uri>
  <email>ucshell.neo@gmail.com</email>
</author>


<entry>
  <title type="html"><![CDATA[shell脚本的调试]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/06/05/shell-debug/" />
  <id>http://localhost:4000/2014/06/05/shell-debug</id>
  <published>2014-06-05T00:00:00+00:00</published>
  <updated>2014-06-05T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;hr /&gt;

&lt;h4&gt;1. 使用set命令&lt;/h4&gt;

&lt;p&gt;set命令设置选项-x或是xtrace时候,在运行脚本的时候除了正常的出处之外,还会显示出代码运行前每行代码的扩展命令和变量,方便的观察脚本运行的情况,确定出错的位置&lt;/p&gt;

&lt;p&gt;如果在脚本文件中加入命令 set -x,那么在set之后执行的每一条命令以及加在命令行中的任何参数都会被显示处理.每一行之前都会加上加号(+),提示塔式跟踪输出的标识,shell中执行的shell跟踪命令会加两个加号即&quot;++&quot;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
#filename:debug.sh
#set -x     #此时set -x被注释掉了

echo -n &quot;Can you write device drivers? &quot;
read answer
answer=`echo $answer | tr [a-z] [A-Z]`      #小写转大写

if [ &quot;$answer&quot; = Y ] ; then                 #$answer要使用&quot;&quot;,否则输入为空的时候会显示错误

    echo &quot;Wow, you must be very skilled&quot;
else

    echo &quot;Neither can I, I&#39;m just an example shell script&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@ script]# ./debug.sh 
Can you write device drivers? y
Wow, you must be very skilled
[root@ script]# ./debug.sh 
Can you write device drivers? n
Neither can I, I&#39;m just an example shell script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取消set -x的注释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
#filename:debug.sh
set -x      #取消注释               

echo -n &quot;Can you write device drivers? &quot;
read answer
answer=`echo $answer | tr [a-z] [A-Z]`      #小写转大写

if [ &quot;$answer&quot; = Y ] ; then         #$answer要使用&quot;&quot;,否则输入为空的时候会显示错误

    echo &quot;Wow, you must be very skilled&quot;
else

    echo &quot;Neither can I, I&#39;m just an example shell script&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@ script]# ./debug.sh 
+ echo -n &#39;Can you write device drivers? &#39;
Can you write device drivers? + read answer         #前部分为正常的输出
y
++ echo y           #++表示在shell中执行shell命令的跟踪调用
++ tr &#39;[a-z]&#39; &#39;[A-Z]&#39;
+ answer=Y
+ &#39;[&#39; Y = Y &#39;]&#39;
+ echo &#39;Wow, you must be very skilled&#39;
Wow, you must be very skilled
[root@ script]# ./debug.sh 
+ echo -n &#39;Can you write device drivers? &#39;
Can you write device drivers? + read answer
n
++ tr &#39;[a-z]&#39; &#39;[A-Z]&#39;
++ echo n
+ answer=N
+ &#39;[&#39; N = Y &#39;]&#39;
+ echo &#39;Neither can I, I&#39;\&#39;&#39;m just an example shell script&#39;
Neither can I, I&#39;m just an example shell script
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;set中关闭-x选项的方法是使用+x来关闭,这样就可以从某个点关闭选项,这在只需要调试一小段代码时候是非常有用的,只需要在代码错误区之前打开选项,在错误区域关闭选项就可以完成调试,这样就不会让程序显示一大堆无用信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
#filename:debug.sh
set -x              #开启

echo -n &quot;Can you write device drivers? &quot;
read answer
answer=`echo $answer | tr [a-z] [A-Z]`      #小写转大写
set +x              #在此处关闭, 一下内容不会跟踪
if [ &quot;$answer&quot; = Y ] ; then                 #$answer要使用&quot;&quot;,否则输入为空的时候会显示错误

    echo &quot;Wow, you must be very skilled&quot;
else

    echo &quot;Neither can I, I&#39;m just an example shell script&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出
    [root@ script]# ./debug.sh
    + echo -n &#39;Can you write device drivers? &#39;
    Can you write device drivers? + read answer         #前部分为正常的输出
    y
    ++ echo y               #++表示在shell中执行shell命令的跟踪调用
    ++ tr &#39;[a-z]&#39; &#39;[A-Z]&#39;
    + answer=Y
    + set +x                #set +x关闭了跟踪
    Wow, you must be very skilled
    [root@ script]# ./debug.sh
    + echo -n &#39;Can you write device drivers? &#39;
    Can you write device drivers? + read answer
    n
    ++ echo n
    ++ tr &#39;[a-z]&#39; &#39;[A-Z]&#39;
    + answer=N
    + set +x
    Neither can I, I&#39;m just an example shell script&lt;/p&gt;

&lt;hr /&gt;

&lt;h4&gt;2. echo简单的输出&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
#filename:debug.sh
set -x              #开启

echo -n &quot;Can you write device drivers? &quot;
read answer
answer=`echo $answer | tr [a-z] [A-Z]`      #小写转大写
set +x              #在此处关闭, 一下内容不会跟踪
if [ &quot;$answer&quot; = Y ] ; then                 #$answer要使用&quot;&quot;,否则输入为空的时候会显示错误

    echo &quot;Wow, you must be very skilled&quot;
    echo &quot;The answer is $answer&quot;
else

    echo &quot;Neither can I, I&#39;m just an example shell script&quot;
    echo &quot;The answer is $answer&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是这种方法很繁琐,每次用完后还要再删除echo的输出&lt;/p&gt;

&lt;hr /&gt;

&lt;h4&gt;3. echo调试层次输出&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
debug=1     #一键开启调试信息
test &quot;$debug&quot; -gt 0 &amp;amp;&amp;amp; echo &quot;Debug is on&quot;
echo -n &quot;Can you write device drivers? &quot;
read answer
test &quot;$debug&quot; -gt 0 &amp;amp;&amp;amp; echo &quot;The answer is $answer&quot;
answer=`echo $answer | tr [a-z] [A-Z]`

if [ &quot;$answer&quot; = Y ] ; then     

    echo &quot;Wow, you must be very skilled&quot;
    test $debug -gt 0 &amp;amp;&amp;amp; echo &quot;The answer is $answer&quot;
else

    echo &quot;Neither can I, I&#39;m just an example shell script&quot;
    test $debug -gt 0 &amp;amp;&amp;amp; echo &quot;The answer is $answer&quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用debug来开启或是关闭调试信息的输出,并且可以按照层次来显示信息,例如test $debug -gt 2,则将debug改为对应层次的值即可实现不同层次的输出&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/06/05/shell-debug/&quot;&gt;shell脚本的调试&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on June 05, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[内存对齐的实现]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/06/05/kernel-memory-align/" />
  <id>http://localhost:4000/2014/06/05/kernel-memory-align</id>
  <published>2014-06-05T00:00:00+00:00</published>
  <updated>2014-06-05T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;首先我们看如何计算倍数的问题:&lt;/p&gt;

&lt;p&gt;其实这个原理是比较简单的,例如:&lt;/p&gt;

&lt;p&gt;size = 8;&lt;/p&gt;

&lt;p&gt;8的二进制====&gt;1000&lt;/p&gt;

&lt;p&gt;如果一个数是8的倍数那么它的二进制形式一定要满足至少为1000的形式,并且我们知道后面的3个0加起来最多也就是7,如果存在后面3位的话,那么一定不是8的整数倍!所以我们要做的就是将这个数的后面三位都给它变成0,那么它一定就是8的倍数了!当然整数0也算8的倍数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;9===========&amp;gt;1001   非8的倍数
15==========&amp;gt;1111   后三位都是1的话也没有达到8,而是7,所以只要后三位上有非0的数那么他就一定不是8的倍数
24==========&amp;gt;11000  8的倍数
16==========&amp;gt;10000  8的倍数
============111000  是多少自己计算吧!但是一定是8的倍数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的几个可以看到,8的倍数一定满足后三位为0这个条件,当然0也是8的倍数,所以第4位也可以是0,其他位任意!&lt;/p&gt;

&lt;p&gt;其他的也是同理:&lt;/p&gt;

&lt;p&gt;比如4=====&gt;0100,必须满足后两位一定是0的条件&lt;/p&gt;

&lt;h4&gt;注意:&lt;/h4&gt;

&lt;p&gt;size只能是2的幂次方,比如2, 4, 8, 16, 32, 64...&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;再看内存对齐的计算方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;addr_ptr addr;      /*  addr是地址指针 */
int size = 8;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们要将地址addr以size对齐,那么addr地址一定是size的倍数&lt;/p&gt;

&lt;p&gt;假设addr地址是9其二进制是1001, 那么如果想要是其变为8的倍数,只要将其后面3位变成0即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;addr = 9        =======&amp;gt;01001
size - 1 = 7    =======&amp;gt;00111
~(size-1)       =======&amp;gt;11000       /*  这个便可以将后三位置0了  */
addr &amp;amp; ~(size-1)=====&amp;gt; 将最后三位置0,变成了1000    即8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以将~(size-1)成为size的对齐掩码&lt;/p&gt;

&lt;p&gt;内核中的的上下取整:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#define _ALIGN_UP(addr,size)    (((addr)+((size)-1))&amp;amp;(~((size)-1)))     
#define _ALIGN_DOWN(addr,size)  ((addr)&amp;amp;(~((size)-1)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;注意:&lt;/h4&gt;

&lt;p&gt;向上取整就是说原本是9,自然希望取得比9大的同时是8的倍数;&lt;/p&gt;

&lt;p&gt;向上取整比较简单,要比9大一些,直接加上8,不久可以了吗?&lt;/p&gt;

&lt;p&gt;但是如果原本就是8的倍数,比如原来是16,在加上8就是24了,但是应该返回的是16,这样就出错了!&lt;/p&gt;

&lt;p&gt;所以应该退一位加上(8-1),在与size的对齐掩码进行操作即可&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/06/05/kernel-memory-align/&quot;&gt;内存对齐的实现&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on June 05, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nginx的slab机制]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/06/02/nginx-share-memory/" />
  <id>http://localhost:4000/2014/06/02/nginx-share-memory</id>
  <published>2014-06-02T00:00:00+00:00</published>
  <updated>2014-06-02T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;Nginx的slab机制主要是两点:缓存与对齐;&lt;/p&gt;

&lt;p&gt;缓存就是预先分配,提前申请号内存并对被踩做好划分形成内存池;&lt;/p&gt;

&lt;p&gt;对齐就是内存的申请与分配总是按照2的幂次方进行,即内存的大小总是8,16,32,64等,例如虽然只申请33个字节内存,但是还是会分撇64字节大小的内存,虽然会浪费内存,但是对于性能有一个很高的提升,并且将内存碎片掌握在可控的范围之内.&lt;/p&gt;

&lt;p&gt;nginx的slab机制主要是和共享内存一起使用,对于共享内存,nginx在解析配置文件时候,将即将使用的共享内存全部以list链表的形式组织在全局变量cf-&gt;cycle-&gt;shared_memory,然后进行统一的内存分配.slab机制就是对这些内存进行进一步的内部划分与管理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;917 static ngx_int_t
918 ngx_init_zone_pool(ngx_cycle_t *cycle, ngx_shm_zone_t *zn)
919 {
920     u_char           *file;
921     ngx_slab_pool_t  *sp;
922 
923     sp = (ngx_slab_pool_t *) zn-&amp;gt;shm.addr;
924 
925     if (zn-&amp;gt;shm.exists) {
926 
927         if (sp == sp-&amp;gt;addr) {
928             return NGX_OK;
929         }
930 
931         ngx_log_error(NGX_LOG_EMERG, cycle-&amp;gt;log, 0,
932                       &quot;shared zone \&quot;%V\&quot; has no equal addresses: %p vs %p&quot;,
933                       &amp;amp;zn-&amp;gt;shm.name, sp-&amp;gt;addr, sp);
934         return NGX_ERROR;
935     }
936 
937     sp-&amp;gt;end = zn-&amp;gt;shm.addr + zn-&amp;gt;shm.size;
938     sp-&amp;gt;min_shift = 3;
939     sp-&amp;gt;addr = zn-&amp;gt;shm.addr;
940 
941 #if (NGX_HAVE_ATOMIC_OPS)
942 
943     file = NULL;
944 
945 #else
946 
947     file = ngx_pnalloc(cycle-&amp;gt;pool, cycle-&amp;gt;lock_file.len + zn-&amp;gt;shm.name.len);
948     if (file == NULL) {
949         return NGX_ERROR;
950     }
951 
952     (void) ngx_sprintf(file, &quot;%V%V%Z&quot;, &amp;amp;cycle-&amp;gt;lock_file, &amp;amp;zn-&amp;gt;shm.name);
953 
954 #endif (ngx_shmtx_create(&amp;amp;sp-&amp;gt;mutex, &amp;amp;sp-&amp;gt;lock, file) != NGX_OK) {
957         return NGX_ERROR;
958     }
959 
        /*  调用slab初始化操作   */
960     ngx_slab_init(sp);
961 
962     return NGX_OK;
963 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ngx_init_zone_pool是在共享内存分配好之后进行的初始化调用,在函数中又会调用slab的初始化函数ngx_slab_init&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;25 typedef struct {
26     ngx_shmtx_sh_t    lock;
27 
28     size_t            min_size;          /*  固定值为8,最小划分块的大小,即1 &amp;lt;&amp;lt; pool-&amp;gt;min_shift  */
29     size_t            min_shift;         /*  固定值为3   */
30     
31     ngx_slab_page_t  *pages;
32     ngx_slab_page_t   free;
33 
34     u_char           *start;
35     u_char           *end;
36 
37     ngx_shmtx_t       mutex;
38 
39     u_char           *log_ctx;
40     u_char            zero;
41 
42     void             *data;
43     void             *addr;
44 } ngx_slab_pool_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;共享内存的初始化布局图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/001.png&quot; alt=&quot;001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据图片可以看到共享内存的开始部分内存已经被用作结构体ngx_slab_pool_t的存储空间,这相当于是slab的额外开销,因为任何一种管理机制都需要有自己的一些控制信息需要存储,所以这些内存的使用无法避免. 剩下的内存才是被管理的主体.&lt;/p&gt;

&lt;p&gt;slab机制对内存进行两级管理,首先是page页,然后是page页内的slab块(简称为slot块),也就是说slot块是在page页内存的再一次管理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;76 void
77 ngx_slab_init(ngx_slab_pool_t *pool)
78 {
79     u_char           *p;
80     size_t            size;
81     ngx_int_t         m;
82     ngx_uint_t        i, n, pages;
83     ngx_slab_page_t  *slots;
84 
85     /* STUB */

        /*  ngx_slab_max_size是slots分配和pages分配的分隔点,
        *   大于等于该值则要从pages里分配,其值为2048
        */
86     if (ngx_slab_max_size == 0) {        
87         ngx_slab_max_size = ngx_pagesize / 2;
            /*  
            *   ngx_slab_exact_size的值为128,刚好能用一个uintptr_t类型的位图变量表示该页的划分;
            *   例如在4k的内存页,32位环境下,一个uintptr_t类型的位图变量最多可以对应表达32个划分块的状态
            *   所以要恰好完整的表示一个4K内存页的每一个划分块状态, 
            *   必须将这个4K内存页划分成32个块,即每块的大小为128
            */
88         ngx_slab_exact_size = ngx_pagesize / (8 * sizeof(uintptr_t));
89         for (n = ngx_slab_exact_size; n &amp;gt;&amp;gt;= 1; ngx_slab_exact_shift++) {
90             /* void */
91         }
92     }
93     /**/
94 
95     pool-&amp;gt;min_size = 1 &amp;lt;&amp;lt; pool-&amp;gt;min_shift;
96 
97     p = (u_char *) pool + sizeof(ngx_slab_pool_t);
98     size = pool-&amp;gt;end - p;
99 
100     ngx_slab_junk(p, size);
101 
102     slots = (ngx_slab_page_t *) p;
        /*  ngx_pagesize_shift值为12,对应ngx_pagesize(4096), 即4096=1&amp;lt;&amp;lt;12  */
103     n = ngx_pagesize_shift - pool-&amp;gt;min_shift;
104 
105     for (i = 0; i &amp;lt; n; i++) {
106         slots[i].slab = 0;
107         slots[i].next = &amp;amp;slots[i];
108         slots[i].prev = 0;
109     }
110 
111     p += n * sizeof(ngx_slab_page_t);
112 
113     pages = (ngx_uint_t) (size / (ngx_pagesize + sizeof(ngx_slab_page_t)));
114 
115     ngx_memzero(p, pages * sizeof(ngx_slab_page_t));
116 
117     pool-&amp;gt;pages = (ngx_slab_page_t *) p;
118 
119     pool-&amp;gt;free.prev = 0;
120     pool-&amp;gt;free.next = (ngx_slab_page_t *) p;
121 
122     pool-&amp;gt;pages-&amp;gt;slab = pages;
123     pool-&amp;gt;pages-&amp;gt;next = &amp;amp;pool-&amp;gt;free;
124     pool-&amp;gt;pages-&amp;gt;prev = (uintptr_t) &amp;amp;pool-&amp;gt;free;
125 
126     pool-&amp;gt;start = (u_char *)
127                   ngx_align_ptr((uintptr_t) p + pages * sizeof(ngx_slab_page_t),
128                                  ngx_pagesize);
129 
        /*  
        *   在末尾如果不够一个page内存页,则会被浪费掉
        *   一下代码是对最终可用内存的调整
        */
130     m = pages - (pool-&amp;gt;end - pool-&amp;gt;start) / ngx_pagesize;
        /*  m &amp;gt; 0则说明对齐操作导致实际可用的内存页减少*/
131     if (m &amp;gt; 0) {
132         pages -= m;         /*  pages去掉多出的部分,则刚好组成实际最终可用的pages的个数   */
133         pool-&amp;gt;pages-&amp;gt;slab = pages;
134     }
135 
136     pool-&amp;gt;log_ctx = &amp;amp;pool-&amp;gt;zero;
137     pool-&amp;gt;zero = &#39;\0&#39;;
138 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;slab机制对page页的管,初始结构如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/002.png&quot; alt=&quot;002&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;page的静态管理&lt;/h4&gt;

&lt;p&gt;slab对page页的静态管理主要体现在ngx_slab_page_t[K]和page[K]这两个数组上;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;16 typedef struct ngx_slab_page_s  ngx_slab_page_t;
17 
18 struct ngx_slab_page_s {
19     uintptr_t         slab;
20     ngx_slab_page_t  *next;
21     uintptr_t         prev;
22 };
23 
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;注意:&lt;/h5&gt;

&lt;p&gt;1.对齐是指实际page内存页按照ngx_pagesize大小对齐,从图中可以看到,原本start是那个虚线箭头的位置,对齐后就是实现箭头所在的位置,对齐能提高对内存页的访问速度,但是有一些内存浪费,并且末尾可能因为不够一个page内存页而被浪费掉(因为对齐的缘故),所以在ngx_slab_init函数的最末尾有一次最终可用内存页的准确调整.&lt;/p&gt;

&lt;p&gt;2.虽然一个页面管理结构(ngx_slab_page_t元素)与一个page内存页相对应,但因为有对齐消耗以及slot块管理结构体的占用(ngx_slab_page_t[n]数组),所以实际上页管理街头体数目比page页内存数目要多,即图中ngx_slab_page_t[N]到ngx_slab_pool_t[K-1]实际上没有对应的page页,所以这部分将会被忽视,虽然他们是存在的.&lt;/p&gt;

&lt;h4&gt;page的动态管理&lt;/h4&gt;

&lt;p&gt;动态管理即page页的申请和释放;&lt;/p&gt;

&lt;p&gt;page页被申请或释放,那么就有了响应的状态,使用或空闲状态;&lt;/p&gt;

&lt;h5&gt;page空闲状态的管理&lt;/h5&gt;

&lt;p&gt;nginx对空闲page页进行链式管理,链表的头节点pool-&gt;free,初始状态下链表如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/003.png&quot; alt=&quot;003&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是一个特别的链表,它的节点是一个数组,例如图中的ngx_slab_page_t数组就是一个链表节点,这个数组通过0号数组元素ngx_slab_page_t[0]接入到这个空闲page页链表内,整个数组的元素个数也记录在第0号元素的slab字段内&lt;/p&gt;

&lt;p&gt;子进程1从共享内存中申请1页,状态如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/004.png&quot; alt=&quot;004&quot; /&gt;&lt;/p&gt;

&lt;p&gt;子进程2从共享内存中申请2页,状态如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/005.png&quot; alt=&quot;005&quot; /&gt;&lt;/p&gt;

&lt;p&gt;子进程有释放刚刚申请的1页&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/006.png&quot; alt=&quot;006&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;释放page页被插入到链表头部&lt;/strong&gt;,如果子进程2接着释放其拥有的那2页内存,如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/007.png&quot; alt=&quot;007&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到nginx对空闲page页的链式管理不会进行节点合并,不过没有关系,因为page也既不是slab机制的最小管理单元,也不是其主要分配单元&lt;/p&gt;

&lt;h4&gt;slab的第二级管理--slot块&lt;/h4&gt;

&lt;p&gt;slot块是对每一个page内存的内部管理,它将page页划分成很多个小块,各个page页的slot块大小可以不相等,但是同一个page页内slot块大小一定相等,page页的状态通过其所在链表即可表明是否空闲,但是page页内的各个slot块的状态却需要一个额外的标记,nginx中具体实现采用的是位图,即每个bit位标记一个对应slot块的状态,1为使用,0未空闲.&lt;/p&gt;

&lt;p&gt;根据slot块大小的不同,每个page页可划分的slot块数也不同,从而需要的位图的大小也不同,每一个page页对应一个名为ngx_slab_page_t的管理结构,该结构体有一个uintptr_t类型的slab字段,在32位平台上uintptr_t占4个字节,即slba字段有32个bit位,如果page页划分的slot块数小于等于32,那么nginx直接利用该字段充当位图,在nginx内叫做exact划分,每个slot块的大小保存在全局变量ngx_slab_exact_size以及ngx_slab_exact_shift内.例如一个4k的page页,如果每个slot块大小为128字节,那么恰好可以分成32块.如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/008.png&quot; alt=&quot;008&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果划分的每个slot块比ngx_slab_exact_size还大,那么意味着一个page也划分的slot块数更少,所以此时依然可以使用ngx_slab_page_t结构体的slab字段作为位图,但是由于比ngx_slab_exact_size大的情况有很多种,因此需要将其具体大小记录下来,这个值同样记录在slab字段内.怎么记录呢?由于划分的时候是按照2的幂次方进行增长的,所以比ngx_slab_exact_size还大,那至少是ngx_slab_exact_size的2倍,那么此时划分的至少要减少slot块的一半,因此利用slab字段的一般bit位即可完成表示所有slot块的状态;&lt;/p&gt;

&lt;p&gt;具体的就是:slab字段的高端bit做位图,低端bit用于存储slot块大小.&lt;/p&gt;

&lt;p&gt;如果申请的内存大于等于ngx_slab_max_size,那么nginx直接返回一个page整页,此时已经不存在slot块管理了&lt;/p&gt;

&lt;p&gt;如果申请小于ngx_slab_exact_size时候,此时slot块的数目已经超过了slab位图可以表示的容量,比如按照8字节划分,那么1个4K的page页将会被划分成512块,表示slot块状态的位图也就需要512个bit位,一个slab字段明显是不够的,所以需要为位图另找存储空间,而slab字段仅仅用于存储slot块大小(仅仅存储其对应的位移数).&lt;/p&gt;

&lt;p&gt;另找的位图存储空间就落在page页内,具体就是其划分的前面几个slot块内,例如512个bit位的位图即64字节,而一个slot块内有8个字节,所以就需要占用page页的前8个slot块做位图,一个按8字节划分slot块的page页初始状态如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/009.png&quot; alt=&quot;009&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于前几个slot块一开始就被用作位图空间,所以必须将其对应的bit位设置为1,表示其状态为使用.其划分大小在slab字段内!&lt;/p&gt;

&lt;p&gt;不论哪种情况,都有了slot块的大小以及状态,这样分配与释放就简单了!&lt;/p&gt;

&lt;h4&gt;page的链式管理&lt;/h4&gt;

&lt;p&gt;首先根据每页划分的slot块大小将各个page页加入到不同的链表内,即按照8,16,32,64,128,256,512,1024,2048一共是9条链,在ngx_slab_init中有对应的初始化&lt;/p&gt;

&lt;p&gt;假设申请一块9字节的内存,那么slab机制将一共分配page那么多页,将它按照8字节做slot划分,并接入到链表slot[0]中&lt;/p&gt;

&lt;p&gt;继续申请8字节的内存不会分配新的page页,除非刚刚那页pageA被使用完了,一旦页A被使用完了,它会被拆除链表&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/010.png&quot; alt=&quot;010&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果继续申请8字节的内存,那么nginx的slab机制必须分配新的page页(简称页B),此时页B会被加入到链表内,此时链表中只有一个节点,但是如果此时页A释放了末个slot块,它又会被加入到链表内,最终形成了两个节点的链表&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/06/011.png&quot; alt=&quot;011&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/06/02/nginx-share-memory/&quot;&gt;nginx的slab机制&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on June 02, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[100介乘末尾有多少个零]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/20/the-algorithm-%E9%98%B6%E4%B9%98%E7%9B%B8%E5%85%B3/" />
  <id>http://localhost:4000/2014/05/20/the-algorithm-阶乘相关</id>
  <published>2014-05-20T00:00:00+00:00</published>
  <updated>2014-05-20T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;100!末尾有多少个零??&lt;/p&gt;

&lt;p&gt;网上都说在编程之美上有,但是我好像不记得看过!&lt;/p&gt;

&lt;p&gt;之前看到了一个非常好用的方法:&lt;/p&gt;

&lt;p&gt;计算方法如下:&lt;/p&gt;

&lt;p&gt;x为要计算的数,n为该结果末尾0的个数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = [x/5^1] + [x/5^2] + [x/5^3] + [x/5^4] + ....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[x]叫做高斯x,表示不大于x的最大整数&lt;/p&gt;

&lt;p&gt;其中[]是一个法则,具体规则如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1.2] = 1
[0.3] = 0
[-1.2] = -2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据这个方法我们可以快速计算出100!末尾0的个数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = [100/5] + [100/25] + [100/5^3] + ...
  = 20 + 4 + 0 + 0 + ...
  = 24
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;还有一道有意思的题目:&lt;/p&gt;

&lt;p&gt;1到100的阶乘的和的末位数是几？&lt;/p&gt;

&lt;p&gt;答案：3&lt;/p&gt;

&lt;p&gt;找规律，1!=1; 2!=2; 3!=6; 4!=24; 5!=120; 6!=120&lt;em&gt;6=720 7!=720&lt;/em&gt;7=5040&lt;/p&gt;

&lt;p&gt;5的阶乘之后的末尾都是0。所以只有1到4的阶乘会产生个位数，所以1+2+6+24=33，所以答案就是3！&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/20/the-algorithm-%E9%98%B6%E4%B9%98%E7%9B%B8%E5%85%B3/&quot;&gt;100介乘末尾有多少个零&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 20, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[kernel中min宏函数]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/20/kernel-macro-min-function/" />
  <id>http://localhost:4000/2014/05/20/kernel-macro-min-function</id>
  <published>2014-05-20T00:00:00+00:00</published>
  <updated>2014-05-20T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;pre&gt;&lt;code&gt;#define min(x,y) ({ \
    const typeof(x) _x = (x);   \
    const typeof(y) _y = (y);   \
    (void)(&amp;amp;_x == &amp;amp;_y);         \       
    _x &amp;lt; _y ? _x : _y;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sizeof(x)的作用是测量x的大小,typedef(x)的作用自然是获取x变量的类型&lt;/p&gt;

&lt;p&gt;(void)(&amp;amp;&lt;em&gt;x == &amp;amp;&lt;/em&gt;y)这句话的作用是用来判断类型是否一致的!之前一直没有搞明白这句话的用处!&lt;/p&gt;

&lt;p&gt;例如,我们定义了两个变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int     in = 5;
char    ch = &#39;6&#39;;

if (&amp;amp;in == &amp;amp;ch);    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果这样比较的话编译器会告诉你两种指针的类型不相同,会有警告或是错误提示&lt;/p&gt;

&lt;p&gt;例如以下程序:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@ work]# cat test.c 
#include &amp;lt;stdio.h&amp;gt;

#define min(x,y) ({ \
    const typeof(x) _x = (x);   \
    const typeof(y) _y = (y);   \
    (void)(&amp;amp;_x == &amp;amp;_y);         \       
    _x &amp;lt; _y ? _x : _y;})

Int main(int argc, char** argv)
{
    int a = 1;
    double d = 2;
    printf(&quot;%lf\n&quot;, min(a, d));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   [root@ work]# cc test.c -omain
   test.c:6:24: warning: backslash and newline separated by space [enabled by default]
   (void)(&amp;amp;&lt;em&gt;x == &amp;amp;&lt;/em&gt;y);   \&lt;br/&gt;
   ^
   test.c: In function ‘main’:
   test.c:6:13: warning: comparison of distinct pointer types lacks a cast [enabled by default]
   (void)(&amp;amp;&lt;em&gt;x == &amp;amp;&lt;/em&gt;y);   \&lt;br/&gt;
   ^
   test.c:13:18: note: in expansion of macro ‘min’
   printf(&quot;%lf\n&quot;, min(a, d));&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/20/kernel-macro-min-function/&quot;&gt;kernel中min宏函数&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 20, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nginx进程间通信]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/11/nginx-process-message/" />
  <id>http://localhost:4000/2014/05/11/nginx-process-message</id>
  <published>2014-05-11T00:00:00+00:00</published>
  <updated>2014-05-11T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;Nginx中采用的是socketpair来创建未命名套接字来进行父子进程之间通信的.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;22 typedef struct {
23     ngx_pid_t           pid;
24     int                 status;
25     ngx_socket_t        channel[2];
26 
27     ngx_spawn_proc_pt   proc;
28     void               *data;
29     char               *name;
30 
31     unsigned            respawn:1;
32     unsigned            just_spawn:1;
33     unsigned            detached:1;
34     unsigned            exiting:1;
35     unsigned            exited:1;
36 } ngx_process_t;

47 #define NGX_MAX_PROCESSES         1024

86 ngx_pid_t
87 ngx_spawn_process(ngx_cycle_t *cycle, ngx_spawn_proc_pt proc, void *data,
88     char *name, ngx_int_t respawn)
89 {
90     u_long     on;
91     ngx_pid_t  pid;
92     ngx_int_t  s;
93 
94     if (respawn &amp;gt;= 0) {
95         s = respawn;
96 
97     } else {
98         for (s = 0; s &amp;lt; ngx_last_process; s++) {
99             if (ngx_processes[s].pid == -1) {
100                 break;
101             }
102         }
103 
104         if (s == NGX_MAX_PROCESSES) {
105             ngx_log_error(NGX_LOG_ALERT, cycle-&amp;gt;log, 0,
106                           &quot;no more than %d processes can be spawned&quot;,
107                           NGX_MAX_PROCESSES);
108             return NGX_INVALID_PID;
109         }
110     }
111 
112 
113     if (respawn != NGX_PROCESS_DETACHED) {
114 
115         /* Solaris 9 still has no AF_LOCAL */
116 
117             /*  建立父子间的通信socket  */
118         if (socketpair(AF_UNIX, SOCK_STREAM, 0, ngx_processes[s].channel) == -1)
119         {
120             ngx_log_error(NGX_LOG_ALERT, cycle-&amp;gt;log, ngx_errno,
            ....
186 
187     pid = fork();
188 
189     switch (pid) {
190 
191     case -1:
192         ngx_log_error(NGX_LOG_ALERT, cycle-&amp;gt;log, ngx_errno,
193                       &quot;fork() failed while spawning \&quot;%s\&quot;&quot;, name);
194         ngx_close_channel(ngx_processes[s].channel, cycle-&amp;gt;log);
195         return NGX_INVALID_PID;
196 
197     case 0:
198         ngx_pid = ngx_getpid();
199         proc(cycle, data);
200         break;
201 
202     default:
203         break;
204     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在调用fork之前,先使用socketpair创建一堆socket描述符放在变量ngx_processes[s].channel中(s代表在ngx_processes中第一个可用元素的下标, 例如产生第一个进程时候,可用元素的下标为0),在fork之后由于子进程继承了父进程的资源,那么父子进程就都有了着一对socket描述符,Nginx将channel[0]给父进程时候,channel[1]给子进程使用,这样分别错开了不同socket描述符,即可实现父子进程之间的双向通信.&lt;/p&gt;

&lt;p&gt;除此之外各个子进程之间也可以进行双向通信,父子进程通信比较简单,而子进程之间通信channel的设定就涉及到了进程之间文件描述符的传递,因为虽然后生成的子进程通过继承的channel[0]能够向之前生成的子进程发送信息,但是在前生成的子进程无法获知在后生成的子进程的channel[0],而不能发送信息,所以在后生成的子进程必须利用已知的在前生成子进程的channel[0]进行主动告知.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;839 static void
840 ngx_worker_process_init(ngx_cycle_t *cycle, ngx_uint_t priority)
841 {
969     for (n = 0; n &amp;lt; ngx_last_process; n++) {
970 
971         if (ngx_processes[n].pid == -1) {
972             continue;
973         }
974 
975         if (n == ngx_process_slot) {
976             continue;
977         }
978 
979         if (ngx_processes[n].channel[1] == -1) {
980             continue;
981         }
982 
983         if (close(ngx_processes[n].channel[1]) == -1) {
984             ngx_log_error(NGX_LOG_ALERT, cycle-&amp;gt;log, ngx_errno,
985                           &quot;close() channel failed&quot;);
986         }
987     }
988 
989     if (close(ngx_processes[ngx_process_slot].channel[0]) == -1) {
990         ngx_log_error(NGX_LOG_ALERT, cycle-&amp;gt;log, ngx_errno,
991                       &quot;close() channel failed&quot;);
992     }
993 
994 #if 0
995     ngx_last_process = 0;
996 #endif
997 
998     if (ngx_add_channel_event(cycle, ngx_channel, NGX_READ_EVENT,
999                               ngx_channel_handler)      /*  回调函数    */
1000         == NGX_ERROR)
1001     {
1002         /* fatal */
1003         exit(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在子进程的启动初始化函数ngx_worker_process_init中,会将ngx_channel(也就是channel[1])加到读事件监听集中,对应的回调处理函数为ngx_channel_handler.&lt;/p&gt;

&lt;p&gt;父进程fork生成一个新的子进程之后会立即通过ngx_pass_open_channel函数把这个子进程的相关信息告知给前面已经生成的子进程.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;435 static void 
436 ngx_pass_open_channel(ngx_cycle_t *cycle, ngx_channel_t *ch)
437 {
438     ngx_int_t  i;
439 
        /*  遍历整个进程表   */
440     for (i = 0; i &amp;lt; ngx_last_process; i++) {
441 
            /*  如果遇到非存活的就直接跳过 */
442         if (i == ngx_process_slot
443             || ngx_processes[i].pid == -1
444             || ngx_processes[i].channel[0] == -1)
445         {
446             continue;
447         }
448 
449         ngx_log_debug6(NGX_LOG_DEBUG_CORE, cycle-&amp;gt;log, 0,
450                       &quot;pass channel s:%d pid:%P fd:%d to s:%i pid:%P fd:%d&quot;,
451                       ch-&amp;gt;slot, ch-&amp;gt;pid, ch-&amp;gt;fd,
452                       i, ngx_processes[i].pid,
453                       ngx_processes[i].channel[0]);
454 
455         /* TODO: NGX_AGAIN */
456 
            /*  对存活的进程告知其channel  */
457         ngx_write_channel(ngx_processes[i].channel[0],
458                           ch, sizeof(ngx_channel_t), cycle-&amp;gt;log);
459     }
460 }


13 ngx_int_t
14 ngx_write_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size,
15     ngx_log_t *log)
16 {
17     ssize_t             n;
18     ngx_err_t           err;
19     struct iovec        iov[1];
20     struct msghdr       msg;             /*  利用msghdr结构体来传递文件描述符   */
21 
22 #if (NGX_HAVE_MSGHDR_MSG_CONTROL)
23 
24     union {
25         struct cmsghdr  cm;
26         char            space[CMSG_SPACE(sizeof(int))];
27     } cmsg;
28 
29     if (ch-&amp;gt;fd == -1) {
30         msg.msg_control = NULL;
31         msg.msg_controllen = 0;
32 
33     } else {
34         msg.msg_control = (caddr_t) &amp;amp;cmsg;
35         msg.msg_controllen = sizeof(cmsg);
36 
37         cmsg.cm.cmsg_len = CMSG_LEN(sizeof(int));
38         cmsg.cm.cmsg_level = SOL_SOCKET;
39         cmsg.cm.cmsg_type = SCM_RIGHTS;
40 
41         /*
42          * We have to use ngx_memcpy() instead of simple
43          *   *(int *) CMSG_DATA(&amp;amp;cmsg.cm) = ch-&amp;gt;fd;
44          * because some gcc 4.4 with -O2/3/s optimization issues the warning:
45          *   dereferencing type-punned pointer will break strict-aliasing rules
46          *
47          * Fortunately, gcc with -O1 compiles this ngx_memcpy()
* in the same simple assignment as in the code above
49          */
50 
51         ngx_memcpy(CMSG_DATA(&amp;amp;cmsg.cm), &amp;amp;ch-&amp;gt;fd, sizeof(int));
52     }
53 
54     msg.msg_flags = 0;
55 
56 #else
57 
58     if (ch-&amp;gt;fd == -1) {
59         msg.msg_accrights = NULL;
60         msg.msg_accrightslen = 0;
61 
62     } else {
63         msg.msg_accrights = (caddr_t) &amp;amp;ch-&amp;gt;fd;
64         msg.msg_accrightslen = sizeof(int);
65     }
66 
67 #endif
68 
        /*  要传递的消息  */
69     iov[0].iov_base = (char *) ch;
70     iov[0].iov_len = size;
71 
72     msg.msg_name = NULL;
73     msg.msg_namelen = 0;
74     msg.msg_iov = iov;
75     msg.msg_iovlen = 1;
76 
        /*  利用sendmsg来传递文件描述符   */
77     n = sendmsg(s, &amp;amp;msg, 0);
78 
79     if (n == -1) {
80         err = ngx_errno;
81         if (err == NGX_EAGAIN) {
82             return NGX_AGAIN;
83         }
84 
85         ngx_log_error(NGX_LOG_ALERT, log, err, &quot;sendmsg() failed&quot;);
86         return NGX_ERROR;
87     }
88 
89     return NGX_OK;
90 }


17 typedef struct {
18      ngx_uint_t  command;
19      ngx_pid_t   pid;
20      ngx_int_t   slot;       /*  全局的下标 */
21      ngx_fd_t    fd;         /*  channel[0]  */
22 } ngx_channel_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到文件描述符的传递是通过sendmsg的方式来传递的,ch中包含了新创建文件描述符的pid,进程信息在全局数组里存储下标,socket描述符channel[0]的信息&lt;/p&gt;

&lt;p&gt;NGX_WRITE_CHANNEL通过继承的CHANNEL[0]描述符进行信息告知,收到这些消息的子进程将执行设置号的回调函数NGX_CHANNEL_HANDLER,将新接收的子进程相关信息存储在全局变量NGX_PROCESSES中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1071 static void
1072 ngx_channel_handler(ngx_event_t *ev)
1073 {
1074     ngx_int_t          n;
1075     ngx_channel_t      ch;
1076     ngx_connection_t  *c;
1077 
1078     if (ev-&amp;gt;timedout) {
1079         ev-&amp;gt;timedout = 0;
1080         return;
1081     }
1082 
1083     c = ev-&amp;gt;data;
1084 
1085     ngx_log_debug0(NGX_LOG_DEBUG_CORE, ev-&amp;gt;log, 0, &quot;channel handler&quot;);
1086 
1087     for ( ;; ) {
1088 
            /*  
            *   读取到发送的新建子进程的channel[0]
            *   从c-&amp;gt;fd中读取到ch中去    
            */
1089         n = ngx_read_channel(c-&amp;gt;fd, &amp;amp;ch, sizeof(ngx_channel_t), ev-&amp;gt;log);
1090 
1091         ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev-&amp;gt;log, 0, &quot;channel: %i&quot;, n);
1092 
1093         if (n == NGX_ERROR) {
1094 
1095             if (ngx_event_flags &amp;amp; NGX_USE_EPOLL_EVENT) {
1096                 ngx_del_conn(c, 0);
1097             }
1098 
1099             ngx_close_connection(c);
1100             return;
1101         }
1102 
1103         if (ngx_event_flags &amp;amp; NGX_USE_EVENTPORT_EVENT) {
1104             if (ngx_add_event(ev, NGX_READ_EVENT, 0) == NGX_ERROR) {
1105                 return;
1106             }
1107         }
1108 
1109         if (n == NGX_AGAIN) {
1110             return;
1111         }
1112 
1113         ngx_log_debug1(NGX_LOG_DEBUG_CORE, ev-&amp;gt;log, 0,
1114                        &quot;channel command: %d&quot;, ch.command);
1115 
1116         switch (ch.command) {
1117 
1118         case NGX_CMD_QUIT:
1119             ngx_quit = 1;
1120             break;
1121 
1122         case NGX_CMD_TERMINATE:
1123             ngx_terminate = 1;
1124             break;
1125 
1126         case NGX_CMD_REOPEN:
1127             ngx_reopen = 1;
1128             break;
1129 
1130         case NGX_CMD_OPEN_CHANNEL:
1131 
1132             ngx_log_debug3(NGX_LOG_DEBUG_CORE, ev-&amp;gt;log, 0,
1133                            &quot;get channel s:%i pid:%P fd:%d&quot;,
1134                            ch.slot, ch.pid, ch.fd);
1135 
                /*  将相关信息加入到全局数组中去  */
1136             ngx_processes[ch.slot].pid = ch.pid;
1137             ngx_processes[ch.slot].channel[0] = ch.fd;
1138             break;
1139 
1140         case NGX_CMD_CLOSE_CHANNEL:
1141 
1142             ngx_log_debug4(NGX_LOG_DEBUG_CORE, ev-&amp;gt;log, 0,
1143                            &quot;close channel s:%i pid:%P our:%P fd:%d&quot;,
1144                            ch.slot, ch.pid, ngx_processes[ch.slot].pid,
1145                            ngx_processes[ch.slot].channel[0]);
1146 
1147             if (close(ngx_processes[ch.slot].channel[0]) == -1) {
1148                 ngx_log_error(NGX_LOG_ALERT, ev-&amp;gt;log, ngx_errno,
1149                               &quot;close() channel failed&quot;);
1150             }
1151 
1152             ngx_processes[ch.slot].channel[0] = -1;
1153             break;
1154         }
1155     }
1156 }


ngx_int_t
94 ngx_read_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size, ngx_log_t *log)
95 {
96     ssize_t             n;
97     ngx_err_t           err;
98     struct iovec        iov[1];
99     struct msghdr       msg;
100 
101 #if (NGX_HAVE_MSGHDR_MSG_CONTROL)
102     union {
103         struct cmsghdr  cm;
104         char            space[CMSG_SPACE(sizeof(int))];
105     } cmsg;
106 #else
107     int                 fd;
108 #endif
109 
110     iov[0].iov_base = (char *) ch;
111     iov[0].iov_len = size;
112 
113     msg.msg_name = NULL;
114     msg.msg_namelen = 0;
115     msg.msg_iov = iov;
116     msg.msg_iovlen = 1;
117 
118 #if (NGX_HAVE_MSGHDR_MSG_CONTROL)
119     msg.msg_control = (caddr_t) &amp;amp;cmsg;
120     msg.msg_controllen = sizeof(cmsg);
121 #else
122     msg.msg_accrights = (caddr_t) &amp;amp;fd;
123     msg.msg_accrightslen = sizeof(int);
124 #endif
125 
126     n = recvmsg(s, &amp;amp;msg, 0);
127 
128     if (n == -1) {
129         err = ngx_errno;
130         if (err == NGX_EAGAIN) {
131             return NGX_AGAIN;
132         }
133 
134         ngx_log_error(NGX_LOG_ALERT, log, err, &quot;recvmsg() failed&quot;);
135         return NGX_ERROR;
136     }
137 
138     if (n == 0) {
139         ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, 0, &quot;recvmsg() returned zero&quot;);
140         return NGX_ERROR;
141     }
142 
143     if ((size_t) n &amp;lt; sizeof(ngx_channel_t)) {
144         ngx_log_error(NGX_LOG_ALERT, log, 0,
145                       &quot;recvmsg() returned not enough data: %uz&quot;, n);
146         return NGX_ERROR;
147     }
148 
149 #if (NGX_HAVE_MSGHDR_MSG_CONTROL)
150 
151     if (ch-&amp;gt;command == NGX_CMD_OPEN_CHANNEL) {
152 
153         if (cmsg.cm.cmsg_len &amp;lt; (socklen_t) CMSG_LEN(sizeof(int))) {
154             ngx_log_error(NGX_LOG_ALERT, log, 0,
155                           &quot;recvmsg() returned too small ancillary data&quot;);
156             return NGX_ERROR;
157         }
158 
159         if (cmsg.cm.cmsg_level != SOL_SOCKET || cmsg.cm.cmsg_type != SCM_RIGHTS)
160         {
161             ngx_log_error(NGX_LOG_ALERT, log, 0,
162                           &quot;recvmsg() returned invalid ancillary data &quot;
163                           &quot;level %d or type %d&quot;,
164                           cmsg.cm.cmsg_level, cmsg.cm.cmsg_type);
165             return NGX_ERROR;
166         }
    167 
168         /* ch-&amp;gt;fd = *(int *) CMSG_DATA(&amp;amp;cmsg.cm); */
169 
170         ngx_memcpy(&amp;amp;ch-&amp;gt;fd, CMSG_DATA(&amp;amp;cmsg.cm), sizeof(int));
171     }
172 
173     if (msg.msg_flags &amp;amp; (MSG_TRUNC|MSG_CTRUNC)) {
174         ngx_log_error(NGX_LOG_ALERT, log, 0,
175                       &quot;recvmsg() truncated data&quot;);
176     }
177 
178 #else
179 
180     if (ch-&amp;gt;command == NGX_CMD_OPEN_CHANNEL) {
181         if (msg.msg_accrightslen != sizeof(int)) {
182             ngx_log_error(NGX_LOG_ALERT, log, 0,
183                           &quot;recvmsg() returned no ancillary data&quot;);
184             return NGX_ERROR;
185         }
186 
187         ch-&amp;gt;fd = fd;
188     }
189 
190 #endif
191 
192     return n;
193 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过好像程序执行过程当中,子进程并没有向父进程发送任何消息,子进程之间也没有相互通信,还有一点有些想不通,在什么情况下子进程之间需要通信,或者说子进程之间要传递什么信息??&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/11/nginx-process-message/&quot;&gt;nginx进程间通信&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 11, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[sed批量修改文件中的名字]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/10/sed-bat-change-file-var-name/" />
  <id>http://localhost:4000/2014/05/10/sed-bat-change-file-var-name</id>
  <published>2014-05-10T00:00:00+00:00</published>
  <updated>2014-05-10T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;比如我们想批量将文件中的某个单词例如shell替换成my_shell,此时可以使用sed&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -i &quot;s/shell/my_shell/g&quot; `grep -l &quot;\&amp;lt;shell\&amp;gt;&quot; *`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grep  -l表示找到含有shell的文件后仅仅显示文件名&lt;/p&gt;

&lt;p&gt;sed -i 表示直接将指令插入到符合的行后&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/10/sed-bat-change-file-var-name/&quot;&gt;sed批量修改文件中的名字&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 10, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[覆盖性加载]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/10/security-hiden-file/" />
  <id>http://localhost:4000/2014/05/10/security-hiden-file</id>
  <published>2014-05-10T00:00:00+00:00</published>
  <updated>2014-05-10T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;今天看到了一个非常非常非常非常好的隐藏目录的方法,使人难以访问.&lt;/p&gt;

&lt;p&gt;例如我们可以创建/opt/tmp目录.并将所有的工具都放在该目录下,然后切换到这个目录,运行要运行的程序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@ tmp]# pwd
/opt/tmp
[root@ tmp]# ls
ping.sh  su.sh
[root@ tmp]# ./ping.sh &amp;amp;
[1] 4362
[root@ tmp]# 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;做完这些工作之后,我们需要在/opt/tmp上加载一个新的文件系统,比如一个多余的分区或是tmpfs文件系统&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@ tmp]# mount size=100 -t tmpfs /opt/tmp/
[root@ tmp]# ls
ping.sh  su.sh
[root@ tmp]# pwd
/opt/tmp
[root@ tmp]# touch test
[root@ tmp]# ls
ping.sh  su.sh  test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们没有离开过/opt/tmp目录,所以对其中的内容仍然拥有完成的访问权限,并且lsof会将原来的/opt/tmp目录当作是前面启动的程序及其锁打开文件的所在位置,但是新的进程无法访问其中的任何东西&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@ tmp]# lsof -c ping.sh 
COMMAND  PID USER   FD   TYPE DEVICE  SIZE/OFF    NODE NAME
ping.sh 4362 root  cwd    DIR  253,1      4096 1048358 /opt/tmp
ping.sh 4362 root  rtd    DIR  253,1      4096       2 /
ping.sh 4362 root  txt    REG  253,1    911720 2094276 /usr/bin/bash
ping.sh 4362 root  mem    REG  253,1 106070928 2102940 /usr/lib/locale/locale-archive
ping.sh 4362 root  mem    REG  253,1   2064488 2095852 /usr/lib/libc-2.18.so
ping.sh 4362 root  mem    REG  253,1     17912 2095931 /usr/lib/libdl-2.18.so
ping.sh 4362 root  mem    REG  253,1    135216 2096544 /usr/lib/libtinfo.so.5.9
ping.sh 4362 root  mem    REG  253,1     26252 2098767 /usr/lib/gconv/gconv-modules.cache
ping.sh 4362 root  mem    REG  253,1    150572 2095672 /usr/lib/ld-2.18.so
ping.sh 4362 root    0u   CHR  136,3       0t0       6 /dev/pts/3
ping.sh 4362 root    1u   CHR  136,3       0t0       6 /dev/pts/3
ping.sh 4362 root    2u   CHR  136,3       0t0       6 /dev/pts/3
ping.sh 4362 root  255r   REG  253,1        43 1048359 /opt/tmp/ping.sh
[root@ tmp]# pwd
/opt/tmp
[root@ tmp]# ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lsof表示文件是在/opt/tmp/中,但是就是显示不出来,是不是很爽呢?&lt;/p&gt;

&lt;p&gt;恢复隐藏的目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@ tmp]# mount
proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)
sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)
devtmpfs on /dev type devtmpfs (rw,nosuid,size=989192k,nr_inodes=215247,mode=755)
securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)
tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev)
devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000)
tmpfs on /run type tmpfs (rw,nosuid,nodev,mode=755)
tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,mode=755)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
pstore on /sys/fs/pstore type pstore (rw,nosuid,nodev,noexec,relatime)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)
/dev/mapper/fedora-root on / type ext4 (rw,relatime,data=ordered)
systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=35,pgrp=1,timeout=300,minproto=5,maxproto=5,direct)
debugfs on /sys/kernel/debug type debugfs (rw,relatime)
tmpfs on /tmp type tmpfs (rw)
hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime)
configfs on /sys/kernel/config type configfs (rw,relatime)
mqueue on /dev/mqueue type mqueue (rw,relatime)
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw,relatime)
sunrpc on /proc/fs/nfsd type nfsd (rw,relatime)
/dev/sda12 on /boot type ext4 (rw,relatime,data=ordered)
/dev/mapper/fedora-home on /home type ext4 (rw,relatime,data=ordered)
gvfsd-fuse on /run/user/0/gvfs type fuse.gvfsd-fuse (rw,nosuid,nodev,relatime,user_id=0,group_id=0)
/dev/sdb4 on /run/media/root/FEDORA-LIVE type vfat (rw,nosuid,nodev,relatime,fmask=0022,dmask=0077,codepage=437,iocharset=ascii,shortname=mixed,showexec,utf8,flush,errors=remount-ro,uhelper=udisks2)
size=100 on /opt/tmp type tmpfs (rw,relatime)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时最后一行显示出了这个挂载点,我们需要将其卸载&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@ tmp]# ls
ping.sh  su.sh  test
[root@ tmp]# cd ..          #一旦离开目录就没有访问权限了
[root@ opt]# cd tmp/
[root@ tmp]# ls
[root@ tmp]# cd ../     
[root@ opt]# 
[root@ opt]# umount tmp/
[root@ opt]# cd tmp/
[root@ tmp]# ls
ping.sh  su.sh  test
[root@ tmp]# 
&lt;/code&gt;&lt;/pre&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/10/security-hiden-file/&quot;&gt;覆盖性加载&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 10, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[map的使用]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/09/stl-use-map/" />
  <id>http://localhost:4000/2014/05/09/stl-use-map</id>
  <published>2014-05-09T00:00:00+00:00</published>
  <updated>2014-05-09T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;map是关联容器，它提供一对一的数据处理能力，其中第一个可以叫做关键字，每个关键字只能出现一次，第二个叫关键字的值。&lt;/p&gt;

&lt;p&gt;map使用红黑树来实现的，所以在map捏不所有的数据都是有序的。&lt;/p&gt;

&lt;h4&gt;map的插入&lt;/h4&gt;

&lt;p&gt;1.使用insert插入pair数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;map&amp;gt;

using namespace std;

int main(int argc, char** argv)
{
    map&amp;lt;int, string&amp;gt; map_student;
    map_student.insert(pair&amp;lt;int, string&amp;gt;(1, &quot;student_one&quot;));
    map_student.insert(pair&amp;lt;int, string&amp;gt;(2, &quot;student_two&quot;));
    map_student.insert(pair&amp;lt;int, string&amp;gt;(3, &quot;student_three&quot;));

    map&amp;lt;int, string&amp;gt;::reverse_iterator reiter;
    map&amp;lt;int, string&amp;gt;::iterator iter;

    /*  正序输出    */
    for (iter = map_student.rbegin(); iter != map_student.rend(); ++iter) {
        cout &amp;lt;&amp;lt; iter-&amp;gt;first &amp;lt;&amp;lt; &quot;:&quot; &amp;lt;&amp;lt; iter-&amp;gt;second &amp;lt;&amp;lt; endl; 
    }
    cout &amp;lt;&amp;lt; &quot;map.size() = &quot; &amp;lt;&amp;lt;  map_student.size() &amp;lt;&amp;lt; endl;

    /*  逆序输出    */
    for (reiter = map_student.rbegin(); reiter != map_student.rend(); ++reiter) {
        cout &amp;lt;&amp;lt; reiter-&amp;gt;first &amp;lt;&amp;lt; &quot;:&quot; &amp;lt;&amp;lt; reiter-&amp;gt;second &amp;lt;&amp;lt; endl; 
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.使用insert插入value_type数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;map&amp;gt;

using namespace std;

int main(int argc, char** argv)
{



    map&amp;lt;int, string&amp;gt; map_student;

    map_student.insert(map&amp;lt;int, string&amp;gt;::value_type(1, &quot;student_one&quot;));
    map_student.insert(map&amp;lt;int, string&amp;gt;::value_type(2, &quot;student_two&quot;));
    map_student.insert(map&amp;lt;int, string&amp;gt;::value_type(3, &quot;student_three&quot;));

    map&amp;lt;int, string&amp;gt;::iterator iter;

    for (iter = map_student.begin(); iter != map_student.end(); ++iter) {
        cout &amp;lt;&amp;lt; iter-&amp;gt;first &amp;lt;&amp;lt; &quot;:&quot; &amp;lt;&amp;lt; iter-&amp;gt;second &amp;lt;&amp;lt; endl; 
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.数组方式插入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;map&amp;gt;

using namespace std;

int main(int argc, char** argv)
{
    map&amp;lt;int, string&amp;gt; map_student;
    map_student[1] =  &quot;student_one&quot;;
    map_student[2] =  &quot;student_two&quot;;
    map_student[3] =  &quot;student_three&quot;;

    map&amp;lt;int, string&amp;gt;::iterator iter;

    for (iter = map_student.begin(); iter != map_student.end(); ++iter) {
        cout &amp;lt;&amp;lt; iter-&amp;gt;first &amp;lt;&amp;lt; &quot;:&quot; &amp;lt;&amp;lt; iter-&amp;gt;second &amp;lt;&amp;lt; endl; 
    }

        /*  很少能够使用如下方法，除非是连续的 */  
//      int size = map_student.size();  
        /*  要从下标1开始，因为我们没有插入0 */
//      for (int index = 1; index &amp;lt;= size; ++index) {   
//          cout &amp;lt;&amp;lt; map_student[index] &amp;lt;&amp;lt; endl;
//      }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上三种方法都可以事项数据的插入，但是他们有一定的区别:&lt;/p&gt;

&lt;p&gt;第一和第二种是完全一样的,使用insert插入数据，当map中有这个关键字的时候，insert是插入不了的，相当与不会执行。&lt;/p&gt;

&lt;p&gt;数组方式则会修改已经存在的值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    map_student.insert(map&amp;lt;int, string&amp;gt;::value_type(2, &quot;student_two&quot;));
    map_student.insert(map&amp;lt;int, string&amp;gt;::value_type(2, &quot;student_three&quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上两条语句执行之后，map中2关键字对应的值还是student_two,也就是说第二条语句没有生效，这就涉及到如何判断insert语句是否成功插入的问题，可以使用pair来获取是否插入成功&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*  通过insert_pair的第二个变量来知道是否插入成功，成功返回true，失败返回false，
    第一个变量返回的是map的迭代器      
*/
pair&amp;lt;map&amp;lt;int, string&amp;gt;::iterator, bool&amp;gt; insert_pair;
map_student.insert(map&amp;lt;int, string&amp;gt;::value_type(2, &quot;student_two&quot;));
insert_pair = map_student.insert(map&amp;lt;int, string&amp;gt;::value_type(2, &quot;student_three&quot;));

if (insert_pair.second == false) {
    cout &amp;lt;&amp;lt; &quot;insert failed&quot; &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数组中的插入会覆盖原来的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    map_student[2] =  &quot;student_two&quot;;
    map_student[2] =  &quot;student_three&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则map中的2对应的值变成了student_three;&lt;/p&gt;

&lt;h4&gt;map的大小&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;int size = map_student.size();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;map的遍历&lt;/h4&gt;

&lt;p&gt;map中提供了正向与反向迭代器可以使用;&lt;/p&gt;

&lt;h4&gt;数据的查找&lt;/h4&gt;

&lt;p&gt;1.使用count&lt;/p&gt;

&lt;p&gt;count是返回map中元素的个数，但是map不允许有重复的，所以count要么返回0,要么返回1
但是缺点是无法确定数据出现的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;map_student.count(2)    /*  存在所有返回1 */
map_student.count(5)    /*  不存在所有返回0  */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.使用find&lt;/p&gt;

&lt;p&gt;find返回的是一个迭代器，当数据出现时候，返回的是数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器就是end函数的迭代器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;map&amp;gt;

using namespace std;

int main(int argc, char** argv)
{
    map&amp;lt;int, string&amp;gt; map_student;
    map_student.insert(pair&amp;lt;int, string&amp;gt;(1, &quot;stuednt_one&quot;));
    map_student.insert(pair&amp;lt;int, string&amp;gt;(2, &quot;stuednt_two&quot;));
    map_student.insert(pair&amp;lt;int, string&amp;gt;(3, &quot;stuednt_three&quot;));

    map&amp;lt;int, string&amp;gt;::iterator iter;

    iter = map_student.find(1);
    if (iter != map_student.end()) {
        cout &amp;lt;&amp;lt; &quot;find the value is &quot; &amp;lt;&amp;lt; iter-&amp;gt;second &amp;lt;&amp;lt; endl;

    } else {
        cout &amp;lt;&amp;lt; &quot;Do not find&quot; &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.使用equal_range&lt;/p&gt;

&lt;p&gt;lower_bound函数用来返回要查找关键字的下边界迭代器
upper_bound函数用来返回要查找关键字的上边界迭代器&lt;/p&gt;

&lt;p&gt;如果map中已经插入了1,2,3,4的话，使用lower_bound(2)则返回2，upper_bound(2)返回的就是3&lt;/p&gt;

&lt;p&gt;如果不存在upper_bound就返回迭代器指向end，如果不存在lower_bound就返回迭代器指向end.&lt;/p&gt;

&lt;p&gt;例如upper_bound(4)就返回指向end的迭代器,lower_bound(0)返回的也是指向end的迭代器&lt;/p&gt;

&lt;p&gt;equal_range返回一个pairpair中第一个变量是lower_bound返回的迭代其，第二个是upper_bound返回的迭代器，
如果这两个迭代器相等的话(就都是end)，则说明map中不出现这个关键字;如果存在的话其upper_bound与lower_bound一定不同&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;map&amp;gt;

using namespace std;

int main(int argc, char** argv)
{
    map&amp;lt;int, string&amp;gt; map_student;
    map_student[1] =  &quot;stuednt_one&quot;;
    map_student[2] =  &quot;stuednt_two&quot;;
    map_student[3] =  &quot;stuednt_three&quot;;

    map&amp;lt;int, string&amp;gt;::iterator iter;

    iter = map_student.lower_bound(2);
    cout &amp;lt;&amp;lt; iter-&amp;gt;second &amp;lt;&amp;lt; endl;

    iter = map_student.lower_bound(3);
    cout &amp;lt;&amp;lt; iter-&amp;gt;second &amp;lt;&amp;lt; endl;

    iter = map_student.upper_bound(1);
    cout &amp;lt;&amp;lt; iter-&amp;gt;second &amp;lt;&amp;lt; endl;

    iter = map_student.upper_bound(2);
    cout &amp;lt;&amp;lt; iter-&amp;gt;second &amp;lt;&amp;lt; endl;


    pair&amp;lt;map&amp;lt;int, string&amp;gt;::iterator, map&amp;lt;int, string&amp;gt;::iterator&amp;gt; map_pair;
    map_pair = map_student.equal_range(3);

    if (map_pair.first == map_pair.second) {

        cout &amp;lt;&amp;lt; &quot;do not find&quot; &amp;lt;&amp;lt; endl;

    } else {
        cout &amp;lt;&amp;lt; &quot;find&quot; &amp;lt;&amp;lt; endl;
    }

    /*  upper_bound(3)返回的是指向end的迭代器,一下是验证 */
    cout &amp;lt;&amp;lt; (map_pair.second == map_student.end() ? &quot;end&quot; : &quot;other&quot;) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;数据的清空与判断&lt;/h4&gt;

&lt;p&gt;清空map中的数据可以使用clear函数，判断map中是否有数据可以使用empty(),为空返回true&lt;/p&gt;

&lt;h4&gt;数据的删除&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;map&amp;gt;

using namespace std;

int main(int argc, char** argv)
{
    map&amp;lt;int, string&amp;gt; map_student;
    map_student.insert(pair&amp;lt;int, string&amp;gt;(1, &quot;stuednt_one&quot;));
    map_student.insert(pair&amp;lt;int, string&amp;gt;(2, &quot;stuednt_two&quot;));
    map_student.insert(pair&amp;lt;int, string&amp;gt;(3, &quot;stuednt_three&quot;));
    map_student.insert(pair&amp;lt;int, string&amp;gt;(4, &quot;stuednt_four&quot;));

    cout &amp;lt;&amp;lt; &quot;map.size() = &quot; &amp;lt;&amp;lt;  map_student.size() &amp;lt;&amp;lt; endl;

    /*  数据的删除使用迭代器  */
    map&amp;lt;int, string&amp;gt;::iterator m_iter = map_student.find(1);
    if (m_iter != map_student.end()) {
        map_student.erase(m_iter);  
    }

    /*  直接使用关键字删除 
        如果删除了会返回1,否则返回0
    */
    int ret = map_student.erase(2);

    /*  使用迭代器成片删除，删除的是一个前闭后开的区间   */
    map_student.earse(map_student.begin(), map_student.end());
    cout &amp;lt;&amp;lt; &quot;map.size() = &quot; &amp;lt;&amp;lt;  map_student.size() &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;排序&lt;/h4&gt;

&lt;p&gt;STL默认使用小于号排序的，对于常规类型没有问题，但是在用户自定义类型的情况下，排序就会出现问题，因为它没有小于号，所以编译不过去。&lt;/p&gt;

&lt;p&gt;1.重载小于运算符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;map&amp;gt;

using namespace std;

typedef struct student_info{
    int         m_id;
    string      m_name;

    /*  或者写成有原函数    */  
    /*  自定义类型必须重载小于运算符  */
    bool operator &amp;lt; (const student_info&amp;amp; info) const
    {
        if (m_id &amp;lt; info.m_id)
            return true;
        if (m_id == info.m_id)  
            /*  如果id相同则按照名字比较 */
            return m_name.compare(info.m_name) &amp;lt; 0;

        return false;
    }
}student_info, *prt_student_info;


int main(int argc, char** argv)
{
    int size;
    map&amp;lt;student_info, int&amp;gt;  map_student;
    map&amp;lt;student_info, int&amp;gt;::iterator iter;
    student_info my_student;
    my_student.m_id = 1;
    my_student.m_name = &quot;student_one&quot;;

    map_student.insert(pair&amp;lt;student_info, int&amp;gt;(my_student, 90));

    my_student.m_id = 2;
    my_student.m_name = &quot;student_two&quot;;
    map_student.insert(pair&amp;lt;student_info, int&amp;gt;(my_student, 80));

    for (iter = map_student.begin(); iter != map_student.end(); iter++) {
        cout &amp;lt;&amp;lt; iter-&amp;gt;first.m_id &amp;lt;&amp;lt; &quot;   &quot; &amp;lt;&amp;lt; iter-&amp;gt;first.m_name &amp;lt;&amp;lt; &quot;    &quot; &amp;lt;&amp;lt;  iter-&amp;gt;second &amp;lt;&amp;lt; endl;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.实现仿函数&lt;/p&gt;

&lt;p&gt;所谓的仿函数就是指在类中对()符号进行重载，使其具有与函数类似的功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class sort {
public:
    /*  注意不是重载&amp;lt;，而是重载()    */
    bool operator()(student_info const &amp;amp; first, student_info const &amp;amp; second) const
    {   
        if (first.m_id &amp;lt; second.m_id)
            return true;
        if (first.m_id == second.m_id) 
            return first.m_name.compare(second.m_name) &amp;lt; 0;

        return false;
    }   
};


int main()
{
    ... 
    /*  并没有重载&amp;lt;，仅仅是实现了仿函数  */
    map&amp;lt;student_info, int, sort&amp;gt;    map_student;
    ...


}
&lt;/code&gt;&lt;/pre&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/09/stl-use-map/&quot;&gt;map的使用&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 09, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[将mysql的头文件加入自动搜索]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/08/mysql-include-header/" />
  <id>http://localhost:4000/2014/05/08/mysql-include-header</id>
  <published>2014-05-08T00:00:00+00:00</published>
  <updated>2014-05-08T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;gcc 在编译时如何去寻找所需要的头文件：&lt;/p&gt;

&lt;p&gt;命令行参数-I&lt;/p&gt;

&lt;p&gt;然后找gcc的环境变量 C_INCLUDE_PATH,CPLUS_INCLUDE_PATH,OBJC_INCLUDE_PATH&lt;/p&gt;

&lt;p&gt;再找以下目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/include
/usr/local/include
/usr/lib/gcc-lib/i386-linux/2.95.2/include
/usr/lib/gcc-lib/i386-linux/2.95.2/../../../../include/g++-3
/usr/lib/gcc-lib/i386-linux/2.95.2/../../../../i386-linux/include
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果只对当前用户有效在Home目录下的.bashrc或.bash_profile里增加下面的内容(对所有用户有效则是在/etc/profile):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#在PATH中找到可执行文件程序的路径。
export PATH =$PATH:$HOME/bin

#gcc找到头文件的路径
C_INCLUDE_PATH=/usr/include/libxml2:/MyLib
export C_INCLUDE_PATH

#g++找到头文件的路径
CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/include/libxml2:/MyLib
export CPLUS_INCLUDE_PATH

#找到动态链接库的路径
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/MyLib
export LD_LIBRARY_PATH

#找到静态库的路径
LIBRARY_PATH=$LIBRARY_PATH:/MyLib
export LIBRARY_PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直接在.bashrc中加入:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C_INCLUDE_PATH=/usr/include/mysql   #mysql.h的路径
export C_INCLUDE_PATH   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为我的C_INCLUDE_PATH原来没有值，所以直接给它赋值&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/08/mysql-include-header/&quot;&gt;将mysql的头文件加入自动搜索&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 08, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nginx开启目录显示]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/07/nginx-show-directory/" />
  <id>http://localhost:4000/2014/05/07/nginx-show-directory</id>
  <published>2014-05-07T00:00:00+00:00</published>
  <updated>2014-05-07T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;主要是三个选项&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;autoindex on;                   #开启nginx目录浏览功能
autoindex_exact_size off;       #文件大小从KB显示
                                #默认为on，显示文件确切大小，单位是bytes
                                #off，显示文件大概大小，单位是最方便读的
autoindex_localtime on;         #显示文件修改时间为服务器本地时间
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体在配置文件中的使用如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;worker_processes  2;  
error_log  logs/error.log debug;    


events {
    worker_connections  1024;   
}   


http {
    include       mime.types;      
    default_type  application/octet-stream;

    server {
        listen       80;
        listen      127.0.0.1:8080;
        server_name  localhost;

            location / { 
                root   html;
                index  index.html index.htm;

                autoindex on;                   #开启nginx目录浏览功能
                autoindex_exact_size off;       #文件大小从KB显示
                                                #默认为on，显示文件确切大小，单位是bytes
                                                #off，显示文件大概大小，单位是最方便读的

                autoindex_localtime on;         #显示文件修改时间为服务器本地时间
            }

        error_page 404 /404.html;
        error_page 500 502 503 504 /50x.html;

        location = /50x.html {
            root html;
        }
    }
}   
&lt;/code&gt;&lt;/pre&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/07/nginx-show-directory/&quot;&gt;nginx开启目录显示&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 07, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nginx模块--handler|filter|upstream]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/07/nginx-module/" />
  <id>http://localhost:4000/2014/05/07/nginx-module</id>
  <published>2014-05-07T00:00:00+00:00</published>
  <updated>2014-05-07T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;Nginx的模块根据主要功能分为以下四个类别:&lt;/p&gt;

&lt;h4&gt;1.handlers:&lt;/h4&gt;

&lt;p&gt;协同完成客户端请求的处理、产生响应数据&lt;/p&gt;

&lt;h4&gt;2.filter:&lt;/h4&gt;

&lt;p&gt;对handlers产生的响应数据做各种过滤处理(增删改)，例如ngx_http_not_module_filter_module，对待响应的数据进行顾虑检测，如果通过时间戳判断出前后两次请求的响应数据没有任何实质改变，那么就直接响应&quot;304 Not Modified&quot;标识，让客户端使用本地缓存即可，而原本待发送的响应数据将被清除&lt;/p&gt;

&lt;h4&gt;3.upstream:&lt;/h4&gt;

&lt;p&gt;如果存在后端真实服务器，Nginx可以利用upstream做反向代理，对客户端发起的请求只负责转发，也包括对服务器响应数据的回转&lt;/p&gt;

&lt;h4&gt;4.load-balance:&lt;/h4&gt;

&lt;p&gt;在Nginx充当中间代理角色的时候由于后端真实服务器往往多于一个，对于某一次客户端的请求选择对应的后端服务器进行处理。&lt;/p&gt;

&lt;p&gt;nginx的所有代码都是以模块的形式进行组织，nginx的模块结构体ngx_module_s封装模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;111 struct ngx_module_s {
112     ngx_uint_t            ctx_index;                        /*  当前模块在同类模块中的序号 */
113     ngx_uint_t            index;                            /*  当前模块在所有模块中的序号 */
114 
115     ngx_uint_t            spare0;                           
116     ngx_uint_t            spare1;                           
117     ngx_uint_t            spare2;                               
118     ngx_uint_t            spare3;   
119 
120     ngx_uint_t            version;                          /*      当前模块版本号           */
121     
122     void                 *ctx;                              /*  指向当前模块特有数据      */
123     ngx_command_t        *commands;                         /*  指向当前模块配置项解析数组 */
124     ngx_uint_t            type;                             /*          模块类型            */
125
            /*  以下是回调函数   */
126     ngx_int_t           (*init_master)(ngx_log_t *log);
127 
128     ngx_int_t           (*init_module)(ngx_cycle_t *cycle);
129 
130     ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
131     ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
132     void                (*exit_thread)(ngx_cycle_t *cycle);
133     void                (*exit_process)(ngx_cycle_t *cycle);
134 
135     void                (*exit_master)(ngx_cycle_t *cycle);
136 
137     uintptr_t             spare_hook0;
138     uintptr_t             spare_hook1;
139     uintptr_t             spare_hook2;
140     uintptr_t             spare_hook3;
141     uintptr_t             spare_hook4;
142     uintptr_t             spare_hook5;
143     uintptr_t             spare_hook6;
144     uintptr_t             spare_hook7;
145 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;type值只有5中可能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    type的值              ctx指向数据类型

NGX_CORE_MODULE             ngx_core_module_t

NGX_EVENT_MODULE            ngx_event_module_t

NGX_CONF_MODULE             NULL

NGX_HTTP_MODULE             ngx_http_module_t

NGX_MAIL_MODULE             ngx_mail_module_t
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ctx指向的数据类型中基本都是一些回调函数,这些回调函数会在其模块对应的配置文件解析过程前/中/后被适时调用,做一些内存准备,初始化,配置值检测,初始值填充与合并,回调函数挂载等初始工作.&lt;/p&gt;

&lt;p&gt;以ngx_http_core_module模块为例,其type类型为NGX_HTTP_MODULE,ctx指向的ngx_http_module_t结构体变量ngx_http_core_module_ctx&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;786 static ngx_http_module_t  ngx_http_core_module_ctx = {
787     ngx_http_core_preconfiguration,        /* preconfiguration */
788     NULL,                                  /* postconfiguration */
789 
790     ngx_http_core_create_main_conf,        /* create main configuration */
791     ngx_http_core_init_main_conf,          /* init main configuration */
792 
793     ngx_http_core_create_srv_conf,         /* create server configuration */
794     ngx_http_core_merge_srv_conf,          /* merge server configuration */
795     
796     ngx_http_core_create_loc_conf,         /* create location configuration */
797     ngx_http_core_merge_loc_conf           /* merge location configuration */
798 };  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据后面的英文注释,我们可以很明显的看出各个回调函数的回调时机,例如ngx_http_core_preconfiguration将会在http块配置解析之前被调用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;118 static char *
119 ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
120 {
            ....
228         /*  在解析之前调用  */
229         if (module-&amp;gt;preconfiguration) {
230             if (module-&amp;gt;preconfiguration(cf) != NGX_OK) {
231                 return NGX_CONF_ERROR;
232             }
233         }
234     }
235 
236     /* parse inside the http{} block */
237 
238     cf-&amp;gt;module_type = NGX_HTTP_MODULE;
239     cf-&amp;gt;cmd_type = NGX_HTTP_MAIN_CONF;
240     /*  开始解析    */
241     rv = ngx_conf_parse(cf, NULL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到在函数ngx_http_block中确实是在解析前调用了preconfiguration函数&lt;/p&gt;

&lt;h4&gt;handle模块&lt;/h4&gt;

&lt;p&gt;对于客户端的HTTP请求,Nginx将其整个过程细分为了多个阶段,每一个阶段都可以有零到多个回调函数专门处理,我们自己写handler模块时候必须将模块功能处理函数挂载到正确的阶段点上.&lt;/p&gt;

&lt;p&gt;http请求的整个处理过程一共分为11个阶段,每个阶段对应的处理功能都比较单一,这样使得Nginx模块代码更为内聚,这11个阶段是Nginx处理客户端请求的核心所在,在实际处理过程中,因为等待时间或内部转跳或子请求等会导致这些阶段被返回执行,但是在任何时刻,对末个指定的客户端请求而言,对应的request对象总是处于某个确切的阶段;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;序号          阶段宏名                阶段描述
0       NGX_HTTP_POST_READ_PHASE                请求头读取完成之后的阶段
1       NGX_HTTP_SERVER_REWRITE_PHASE   server内请求地址重写阶段
2       NGX_HTTP_FIND_CONFIG_PHASE      配置查找阶段
3       NGX_HTTP_REWIRET_PHASE          location内请求地址重写阶段
4       NGX_HTTP_POST_REWRITE_PHASE     请求地址重写完成之后的阶段
5       NGX_HTTP_PREACCESS_PHASE        访问权限检查准备阶段
6       NGX_HTTP_ACCESS_PHASE           访问权限检查阶段
7       NGX_HTTP_POST_ACCESS_PHASE      访问权限检查完成之后阶段    
8       NGX_HTTP_TRY_FILES_PHASE        配置项try_files处理阶段
9       NGX_HTTP_CONTENT_PHASE          内容产生阶段
10      NGX_HTTP_LOG_PHASE              日志模块处理阶段
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;NGX_HTTP_READ_PHASE:&lt;/h5&gt;

&lt;p&gt;当Nginx成功收到一个客户端请求后(即函数accept正确返回对应的套接字描述符,链接建立),针对该请求所做的第一个实际工作就是读取客户端发来的请求头内容,如果在这个阶段挂上一个对应的回调函数,那么在Nginx读取并解析完客户端请求头内容后,就会执行这些回调函数.&lt;/p&gt;

&lt;h5&gt;NGX_HTTP_SERVER_REWRITE_PHASE:&lt;/h5&gt;

&lt;p&gt;与NGX_HTTP_REWIRET_PHASE都属于地址重写,也都是针对rewrite模块而设定的阶段,前者用于server上下文的地址重写,后者用于location上下文里的地址重写,为什么需要两个地址重写阶段?因为在rewrite模块的相关指令(rewrite,if,set等)即可用于server上下文,又可以用于location上下文,在客户端请求被Nginx接收后,首先做server查找与定位,在定位到server(如果没有就是默认server)后执行NGX_HTTP_SERVER_REWRITE_PHASE阶段上的回调函数,然后在进入到下一阶段NGX_HTTP_FIND_CONFIG_PHASE;&lt;/p&gt;

&lt;p&gt;具体的流程是:
                                ngx_http_find_virtual_server()
    客户端请求 --&gt; 读取&amp;amp;解析请求头      ----&gt; server定位与查找 ----&gt;NGX_HTTP_POST_READ_PHASE   ----&gt;   NGX_HTTP_SERVER_REWRITE_PHASE
    accept          ngx_http_process_request_headers&lt;/p&gt;

&lt;h5&gt;NGX_HTTP_FIND_CONFIG_PHASE:&lt;/h5&gt;

&lt;p&gt;该阶段不能挂载任何回调函数,因为他们永远不会被执行,该阶段是完成Nginx的特定任务,即进行location定位,只有把当前请求对应的location找到,才能从该location上下文中取出更多精确的用户配置值,做后续的处理&lt;/p&gt;

&lt;h5&gt;NGX_HTTP_REWIRET_PHASE:&lt;/h5&gt;

&lt;p&gt;经过上个阶段的处理,Nginx已经定位到当前请求的对应的location上,此时进入NGX_HTTP_REWIRET_PHASE进行地址重写,和第一阶段的地址重写没有太多区别,唯一区别在于定义在location里的地址重写规则只会对被定位到当前locatino的请求才生效,意思就是他们的作用域不同.&lt;/p&gt;

&lt;h5&gt;NGX_HTTP_POST_REWRITE_PHASE:&lt;/h5&gt;

&lt;p&gt;该阶段在基尼下嗯地址重写之后,具体是在location请求地址重写阶段之后,这个阶段不会执行任何回调函数,它本身也是完成Nginx特定任务,即检查当前请求时候做了过多的内部转跳,我们不能让对一个请求的处理在Nginx内转跳很多次甚至是死循环,每转跳一次基本所有的流程都要重新走一遍,这是非常消耗性能的,如果转跳次数超过限定值NGX_HTTP_MAX_URI_CHANGES(宏值为10),那么就直接返回状态码500给客户端提示当前服务器发生内部错误,这种情况多半是配置文件写的有问题.&lt;/p&gt;

&lt;h5&gt;NGX_HTTP_PREACCESS_PHASE+NGX_HTTP_ACCESS_PHASE+NGX_HTTP_POST_READ_PHASE:&lt;/h5&gt;

&lt;p&gt;做访问权限检查的前期中期后期工作,其中后期工作是固定的,判断前面访问权限检查的结果,其中后期工作是固定的,判断前面访问权限检查的结果(状态码存放在字段r-&gt;access_code中),如果当前请求没有访问权限,那么直接返回状态403错误,所以这个阶段也无法去挂载额外的回调函数&lt;/p&gt;

&lt;p&gt;NGX_HTTP_TRY_FILES_PHASE是针对配置项try_files的特定处理阶段,所以也无法挂载额外回调函数&lt;/p&gt;

&lt;p&gt;NGX_HTTP_LOG_PHASE是针对日志模块的特定处理阶段,所以也无法挂载额外回调函数&lt;/p&gt;

&lt;p&gt;一般情况下,我们自己定义模块的回调函数都是挂载在NGX_HTTP_CONTENT_PHASE阶段,因为大部分业务都是在修改http响应数据,nginx自身产生响应内容的模块ngx_http_static_module等也都挂载在这个阶段.&lt;/p&gt;

&lt;p&gt;大多数情况下,功能模块会在其对应配置解析完成后去回调对应函数,也就是说ngx_http_module_t结构体的postconfiguration字段指向的函数内将当枪模块的回调功能函数挂载到这11个阶段中的一个上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;17 ngx_http_module_t  ngx_http_static_module_ctx = {
18     NULL,                                  /* preconfiguration */
19     ngx_http_static_init,                  /* postconfiguration */
20 
21     NULL,                                  /* create main configuration */
22     NULL,                                  /* init main configuration */
23 
24     NULL,                                  /* create server configuration */
25     NULL,                                  /* merge server configuration */
26 
27     NULL,                                  /* create location configuration */
28     NULL                                   /* merge location configuration */
29 };


270 static ngx_int_t
271 ngx_http_static_init(ngx_conf_t *cf)
272 {
273     ngx_http_handler_pt        *h;
274     ngx_http_core_main_conf_t  *cmcf;
275 
276     cmcf = ngx_http_conf_get_module_main_conf(cf, ngx_http_core_module);
277 
        /*  h对应这cmcf-&amp;gt;phases数组的[NGX_HTTP_CONTENT_PHASE]的空闲位置  */
278     h = ngx_array_push(&amp;amp;cmcf-&amp;gt;phases[NGX_HTTP_CONTENT_PHASE].handlers);
279     if (h == NULL) {
280         return NGX_ERROR;
281     }
282     /*  向数组中添加了回调函数   */ 
283     *h = ngx_http_static_handler;
284 
285     return NGX_OK;
286 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到在模块ngx_http_static_module的postconfiguration回调函数ngx_http_static_init内,将ngx_http_static_module模块的核心功能函数ngx_http_static_handler挂载在http请求处理流程的NGX_HTTP_CONTENT_PHASE阶段,这样,当一个客户端的http静态页面请求发送送到Nginx服务器,Nginx就能够调用到我们这里注册的ngx_http_static_handler函数;&lt;/p&gt;

&lt;p&gt;各个模块将其自身的功能函数挂载在cmcf-&gt;phases之后如图所示:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/014.png&quot; alt=&quot;014&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回调函数会根据选用模块的不同而不同,这些回调函数的调用也是有条件的,调用后要做一些根据返回值的结果的处理,比如某次处理能否进入阶段NGX_HTTP_CONTENT_PHASE的回调函数中处理,还需要一个事前判断,所以函数ngx_http_init_phase_handlers里对所有这些回调函数进行一次重组,结果如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/015.png&quot; alt=&quot;015&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到ngx_http_static_module之前要运行checker函数ngx_http_core_content_phase.&lt;/p&gt;

&lt;p&gt;ngx_http_init_phase_handlers对回调函数进行了重组,利用ngx_http_phase_handler结构体数组将这些回调函数进行了重组,不仅仅加上了回调函数的条件判断checker函数,还通过next字段,将原本的二维数组实现转化为可以直接在以为数组内不跳动,二维数组的遍历需要两层循环,而遍历以为数组只要一层循环.&lt;/p&gt;

&lt;p&gt;对http请求分阶段处理的核心函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;864 void
865 ngx_http_core_run_phases(ngx_http_request_t *r)
866 {
867     ngx_int_t                   rc;
868     ngx_http_phase_handler_t   *ph;
869     ngx_http_core_main_conf_t  *cmcf;
870 
871     cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);
872 
873     ph = cmcf-&amp;gt;phase_engine.handlers;
874 
875     while (ph[r-&amp;gt;phase_handler].checker) {
876 
877         rc = ph[r-&amp;gt;phase_handler].checker(r, &amp;amp;ph[r-&amp;gt;phase_handler]);
878 
879         if (rc == NGX_OK) {
880             return;
881         }
882     }
883 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;r-&gt;phase_handler表示当前处理的序号,对一个客户端请求处理的最开始时刻,该值就是0,while循环判断如果存在checker函数(末尾数组元素的checker是NULL),那么就调用该checker函数并有可能进行调用对应的回调函数&lt;/p&gt;

&lt;p&gt;以NGX_HTTP_ACCESS_PHASE阶段的ngx_http_core_access_phase函数为例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1088 ngx_int_t
1089 ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
1090 {
1091     ngx_int_t                  rc;
1092     ngx_http_core_loc_conf_t  *clcf;
1093 
        /*  如果非主请求,自然不必进行访问权限检查,直接进入下一阶段    */
1094     if (r != r-&amp;gt;main) {
1095         r-&amp;gt;phase_handler = ph-&amp;gt;next;   /*  直接进入下一阶段    */
1096         return NGX_AGAIN;
1097     }
1098 
1099     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
1100                    &quot;access phase: %ui&quot;, r-&amp;gt;phase_handler);
1101 
        /*  否则要进行访问权限检查,执行回调  */
1102     rc = ph-&amp;gt;handler(r);
1103 
        /*  条件处理表示当前回调拒绝处理或是不符合它的处理条件,将会尝试使用下一个回调函数 */
1104     if (rc == NGX_DECLINED) {
1105         r-&amp;gt;phase_handler++;        /*  使用下一个回调函数 */
1106         return NGX_AGAIN;
1107     }
1108 
        /*  表示当前回调需要再次处理或者是已经成功处理 */
1109     if (rc == NGX_AGAIN || rc == NGX_DONE) {
            /*  
            *   直接返回会导致ngx_http_core_run_phases的循环处理退出,
            *   这表示状态机的继续处理需要等待更进一步的事件发生
            *   可以是子请求结束,socket描述符变得写可,超时等
            *   并且在进入到状态机处理函数时,仍将从当前回调开始
            */
1110         return NGX_OK;
1111     }
1112 
1113     clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);
1114 
1115     if (clcf-&amp;gt;satisfy == NGX_HTTP_SATISFY_ALL) {
1116 
1117         if (rc == NGX_OK) {
1118             r-&amp;gt;phase_handler++;
1119             return NGX_AGAIN;
1120         }
1121 
1122     } else {
1123         if (rc == NGX_OK) {
1124             r-&amp;gt;access_code = 0;
1125 
1126             if (r-&amp;gt;headers_out.www_authenticate) {
1127                 r-&amp;gt;headers_out.www_authenticate-&amp;gt;hash = 0;
1128             }
1129 
1130             r-&amp;gt;phase_handler = ph-&amp;gt;next;
1131             return NGX_AGAIN;
1132         }
1133 
1134         if (rc == NGX_HTTP_FORBIDDEN || rc == NGX_HTTP_UNAUTHORIZED) {
1135             r-&amp;gt;access_code = rc;
1136 
1137             r-&amp;gt;phase_handler++;
1138             return NGX_AGAIN;
1139         }
1140     }
1141 
1142     /* rc == NGX_ERROR || rc == NGX_HTTP_...  */
        /*  一下是对发生错误的处理   */
1143 
1144     ngx_http_finalize_request(r, rc);
1145     return NGX_OK;
1146 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;handler函数返回值的含义:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;返回值                           含义
NGX_OK                          当前阶段已经被成功处理,必须进入到下一个阶段
NGX_DECLINED                    当前回调不出里当前情况,进入下一个回调处理
NGX_AGAIN                       当前处理所需资源不足,需要等待依赖事件发生
NGX_DONE                        当前处理结束,需要等待进一步事件发生后做处理
NGX_ERROR\NGX_HTTP_...          当前回调处理发生错误,需要进入异常处理流程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于回调函数的返回值会影响到统一阶段的后续回调函数的处理与否,Nginx采用先进后出的方案,即先注册的模块,其回调函数反而后执行,所以回调函数或者说是模块的先后顺序非常重要,以NGX_HTTP_CONTENT_PHASE阶段的三个回调函数为例&lt;/p&gt;

&lt;p&gt;在objs/ngx_modules.c中可以看到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;18 extern ngx_module_t  ngx_http_static_module;
19 extern ngx_module_t  ngx_http_autoindex_module;
20 extern ngx_module_t  ngx_http_index_module;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个模块的注册先后顺序,而前面图中的调用顺序确实相反的,即ngx_http_index_module--&gt;ngx_http_autoindex_module--&gt;ngx_http_static_module的顺序执行,这个顺序是合理的.比如我们打开Nginx服务器,直接访问一个目录,那么Nginx先是查看当前目录下是否存在index.html/index.htm/index.php之类的默认显示页面,这是回调函数ngx_http_index_module的工作,如果不存在这样的页面查看是否允许显示列表页面,这属于ngx_http_autoindex_module函数的工作,而ngx_http_static_handler回调函数则是根据客户端静态页面请求查找对应的页面文件并组成待响应内容.&lt;/p&gt;

&lt;p&gt;可以看到虽然这三个函数都是挂载在NGX_HTTP_CONTENT_PHASE阶段,但是各自实现的功能却存在先后关系,如果ngx_http_autoindex_module在ngx_http_index_module之前,那么对于本来存在默认显示页面的目录进行列表显示,这显然是错误的.&lt;/p&gt;

&lt;h4&gt;filter模块&lt;/h4&gt;

&lt;p&gt;对于http请求处理handlers产生的响应内容,在输出到客户端之前需要做过滤处理,这些过滤处理对于完成功能的增强实现与性能的提升是非常有必要的.例如ngx_http_chunked_filter_module用来支持HTTP1.1协议的chunk功能.ngx&lt;strong&gt;http_not&lt;/strong&gt;modified_filter_module过滤模块使得客户端使用本地缓存来提高性能,这些都需要过滤模块的支持.&lt;/p&gt;

&lt;p&gt;由于响应数据包含响应头和响应体,所以与之对应,Filter模块必须提供处理响应头的header过滤功能函数或者提供处理响应体body过滤功能函数,或者两者皆有.&lt;/p&gt;

&lt;p&gt;所有的header过滤功能函数和body过滤功能函数会分别组成各自的两条过滤链,如图:&lt;/p&gt;

&lt;p&gt;![016] (/uploads/2014/05/016.png)&lt;/p&gt;

&lt;p&gt;文件ngx_http.c中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;72 ngx_int_t  (*ngx_http_top_header_filter) (ngx_http_request_t *r);
73 ngx_int_t  (*ngx_http_top_body_filter) (ngx_http_request_t *r, ngx_chain_t *ch);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是整个Nginx范围内可见的全局变量,然后在每一个filter模块内,我们还可以看到类似定义(如果当前模块只有header过滤功能函数或是之后body过滤功能函数,那么如下定义也只用对应的变量)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;233 static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;
234 static ngx_http_output_body_filter_pt    ngx_http_next_body_filter;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意static,也就是说这两个变量属于模块范围内的可见局部变量,有了这些函数指针变量,在各个filter模块的postconfiguration回调函数内,全局变量与局部变量巧妙赋值最终形成了两条过滤链&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;40 extern ngx_module_t  ngx_http_header_filter_module;
41 extern ngx_module_t  ngx_http_chunked_filter_module;
42 extern ngx_module_t  ngx_http_range_header_filter_module;
43 extern ngx_module_t  ngx_http_gzip_filter_module;
44 extern ngx_module_t  ngx_http_postpone_filter_module;
45 extern ngx_module_t  ngx_http_ssi_filter_module;
46 extern ngx_module_t  ngx_http_charset_filter_module;
47 extern ngx_module_t  ngx_http_userid_filter_module;
48 extern ngx_module_t  ngx_http_headers_filter_module;

objs/modulus.c 中ngx_http_header_filter_module是具有header过滤功能函数的序号最小的过滤模块,我们以ngx_http_header_filter_module为例,其postconfiguration回调函数如下:

617 static ngx_int_t
618 ngx_http_header_filter_init(ngx_conf_t *cf)
619 {
620     ngx_http_top_header_filter = ngx_http_header_filter;
621 
622     return NGX_OK;
623 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时ngx_http_top_header_filter指向了ngx_http_header_filter,接着nginx初始化在继续执行到下一序号的带有header过滤功能函数的过滤模块的postconfiguration回调函数中;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;232 static ngx_int_t
233 ngx_http_chunked_filter_init(ngx_conf_t *cf)
234 {
235     ngx_http_next_header_filter = ngx_http_top_header_filter;
236     ngx_http_top_header_filter = ngx_http_chunked_header_filter;
237 
238     ngx_http_next_body_filter = ngx_http_top_body_filter;
239     ngx_http_top_body_filter = ngx_http_chunked_body_filter;
240 
241     return NGX_OK;
242 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这时候&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/017.png&quot; alt=&quot;017&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其他模块类似,最终形成了完整的header过滤链,body过滤链的形成也是类似,两条过滤链形成后,其对应的调用入口分别在ngx_http_send_header和函数ngx_http_output_filter内&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1889 ngx_int_t
1890 ngx_http_send_header(ngx_http_request_t *r)
1891 {
1892     if (r-&amp;gt;err_status) {
1893         r-&amp;gt;headers_out.status = r-&amp;gt;err_status;
1894         r-&amp;gt;headers_out.status_line.len = 0;
1895     }
1896    /*  调用header链 */
1897     return ngx_http_top_header_filter(r);  
1898 }


1901 ngx_int_t
1902 ngx_http_output_filter(ngx_http_request_t *r, ngx_chain_t *in)
1903 {
1904     ngx_int_t          rc;
1905     ngx_connection_t  *c;
1906 
1907     c = r-&amp;gt;connection;
1908     
1909     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c-&amp;gt;log, 0,
1910                    &quot;http output filter \&quot;%V?%V\&quot;&quot;, &amp;amp;r-&amp;gt;uri, &amp;amp;r-&amp;gt;args);
1911 
        /*  调用body链表    */
1912     rc = ngx_http_top_body_filter(r, in);
1913 
1914     if (rc == NGX_ERROR) {
1915         /* NGX_ERROR may be returned by any filter */
1916         c-&amp;gt;error = 1;
1917     }
1918 
1919     return rc;
1920 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个函数主要通过链表的连头函数指针全局变量进入到两条过滤链内,进而依次执行链上的各个函数,例如ngx_http_top_header_filter指向的是ngx_http_not_module_filter_module函数,因此进入该函数内执行,在该函数执行的过程中又会根据情况,继续通过当前模块内的函数指针局部变量ngx_http_next_header_filter间接的去调用到header过滤链的下一个过滤函数,这对过滤链的前后承接是非常必要的.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /*  局部变量函数指针    */
49 static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;
50 
51 
    /*  
    *   ngx_http_next_header_filter指针现在初始化函数中被设定
    *   之后才在ngx_http_not_modified_header_filter中被调用 
    */
52 static ngx_int_t
53 ngx_http_not_modified_header_filter(ngx_http_request_t *r)
54 {
55     if (r-&amp;gt;headers_out.status != NGX_HTTP_OK
56         || r != r-&amp;gt;main
57         || r-&amp;gt;headers_out.last_modified_time == -1)
58     {
59         return ngx_http_next_header_filter(r);
60     }
61 
62     if (r-&amp;gt;headers_in.if_unmodified_since) {
63         return ngx_http_test_precondition(r); 
64     }
65 
66     if (r-&amp;gt;headers_in.if_modified_since) {
67         return ngx_http_test_not_modified(r);
68     }
69 
70     return ngx_http_next_header_filter(r);
71 }

    /*  
    *   ngx_http_next_header_filter指针现在初始化函数中被设定
    *   之后才在ngx_http_not_modified_header_filter中被调用 
    */
136 static ngx_int_t
137 ngx_http_not_modified_filter_init(ngx_conf_t *cf)
138 {
139     ngx_http_next_header_filter = ngx_http_top_header_filter;
140     ngx_http_top_header_filter = ngx_http_not_modified_header_filter;
141 
142     return NGX_OK;
143 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更具HTTP协议具备的响应头来影响或决定响应体的内容的特点,一般是先对响应头进行过滤,根据头过滤处理返回值在对响应体进行过滤处理,如果在响应头过滤处理出错或是某些特定的情况下,响应体过滤处理可以不用再进行.&lt;/p&gt;

&lt;h4&gt;upstream模块&lt;/h4&gt;

&lt;p&gt;upstream模块与具体协议无关,除了支持HTTP,还支持FASTCGI等协议&lt;/p&gt;

&lt;p&gt;upstream的典型应用就是反向代理,其配置文件如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http {
.....

    #都是在本机运行
    upstream backend {
        server localhost:8000;
        server localhost:9000;
    }

    server {
        listen 80;
        ...

        location / {
            #禁用nginx反向代理的缓存功能,保证客户端的每次请求都被转发到后端真实服务器上
            proxy_buffering off;
            #此配置项将当前请求反向代理到URL参数指定的服务器上,URL可以是主机名或是ip加端口的形式
            proxy_pass  http://backend;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/07/nginx-module/&quot;&gt;nginx模块--handler|filter|upstream&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 07, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[使用c连接到mysql数据库]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/07/mysql-c-connect-mysql-server/" />
  <id>http://localhost:4000/2014/05/07/mysql-c-connect-mysql-server</id>
  <published>2014-05-07T00:00:00+00:00</published>
  <updated>2014-05-07T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;h4&gt;mysql_init():准备连接&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;MYSQL*  mysql_init(MYSQL* mysql)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*  test.c  */
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;mysql.h&amp;gt;  /*  头文件不一定是这个 */

int main() 
{
    MYSQL conn;

    if (mysql_init(&amp;amp;conn) == NULL) {
        printf(&quot;mysql_init error\n&quot;);
        exit(-1);
    }
    mysql_close(&amp;amp;conn);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用gcc编译的时候，必须指定mysql.h所在的路径，并加入mysqlclient库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cc test.c -omain -I/usr/include/mysql -L/usr/lib/mysql -lmysqlclient 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-I致命mysql.h所在的路径;&lt;/p&gt;

&lt;p&gt;—L指定库文件的路径&lt;/p&gt;

&lt;p&gt;-l使用库&lt;/p&gt;

&lt;h4&gt;mysql_real_connect()&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;MYSQL* mysql_real_connect(MYSQL* mysql, const char* host, const char* user, 
                          const char* passwd, const char* db, unsigned int port, 
                          const char* unix_socket, unsigned long client_flag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数是handle，就是mysql_init返回的handle;&lt;/p&gt;

&lt;p&gt;第五个参数是db_name，也可以将其设为NULL，然后使用mysql_select_db()来选择数据库;&lt;/p&gt;

&lt;p&gt;第六个参数是MYSQL Server的连接池，一般设置为MYSQl_PORT;&lt;/p&gt;

&lt;p&gt;第六个参数一般设置为NULL;&lt;/p&gt;

&lt;p&gt;第七个参数包含压缩协议，查询协议，加密协议等，一般设置为0;&lt;/p&gt;

&lt;p&gt;实例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*  test.c  */
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;mysql.h&amp;gt;  

int main() 
{
    MYSQL       conn;

    if (mysql_init(&amp;amp;conn) == NULL) {
        printf(&quot;mysql_init error\n&quot;);
        exit(-1);
    }


    if (NULL == mysql_real_connect(&amp;amp;conn, &quot;localhost&quot;, &quot;user&quot;, &quot;123456&quot;, 
                                    &quot;company&quot;, MYSQL_PORT, NULL, 0)) 
    {
        printf(&quot;connection error\n&quot;);
        exit(-1);

    }
    printf(&quot;Connection ok\n&quot;);
    mysql_close(&amp;amp;conn);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;查询数据库&lt;/h4&gt;

&lt;p&gt;当成功连接mysql之后，可以使用mysql_query或是mysql_real_query来查询数据库，但是mysql_query不能处理binary data(例如图片),如果包含binary data，则必须使用mysql_real_query，这个函数需要提供程序字串的长度&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int mysql_query(MYSQL *mysql, const char *query)
int mysql_real_query(MYSQL *mysql, const char *query, unsigned long length) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查询成功则返回0,否则返回非0;&lt;/p&gt;

&lt;p&gt;如果查询语句并没有结果返回，例如delete/update/insert等，mysql_query被执行后便完成了整个操作;&lt;/p&gt;

&lt;p&gt;如果要执行insert/show/describe等，在存取结果前，必须使用mysql_store_result建立result handle;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MYSQL_RES* mysql_store_result(MYSQL* mysql)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实例:
    /&lt;em&gt;  test.c  &lt;/em&gt;/
    #include &amp;lt;stdio.h&gt;
    #include &amp;lt;mysql.h&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main() 
{
    MYSQL       conn;
    MYSQl_RES*  result;

    if (mysql_init(&amp;amp;conn) == NULL) {
        printf(&quot;mysql_init error\n&quot;);
        exit(-1);
    }


    if (NULL == mysql_real_connect(&amp;amp;conn, &quot;localhost&quot;, &quot;user&quot;, &quot;123456&quot;, 
                                    &quot;company&quot;, MYSQL_PORT, NULL, 0)) 
    {
        printf(&quot;connection error\n&quot;);
        exit(-1);

    }
    printf(&quot;Connection ok\n&quot;);

    mysql_query(&amp;amp;conn, &quot;select * from worker&quot;);
    result = mysql_store_result(&amp;amp;conn)

    mysql_free_result(result);
    mysql_close(&amp;amp;conn);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;注意:&lt;/h5&gt;

&lt;p&gt;mysql_result是一个指针，因为mysql_store_result会自动分配内存存储查询结果，所以在后面要执行mysql_free_result(MYSQL_RES*)来释放内存&lt;/p&gt;

&lt;h4&gt;提取查询结果:&lt;/h4&gt;

&lt;p&gt;提前接过钱必须使用mysql_store_result分配内存给查询结果，然后利用mysql_fetch_row逐行提取数据。
结果的行数和列数可以使用mysql_num_rows和mysql_num_fields来获取;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MYSQL_ROW mysql_fetch_row(MYSQL_RES* result)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MYSQL_RES是一个数组结构，数组中每一个元素依次为该行的字段value;&lt;/p&gt;

&lt;p&gt;实例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;mysql.h&amp;gt;  

int main() 
{
    MYSQL       conn;
    MYSQL_RES*  result;
    MYSQL_ROW   row;
    int         num_row,
                num_col,
                i,
                j;

    if (mysql_init(&amp;amp;conn) == NULL) {
        printf(&quot;mysql_init error\n&quot;);
        exit(-1);
    }


    if (NULL == mysql_real_connect(&amp;amp;conn, &quot;localhost&quot;, &quot;root&quot;, &quot;ucshell&quot;, 
                                    &quot;company&quot;, MYSQL_PORT, NULL, 0)) 
    {
        printf(&quot;connection error\n&quot;);
        exit(-1);

    }
    printf(&quot;Connection ok\n&quot;);

    if (0 != mysql_query(&amp;amp;conn, &quot;select * from worker&quot;) ) {
        printf(&quot;query error\n&quot;);
        exit(-1);
    }


    result = mysql_store_result(&amp;amp;conn);

    /*  这个函数容易忘记结尾的s，只要记住行有很多行，就是复数(非单数)的意思，就不会忘记最后的s了  */
    num_row = mysql_num_rows(result);       /*  获取行数    */
    num_col = mysql_num_fields(result);     /*  获取列数    */

    for (i = 0; i &amp;lt; num_row; i++) {
        row = mysql_fetch_row(result);      /*  row是一个数组，每一个元素就是对应的字段的值 */

        for (j = 0; j &amp;lt; num_col; j++) {
            printf(&quot;%-20s   &quot;, row[j]);
        }
        printf(&quot;\n&quot;);
    }



    mysql_free_result(result);
    mysql_close(&amp;amp;conn);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;注意:&lt;/h4&gt;

&lt;p&gt;如果数据库很大，而又没有使用mysql_free_result释放内存的话，则很容易发送内存泄漏&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/07/mysql-c-connect-mysql-server/&quot;&gt;使用c连接到mysql数据库&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 07, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Nginx的IO多路复用]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/06/nginx-event/" />
  <id>http://localhost:4000/2014/05/06/nginx-event</id>
  <published>2014-05-06T00:00:00+00:00</published>
  <updated>2014-05-06T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;Nginx是以事件驱动的，也就是说nginx内部流程向前推进基本都是靠各种事件的发生来驱动，否则nginx将一直阻塞在函数epoll_wait和sigsuspend这样的系统调用上，nginx工作进程关注的事件有两类:IO事件与定时器事件。&lt;/p&gt;

&lt;h5&gt;IO复用模型&lt;/h5&gt;

&lt;p&gt;无论是哪种IO复用模型，基本原理都是相同的，他们都能让应用程序同时对多个IO端口进行监控以判断其上的操作是否可以进行，达到时间复用的目的(单位时间内，可以同时监控很多)。&lt;/p&gt;

&lt;p&gt;这个例子非常的形象:&lt;/p&gt;

&lt;p&gt;如果要监控10根来自不同地方的水管(IO端口)是否有水流达到(是否可读)，那么需要10个人来做这件事情(10个线程或10处代码)，如果利用某种技术(比如摄像头)把10根水管的状态统一传达到某个点，那么就只需要1人在那个点进行监控就行了，类似于select或是epoll这样的多路IO复用机制就好比是摄像头的功能，他们能把多个IO端口的情况反馈到同一处，比如某个特定的文件描述符上，这样应用程序只需要对应的select或是epoll_wait调用阻塞关注这一处即可.&lt;/p&gt;

&lt;p&gt;不同平台支持不同的IO多路复用模型，Nginx对这些IO多路复用模型进行封装和使用，IO多路复用模型被封装在一个叫做ngx_event_atcionts_t的结构体中，该结构体中包含的字段主要就是回调函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;230 typedef struct {

        /*  将某个描述符的某个事件(可读/可写)添加到多路复用的监控  */
231     ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
        /*  将某个描述符的某个事件(可读/可写)从多路复用的监控中删除   */
232     ngx_int_t  (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
233 
        /*  启用对某个事件的监控  */
234     ngx_int_t  (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

        /*  禁用对某个指定事件的监控    */
235     ngx_int_t  (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
236 
        /*  将指定连接关联的描述符加入到多路复用监控里 */
237     ngx_int_t  (*add_conn)(ngx_connection_t *c);

        /*  将指定连接关联的描述符从多路复用监控里删除 */
238     ngx_int_t  (*del_conn)(ngx_connection_t *c, ngx_uint_t flags);

239     /*  仅仅对kqueue才会用到这个接口，所以没什么用    */ 
240     ngx_int_t  (*process_changes)(ngx_cycle_t *cycle, ngx_uint_t nowait);

        /*  阻塞等待时间发生，对发生的时间进行逐个处理 */
241     ngx_int_t  (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer,
242                    ngx_uint_t flags);
243 
        /*  初始化   */
244     ngx_int_t  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);
        /*  回收资源    */
245     void       (*done)(ngx_cycle_t *cycle);
246 } ngx_event_actions_t;
247 
248 
249 extern ngx_event_actions_t   ngx_event_actions;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于多路复用模型各自具体的实现不同，上面列出的接口可能在Nginx的IO多路复用处理模块里没有对应的处理，但几个最近本的接口例如add/del/process_events肯定会有实现的。&lt;/p&gt;

&lt;p&gt;为了方便使用任何一种事件处理机制，Nginx定义一个类型为ngx_event_actions_t的全局变量ngx_event_actions，并且定义了几个宏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;448 #define ngx_process_changes  ngx_event_actions.process_changes
449 #define ngx_process_events   ngx_event_actions.process_events
450 #define ngx_done_events      ngx_event_actions.done
451 
452 #define ngx_add_event        ngx_event_actions.add
453 #define ngx_del_event        ngx_event_actions.del
454 #define ngx_add_conn         ngx_event_actions.add_conn
455 #define ngx_del_conn         ngx_event_actions.del_conn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样Nginx要将某个时间添加到多路复用监控里，只需要调用ngx_add_event()即可，至于这个函数对应到哪个具体的IO多路复用模块上，就不必关心！&lt;/p&gt;

&lt;p&gt;ngx_add_event()函数是如何关联到具体的IO多路复用处理模块上的呢？&lt;/p&gt;

&lt;p&gt;关键在于全局变量ngx_event_actions的值，为全局变量ngx_event_actions进行赋值出现在各个时间处理模块的初始化函数内,例如epoll模块。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;491 typedef struct {
492     ngx_str_t              *name;
493 
494     void                 *(*create_conf)(ngx_cycle_t *cycle);
495     char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);
496 
497     ngx_event_actions_t     actions;    /*  action的定义在上面，成员主要是一些回调函数    */
498 } ngx_event_module_t;



149 ngx_event_module_t  ngx_epoll_module_ctx = {
150     &amp;amp;epoll_name,
151     ngx_epoll_create_conf,               /* create configuration */
152     ngx_epoll_init_conf,                 /* init configuration */
153     
154     {
            /*  与ngx_event_actions_t中的函数一一对应  */
155         ngx_epoll_add_event,             /* add an event */
156         ngx_epoll_del_event,             /* delete an event */
157         ngx_epoll_add_event,             /* enable an event */
158         ngx_epoll_del_event,             /* disable an event */
159         ngx_epoll_add_connection,        /* add an connection */
160         ngx_epoll_del_connection,        /* delete an connection */
161         NULL,                            /* process the changes */
162         ngx_epoll_process_events,        /* process the events */
163         ngx_epoll_init,                  /* init the events */
164         ngx_epoll_done,                  /* done the events */
165     }
166 };  



288 static ngx_int_t
289 ngx_epoll_init(ngx_cycle_t *cycle, ngx_msec_t timer)
290 {
291     ngx_epoll_conf_t  *epcf;
292 
293     epcf = ngx_event_get_conf(cycle-&amp;gt;conf_ctx, ngx_epoll_module);
294 
295     if (ep == -1) {
296         ep = epoll_create(cycle-&amp;gt;connection_n / 2);
297 
298         if (ep == -1) {
299             ngx_log_error(NGX_LOG_EMERG, cycle-&amp;gt;log, ngx_errno,
300                           &quot;epoll_create() failed&quot;);
301             return NGX_ERROR;
302         }
303 
304 #if (NGX_HAVE_FILE_AIO)
305 
306         ngx_epoll_aio_init(cycle, epcf);
307 
308 #endif
309     }
310 
311     if (nevents &amp;lt; epcf-&amp;gt;events) {
312         if (event_list) {
313             ngx_free(event_list);
314         }
315 
316         event_list = ngx_alloc(sizeof(struct epoll_event) * epcf-&amp;gt;events,
317                                cycle-&amp;gt;log);
318         if (event_list == NULL) {
319             return NGX_ERROR;
320         }
321     }
322 
323     nevents = epcf-&amp;gt;events;
324 
325     ngx_io = ngx_os_io;
326 
        /*  全局变量关联上来了,这个ngx_epoll_module_ctx.action是一个结构体 */
327     ngx_event_actions = ngx_epoll_module_ctx.actions;
328 
329 #if (NGX_HAVE_CLEAR_EVENT)
330     ngx_event_flags = NGX_USE_CLEAR_EVENT
331 #else
332     ngx_event_flags = NGX_USE_LEVEL_EVENT
333 #endif
334                       |NGX_USE_GREEDY_EVENT
335                       |NGX_USE_EPOLL_EVENT;
336 
337     return NGX_OK;
338 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;327行就是对epoll模块的ngx_event_actions赋值，而在其他时间处理模块的初始化函数内也可以看到这样的赋值语句，所以一旦指定了nginx使用某个事件处理模块，经过事件处理模块的初始化后，就把全局变量ngx_event_actions指向了他的封装，比如ngx_add_event()调用的就是上面的ngx_epoll_add_event()函数&lt;/p&gt;

&lt;p&gt;设定nginx使用那个事件处理机制是通过在event块中使用use指令来指定的，该配置指令对应的处理函数为ngx_event_use()函数&lt;/p&gt;

&lt;p&gt;经过相关验证，比如检验该指定模块是否存在后，就会将对应的事件处理模块序号记录到efc-&gt;use中，如果不进行主动指定，则nginx会根据当前系统平台选择一个合适的事件处理模块，并且同样把模块序号记录在efc-&gt;use中，相关函数是ngx_event_core_init_conf&lt;/p&gt;

&lt;p&gt;工作进程的初始化函数ngx_worker_process_init函数中会调用时间核心模块的初始化函数ngx_event_process_init,在该函数中根据ecf-&gt;use的值来调用对应的时间处理模块的初始化函数,例如epoll模块的ngx_epoll_init模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;584 ngx_event_process_init(ngx_cycle_t *cycle)
585 {
586     ngx_uint_t           m, i;
587     ngx_event_t         *rev, *wev;
588     ngx_listening_t     *ls;
589     ngx_connection_t    *c, *next, *old;
590     ngx_core_conf_t     *ccf;
591     ngx_event_conf_t    *ecf;
592     ngx_event_module_t  *module;
593 
594     ccf = (ngx_core_conf_t *) ngx_get_conf(cycle-&amp;gt;conf_ctx, ngx_core_module);
595     ecf = ngx_event_get_conf(cycle-&amp;gt;conf_ctx, ngx_event_core_module);
596 
597     /*  
598      *      1。只有在多进程的模型下
599      *      2. worker进程数大于1
600      *      3. 手动开启负载均衡     如果没有指定，则默认设置为开启模式
601      *      满足以上三个条件才会开启负载均衡
602     */
603     if (ccf-&amp;gt;master &amp;amp;&amp;amp; ccf-&amp;gt;worker_processes &amp;gt; 1 &amp;amp;&amp;amp; ecf-&amp;gt;accept_mutex) {
604         ngx_use_accept_mutex = 1;   /*  开启负载均衡    */
605         ngx_accept_mutex_held = 0;
606         ngx_accept_mutex_delay = ecf-&amp;gt;accept_mutex_delay;
607 
608     } else {
609         ngx_use_accept_mutex = 0;   /*  没有开启    */
610     }
611 
612 #if (NGX_THREADS)
613     ngx_posted_events_mutex = ngx_mutex_init(cycle-&amp;gt;log, 0);
614     if (ngx_posted_events_mutex == NULL) {
615         return NGX_ERROR;
616     }
617 #endif
618 
619     if (ngx_event_timer_init(cycle-&amp;gt;log) == NGX_ERROR) {
620         return NGX_ERROR;
621     }
622 
            /*  遍历查找对应的模块 */
623     for (m = 0; ngx_modules[m]; m++) {
            /*  首先类型要为NGX_EVENT_MODULE  */
624         if (ngx_modules[m]-&amp;gt;type != NGX_EVENT_MODULE) {
625             continue;
626         }
627 
628         /*  然后在同类模块中的编号要相等 */
629         if (ngx_modules[m]-&amp;gt;ctx_index != ecf-&amp;gt;use) {
630             continue;
631         }
632 
633         module = ngx_modules[m]-&amp;gt;ctx;           /*  对应模块特有的数据 */
634 
635         if (module-&amp;gt;actions.init(cycle, ngx_timer_resolution) != NGX_OK) {
636             /* fatal */
637             exit(2);
638         }
639 
640         break;
641     }
642 


543 typedef struct {
544     ngx_uint_t    connections;      /*   连接池的大小 */
544     ngx_uint_t    use;              /*  选用的事件模块在同类事件模块中的序号  */
545     ngx_flag_t    multi_accept;     /*  标志位，如果为1，则表示在接收到一个新连接事件时，一次性建立尽可能多的连接   */
546     /*  标识位，为1表示启用负载均衡锁 */
547     ngx_flag_t    accept_mutex;
        /*
        *   负载均衡锁会使有些worker进程在拿不到锁时延迟建立新连接
        *   accept_mutex_delay就是这段延迟时间的长度
        */
548     ngx_msec_t    accept_mutex_delay;
549    u_char       *name;              /*   所选用事件模块的名字，它与use成员是匹配的   */
550 #if (NGX_DEBUG)   
551     ngx_array_t   debug_connection;
552 #endif
553 } ngx_event_conf_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/013.png&quot; alt=&quot;013&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/06/nginx-event/&quot;&gt;Nginx的IO多路复用&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 06, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nginx配置解析]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/06/nginx-config/" />
  <id>http://localhost:4000/2014/05/06/nginx-config</id>
  <published>2014-05-06T00:00:00+00:00</published>
  <updated>2014-05-06T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;为了统一配置项目的解析，nginx利用ngx_command_s数据类型对所有的nginx配置项目进行统一的描述&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;78 struct ngx_command_s {
79     ngx_str_t             name;          /*  配置名   */
80     ngx_uint_t            type;          /*  表示配置值的类型    */
                                            /*  对应配置指令的回调函数   */
81     char               *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
82     ngx_uint_t            conf;
83     ngx_uint_t            offset;        /*  指向转换后控制值的存放位置 */
84     void                 *post;          /*  在大多数情况下都为NULL */
85 };
86 
87 #define ngx_null_command  { ngx_null_string, 0, NULL, 0, 0, NULL }


    /*  这个数组对所有可能出现的配置项进行描述，设定对应的回调函数 */
33 static ngx_command_t  ngx_core_commands[] = {
34 
35         /*  设置所有可能出现的配置项的回调函数以及其他对应的处理    */
36     { ngx_string(&quot;daemon&quot;),
37       NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,
38       ngx_conf_set_flag_slot,
39       0,
40       offsetof(ngx_core_conf_t, daemon),
41       NULL },
42 
43     { ngx_string(&quot;master_process&quot;),
44       NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,
45       ngx_conf_set_flag_slot,
46       0,
47       offsetof(ngx_core_conf_t, master),
48       NULL },
49 
            ......
158 
159       ngx_null_command  /*  以它结尾    */
160 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以daemon配置名为例，当遇到配置文件中的daemon项目名时，nginx就会调用ngx_conf_set_flag_slot()回调函数来对其项目值进行解析，并根据是on还是off来将ngx_core_conf_t的daemon的字段值设置为1或0,这样就完成了配置项目信息到nginx内部实际值的转换过程&lt;/p&gt;

&lt;p&gt;其中ngx_command_s结构体中的type字段指定该配置项的多种相关信息。&lt;/p&gt;

&lt;h5&gt;配置的类型:&lt;/h5&gt;

&lt;p&gt;NGX_CONF_FLAG表示该配置项目是一个布尔类型的值，例如daemon就是一个布尔类型的配置项目，其值为on或off;&lt;/p&gt;

&lt;p&gt;NGX_CONF_BLOCK表示该配置项目为负载配置项，因此有一个由大括号组织起来的多值块，比如配置项http、event等。&lt;/p&gt;

&lt;h5&gt;配置项目的配置值的token个数:&lt;/h5&gt;

&lt;p&gt;NGX_CONF_NOARGS、NGX_CONF_TAKE1、NGX_CONF_TAKE2......NGX_CONF_TAKE7分别表示该配置项的配置值没有token、1个、2个......7个token;&lt;/p&gt;

&lt;p&gt;NGX_CONF_TAKE12、NGX_CONF_TAKE123、NGX_CONF_1MORE表示这些配置项的配置值的token个数不定，分别为1个或2个、1个或2个或3个、1个以上;&lt;/p&gt;

&lt;h5&gt;该配置项目所处的上下文:&lt;/h5&gt;

&lt;p&gt;NGX_MAIN_CONF:配置文件最外层，不包含期内的类似于http这样的配置块内部，即不向内延伸，其他上下文都有这个特性;&lt;/p&gt;

&lt;p&gt;NGX_EVENT_CONF:event的配置块&lt;/p&gt;

&lt;p&gt;NGX_HTTP_MAIN_CONF:HTTP配置块&lt;/p&gt;

&lt;p&gt;NGX_HTTP_SRV_CONF:HTTP的server指令配置块&lt;/p&gt;

&lt;p&gt;NGX_HTTP_LOC_CONF:HTTP的location指令配置块&lt;/p&gt;

&lt;p&gt;......等等&lt;/p&gt;

&lt;p&gt;post字段在大多数情况下都为NULL，但是在某些特殊配置项中也会指定其值，而且多为回调函数指针。&lt;/p&gt;

&lt;p&gt;每个模块都把自己所需要的配置项目对应的ngx_command_s结构体变量组成一个数组，以ngx_xxx_xxx_commands的形式命名，该数组以元素ngx_null_command作为结束标识&lt;/p&gt;

&lt;h4&gt;配置文件解析流程&lt;/h4&gt;

&lt;p&gt;假设以命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx -c /usr/local/niginx/conf/nginx.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动nginx&lt;/p&gt;

&lt;p&gt;nginx.conf的内容如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;worker_processes  2;
error_log  logs/error.log debug;    


events {
    worker_connections  1024;   
}


http {
    include       mime.types;       # 文件类型
    default_type  application/octet-stream;

    server {
        listen       8888;
        server_name  localhost;

        location / {
            root   html;
            index  index.html index.htm;
        }
        error_page 404 /404.html
        error_page 500 502 503 504 /50x.html

        location = /50x.html {
            root html;
        }
    }
}

在函数ngx_conf_parse处下断点，我们可以看到ngx_conf_parse有两个参数

Breakpoint 1, ngx_conf_parse (cf=cf@entry=0xbffff0c0, filename=filename@entry=0x80e3aa8) at src/core/ngx_conf_file.c:104
(gdb) p *filename
$2 = {len = 32, data = 0x80e3aff &quot;/usr/local/nginx/conf/nginx.conf&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二个参数filename街头体中保存这配置文件路径的字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ngx_str_t的定义
16 typedef struct {
17     size_t      len;
18     u_char     *data;
19 } ngx_str_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ngx_conf_parse()函数是执行配置文件解析的关键函数&lt;/p&gt;

&lt;p&gt;ngx_conf_parse总体将配置内容的解析过程分为三部分&lt;/p&gt;

&lt;p&gt;1.判断当前解析状态&lt;/p&gt;

&lt;p&gt;2.读取配置标记token&lt;/p&gt;

&lt;p&gt;3.读取了合适数量的标记token后对其进行实际的处理，也就是将配置值转换为Nginx内对应控制变量的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;103 ngx_conf_parse(ngx_conf_t *cf, ngx_str_t *filename)
104 {
105     char             *rv;
106     ngx_fd_t          fd;
107     ngx_int_t         rc;
108     ngx_buf_t         buf;
109     ngx_conf_file_t  *prev, conf_file;
        /*  三种状态    */
110     enum {
111         parse_file = 0,
112         parse_block,
113         parse_param
114     } type;
115 
116 #if (NGX_SUPPRESS_WARN)
117     fd = NGX_INVALID_FILE;
118     prev = NULL;
119 #endif
120 
        /*  首先判断路径是否存在  */
121     if (filename) {
122 
123         /* open configuration file */
124 
125         fd = ngx_open_file(filename-&amp;gt;data, NGX_FILE_RDONLY, NGX_FILE_OPEN, 0);
126         if (fd == NGX_INVALID_FILE) {
127             ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,
128                                ngx_open_file_n &quot; \&quot;%s\&quot; failed&quot;,
129                                filename-&amp;gt;data);
130             return NGX_CONF_ERROR;
131         }
132 
133         prev = cf-&amp;gt;conf_file;
134 
135         cf-&amp;gt;conf_file = &amp;amp;conf_file;
136 
137         if (ngx_fd_info(fd, &amp;amp;cf-&amp;gt;conf_file-&amp;gt;file.info) == -1) {
138             ngx_log_error(NGX_LOG_EMERG, cf-&amp;gt;log, ngx_errno,

139                           ngx_fd_info_n &quot; \&quot;%s\&quot; failed&quot;, filename-&amp;gt;data);
140         }
141 
            /*  cf-&amp;gt;conf_file-&amp;gt;buffer将直接使用buf */
142         cf-&amp;gt;conf_file-&amp;gt;buffer = &amp;amp;buf;
143             
            /*  分配buf的空间  */
144         buf.start = ngx_alloc(NGX_CONF_BUFFER, cf-&amp;gt;log);
145         if (buf.start == NULL) {
146             goto failed;
147         }
148 
149         buf.pos = buf.start;
150         buf.last = buf.start;
151         buf.end = buf.last + NGX_CONF_BUFFER;   /*  指定buf的空间范围,到end结束   */
152         buf.temporary = 1;
153 
154         cf-&amp;gt;conf_file-&amp;gt;file.fd = fd;
155         cf-&amp;gt;conf_file-&amp;gt;file.name.len = filename-&amp;gt;len;
156         cf-&amp;gt;conf_file-&amp;gt;file.name.data = filename-&amp;gt;data;
157         cf-&amp;gt;conf_file-&amp;gt;file.offset = 0;
158         cf-&amp;gt;conf_file-&amp;gt;file.log = cf-&amp;gt;log;
159         cf-&amp;gt;conf_file-&amp;gt;line = 1;
160 
            /*  设置状态标记  */
161         type = parse_file;      
162 
            /*  读取复杂配置项目，一般是递归调用ngx_conf_parse所以filename一般设置为空???   */
163     } else if (cf-&amp;gt;conf_file-&amp;gt;file.fd != NGX_INVALID_FILE) {
164 
165         type = parse_block;
166 
        /*  这个到底是怎么判断的???   */  
167     } else {
168         type = parse_param;
169     }
170 
171 
172     for ( ;; ) {

            /*  循环从配置文件里读取token */
173         rc = ngx_conf_read_token(cf);
174 
175         /*  
176          * ngx_conf_read_token() may return
177          *
178          *    NGX_ERROR             there is error
179          *    NGX_OK                the token terminated by &quot;;&quot; was found
180          *    NGX_CONF_BLOCK_START  the token terminated by &quot;{&quot; was found
181          *    NGX_CONF_BLOCK_DONE   the &quot;}&quot; was found
182          *    NGX_CONF_FILE_DONE    the configuration file is done
183          */
184 
185         if (rc == NGX_ERROR) {
186             goto done;
187         }
188 
189         if (rc == NGX_CONF_BLOCK_DONE) {
190 
                /*  type具体的含义见下文    */
191             if (type != parse_block) {
192                 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, &quot;unexpected \&quot;}\&quot;&quot;);
193                 goto failed;
194             }
195 
196             goto done;
197         }
198 
199         if (rc == NGX_CONF_FILE_DONE) {
200 
201             if (type == parse_block) {
202                 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
203                                    &quot;unexpected end of file, expecting \&quot;}\&quot;&quot;);
204                 goto failed;
205             }
206 
207             goto done;
208         }
209 
210         if (rc == NGX_CONF_BLOCK_START) {
211 
212             if (type == parse_param) {
213                 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
214                                    &quot;block directives are not supported &quot;
215                                    &quot;in -g option&quot;);
216                 goto failed;
217             }
218         }
219 
220         /* rc == NGX_OK || rc == NGX_CONF_BLOCK_START */
221 
            /*  
            *   这个主要是针对类似 text/html html htm;之类不定配置项,这些配置项众多且变化不定,
            *   但格式统一,一般是以key/values的形式存在的    
            *   nginx只是将其拷贝到对应的变量内,所以此时一般提供一个统一的handler便是cf-&amp;gt;handler
            *   比如type指令的处理函数ngx_http_core_types就会将cf-&amp;gt;handler赋值为ngx_http_core_types
            */
222         if (cf-&amp;gt;handler) {
223 
224             /*
225              * the custom handler, i.e., that is used in the http&#39;s
226              * &quot;types { ... }&quot; directive
227              */
228 
229             rv = (*cf-&amp;gt;handler)(cf, NULL, cf-&amp;gt;handler_conf);
230             if (rv == NGX_CONF_OK) {
231                 continue;
232             }
233 
234             if (rv == NGX_CONF_ERROR) {
235                 goto failed;
236             }
237 
238             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, rv);
239 
240             goto failed;
241         }
242 
243 
            /*  
            *   配置转换的核心函数 
            *   两个参数分别是cf和rc
            *   cf中包含了很多参数,比如要转换的token就保存在cf-&amp;gt;args中
            *   rc记录的是最近一次ngx_conf_read_token函数返回值
            */
244         rc = ngx_conf_handler(cf, rc);
245 
246         if (rc == NGX_ERROR) {
247             goto failed;
248         }
249     }
250 
251 failed:
252 
253     rc = NGX_ERROR;
254 
255 done:
256 
257     if (filename) {
258         if (cf-&amp;gt;conf_file-&amp;gt;buffer-&amp;gt;start) {
259             ngx_free(cf-&amp;gt;conf_file-&amp;gt;buffer-&amp;gt;start);
260         }
261 
262         if (ngx_close_file(fd) == NGX_FILE_ERROR) {
263             ngx_log_error(NGX_LOG_ALERT, cf-&amp;gt;log, ngx_errno,
264                           ngx_close_file_n &quot; %s failed&quot;,
265                           filename-&amp;gt;data);
266             return NGX_CONF_ERROR;
267         }
268 
269         cf-&amp;gt;conf_file = prev;
270     }
271 
272     if (rc == NGX_ERROR) {
273         return NGX_CONF_ERROR;
274     }
275 
276     return NGX_CONF_OK;
277 }
278 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入ngx_conf_parse函数后，第一步要做的是判断当前解析过程处于一个什么样的状态，有三种可能&lt;/p&gt;

&lt;h5&gt;parse_file: 正要解析一个配置文件&lt;/h5&gt;

&lt;p&gt;此时参数filename指向一个配置文件路径字符串，需要函数ngx_conf_parse()打开该文件并获取相关的文件信息(比如文件描述符)以便下面代码读取文件内容并进行解析。除了在上面Nginx启动时候开始配置文件解析属于这种情况外，还有当遇到include指令时候也要以这种状态调用ngx_conf_parse函数，因为include指令表示一个新的配置文件要开始解析，此时type=parse_file&lt;/p&gt;

&lt;h5&gt;parse_block: 正要解析一个复杂配置项&lt;/h5&gt;

&lt;p&gt;此时配置文件已经打开并且也已经对文件进行了解析，当遇到复杂的配置项例如events或是http时候，这些复杂配置项的处理函数又会递归调用ngx_conf_parse函数，此时解析的内容还是来自当前的配置文件，因此无需在打开它，此时type=parse_block;&lt;/p&gt;

&lt;h5&gt;parse_param: 主要开始解析命令行参数配置项值&lt;/h5&gt;

&lt;p&gt;在对用户通过命令行-g参数输入的配置信息进行解析时候处于这种状态，比如: nginx -g &#39;daemon on&#39;.nginx在调用ngx_conf_parse函数对命令行参数配置信息&#39;daemon on&#39;进行解析时候就是这种状态，type=parse_param&lt;/p&gt;

&lt;p&gt;当判断好解析状态之后就开始读取配置文件内容，配置文件都是由一个个token组成，因此接下来应该是循环从配置文件里读取token，主要有函数ngx_conf_read_token来实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /*  buf的结构    */
18 typedef struct ngx_buf_s  ngx_buf_t;
19 
20 struct ngx_buf_s {
        /*
        *   pos通常用来该哦啊素使用者保额次应该从pos这个位置开始处理内存中的数据
        *   因为同一个ngx_buf_t很有可能被反复处理
        */
21     u_char          *pos;            
        /*
        *   last通常表示有效的内容到此为止
        *   pos与last之间的内容是希望被nginx处理的内容
        *
        */
22     u_char          *last;           

        /*  处理文件时候,file_pos与file_last的含义与处理内存时候的pos与last相同    */
23     off_t            file_pos;   
24     off_t            file_last;      
25    
        /*  start与end指向内存缓冲区的起始与结束位置,pos与last都是基于这段内存的  */
26     u_char          *start;         /* start of buffer */
27     u_char          *end;           /* end of buffer */  
28     ngx_buf_tag_t    tag;
29     ngx_file_t      *file;
30     ngx_buf_t       *shadow;
31    
32    
33     /* the buf&#39;s content could be changed */
34     unsigned         temporary:1;         
35                 
36     /*
37      * the buf&#39;s content is in a memory cache or in a read only memory
38      * and must not be changed
39      */
40     unsigned         memory:1;
41    
42     /* the buf&#39;s content is mmap()ed and must not be changed */
43     unsigned         mmap:1;
44                 
45     unsigned         recycled:1;
46     unsigned         in_file:1;
47     unsigned         flush:1;
48     unsigned         sync:1;
49     unsigned         last_buf:1;
50     unsigned         last_in_chain:1;     
51 
52     unsigned         last_shadow:1;       
53     unsigned         temp_file:1;         
54 
55     /* STUB */ int   num;
56 };



434 static ngx_int_t
435 ngx_conf_read_token(ngx_conf_t *cf)
436 {
437     u_char      *start, ch, *src, *dst;
438     off_t        file_size; 
439     size_t       len;
440     ssize_t      n, size;
441     ngx_uint_t   found, need_space, last_space, sharp_comment, variable;
442     ngx_uint_t   quoted, s_quoted, d_quoted, start_line;
443     ngx_str_t   *word;
444     ngx_buf_t   *b;
445 
446     found = 0;
447     need_space = 0;
448     last_space = 1;
449     sharp_comment = 0;
450     variable = 0; 
451     quoted = 0;
452     s_quoted = 0;
453     d_quoted = 0;
454 
455     cf-&amp;gt;args-&amp;gt;nelts = 0;
456     b = cf-&amp;gt;conf_file-&amp;gt;buffer;
457     start = b-&amp;gt;pos;
458     start_line = cf-&amp;gt;conf_file-&amp;gt;line;
459 
460     file_size = ngx_file_size(&amp;amp;cf-&amp;gt;conf_file-&amp;gt;file.info);
461 
462     for ( ;; ) {
463 
464         if (b-&amp;gt;pos &amp;gt;= b-&amp;gt;last) {
465 
466             if (cf-&amp;gt;conf_file-&amp;gt;file.offset &amp;gt;= file_size) {
467 
468                 if (cf-&amp;gt;args-&amp;gt;nelts &amp;gt; 0 || !last_space) {
469 
470                     if (cf-&amp;gt;conf_file-&amp;gt;file.fd == NGX_INVALID_FILE) {
471                         ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
472                                            &quot;unexpected end of parameter, &quot;
473                                            &quot;expecting \&quot;;\&quot;&quot;);
474                         return NGX_ERROR;
475                     }
476 
477                     ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
478                                   &quot;unexpected end of file, &quot;
479                                   &quot;expecting \&quot;;\&quot; or \&quot;}\&quot;&quot;);
480                     return NGX_ERROR;
481                 }
482 
483                 return NGX_CONF_FILE_DONE;
484             }
485 
486             len = b-&amp;gt;pos - start;
487 
488             if (len == NGX_CONF_BUFFER) {
489                 cf-&amp;gt;conf_file-&amp;gt;line = start_line;
490 
491                 if (d_quoted) {
492                     ch = &#39;&quot;&#39;;
493 
494                 } else if (s_quoted) {
495                     ch = &#39;\&#39;&#39;;
496 
497                 } else {
498                     ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
499                                        &quot;too long parameter \&quot;%*s...\&quot; started&quot;,
500                                        10, start);
501                     return NGX_ERROR;
502                 }
503 
504                 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
505                                    &quot;too long parameter, probably &quot;
506                                    &quot;missing terminating \&quot;%c\&quot; character&quot;, ch);
507                 return NGX_ERROR;
508             }
509 
510             if (len) {
511                 ngx_memmove(b-&amp;gt;start, start, len);
512             }
513 
514             size = (ssize_t) (file_size - cf-&amp;gt;conf_file-&amp;gt;file.offset);
515 
516             if (size &amp;gt; b-&amp;gt;end - (b-&amp;gt;start + len)) {
517                 size = b-&amp;gt;end - (b-&amp;gt;start + len);
518             }
519 
520             n = ngx_read_file(&amp;amp;cf-&amp;gt;conf_file-&amp;gt;file, b-&amp;gt;start + len, size,
521                               cf-&amp;gt;conf_file-&amp;gt;file.offset);
522 
523             if (n == NGX_ERROR) {
524                 return NGX_ERROR;
525             }
526 
527             if (n != size) {
528                 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
529                                    ngx_read_file_n &quot; returned &quot;
530                                    &quot;only %z bytes instead of %z&quot;,
531                                    n, size);
532                 return NGX_ERROR;
533             }
534 
535             b-&amp;gt;pos = b-&amp;gt;start + len;
536             b-&amp;gt;last = b-&amp;gt;pos + n;
537             start = b-&amp;gt;start;
538         }
539 
540         ch = *b-&amp;gt;pos++;
541 
542         if (ch == LF) {
543             cf-&amp;gt;conf_file-&amp;gt;line++;
544 
545             if (sharp_comment) {
546                 sharp_comment = 0;
547             }
548         }
549 
550         if (sharp_comment) {
551             continue;
552         }
553 
554         if (quoted) {
555             quoted = 0;
556             continue;
557         }
558 
559         if (need_space) {
560             if (ch == &#39; &#39; || ch == &#39;\t&#39; || ch == CR || ch == LF) {
561                 last_space = 1;
562                 need_space = 0;
563                 continue;
564             }
565 
566             if (ch == &#39;;&#39;) {
567                 return NGX_OK;
568             }
569 
570             if (ch == &#39;{&#39;) {
571                 return NGX_CONF_BLOCK_START;
572             }
573 
574             if (ch == &#39;)&#39;) {
575                 last_space = 1;
576                 need_space = 0;
577 
578             } else {
579                  ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
580                                     &quot;unexpected \&quot;%c\&quot;&quot;, ch);
581                  return NGX_ERROR;
582             }
583         }
584 
585         if (last_space) {
586             if (ch == &#39; &#39; || ch == &#39;\t&#39; || ch == CR || ch == LF) {
587                 continue;
588             }
589 
590             start = b-&amp;gt;pos - 1;
591             start_line = cf-&amp;gt;conf_file-&amp;gt;line;
592 
593             switch (ch) {
594 
595             case &#39;;&#39;:
596             case &#39;{&#39;:
597                 if (cf-&amp;gt;args-&amp;gt;nelts == 0) {
598                     ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
599                                        &quot;unexpected \&quot;%c\&quot;&quot;, ch);
600                     return NGX_ERROR;
601                 }
602 
603                 if (ch == &#39;{&#39;) {
604                     return NGX_CONF_BLOCK_START;
605                 }
606 
607                 return NGX_OK;
608 
609             case &#39;}&#39;:
610                 if (cf-&amp;gt;args-&amp;gt;nelts != 0) {
611                     ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
612                                        &quot;unexpected \&quot;}\&quot;&quot;);
613                     return NGX_ERROR;
614                 }
615 
616                 return NGX_CONF_BLOCK_DONE;
617 
618             case &#39;#&#39;:
619                 sharp_comment = 1;
620                 continue;
621 
622             case &#39;\\&#39;:
623                 quoted = 1;
624                 last_space = 0;
625                 continue;
626 
627             case &#39;&quot;&#39;:
628                 start++;
629                 d_quoted = 1;
630                 last_space = 0;
631                 continue;
632 
633             case &#39;\&#39;&#39;:
634                 start++;
635                 s_quoted = 1;
636                 last_space = 0;
637                 continue;
638 
639             default:
640                 last_space = 0;
641             }
642 
643         } else {
644             if (ch == &#39;{&#39; &amp;amp;&amp;amp; variable) {
645                 continue;
646             }
647 
648             variable = 0;
649 
650             if (ch == &#39;\\&#39;) {
651                 quoted = 1;
652                 continue;
653             }
654 
655             if (ch == &#39;$&#39;) {

656                 variable = 1;
657                 continue;
658             }
659 
660             if (d_quoted) {
661                 if (ch == &#39;&quot;&#39;) {
662                     d_quoted = 0;
663                     need_space = 1;
664                     found = 1;
665                 }
666 
667             } else if (s_quoted) {
668                 if (ch == &#39;\&#39;&#39;) {
669                     s_quoted = 0;
670                     need_space = 1;
671                     found = 1;
672                 }
673 
674             } else if (ch == &#39; &#39; || ch == &#39;\t&#39; || ch == CR || ch == LF
675                        || ch == &#39;;&#39; || ch == &#39;{&#39;)
676             {
677                 last_space = 1;
678                 found = 1;
679             }
680 
681             if (found) {
682                 word = ngx_array_push(cf-&amp;gt;args);
683                 if (word == NULL) {
684                     return NGX_ERROR;
685                 }
686 
687                 word-&amp;gt;data = ngx_pnalloc(cf-&amp;gt;pool, b-&amp;gt;pos - start + 1);
688                 if (word-&amp;gt;data == NULL) {
689                     return NGX_ERROR;
690                 }
691 
692                 for (dst = word-&amp;gt;data, src = start, len = 0;
693                      src &amp;lt; b-&amp;gt;pos - 1;
694                      len++)
695                 {
696                     if (*src == &#39;\\&#39;) {
697                         switch (src[1]) {
698                         case &#39;&quot;&#39;:
699                         case &#39;\&#39;&#39;:
700                         case &#39;\\&#39;:
701                             src++;
702                             break;
703 
704                         case &#39;t&#39;:
705                             *dst++ = &#39;\t&#39;;
706                             src += 2;
707                             continue;
708 
709                         case &#39;r&#39;:
710                             *dst++ = &#39;\r&#39;;
711                             src += 2;
712                             continue;
713 
714                         case &#39;n&#39;:
715                             *dst++ = &#39;\n&#39;;
716                             src += 2;
717                             continue;
718                         }
719 
720                     }
721                     *dst++ = *src++;
722                 }
723                 *dst = &#39;\0&#39;;
724                 word-&amp;gt;len = len;
725 
726                 if (ch == &#39;;&#39;) {                    /*  返回表示读取完一个简单配置项的标记 */
727                     return NGX_OK;
728                 }
729 
730                 if (== &#39;{&#39;) {
731                    return NGX_CONF_BLOCK_START;     /*  返回开始读取负载配置项的标记  */
732                 }
733
734                     found = 0;
735             }
736         }
737     }
738 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ngx_conf_read_token会对配置文件进行逐个字符扫描并解析出单个的token，但是这个函数并不会去频繁的读取配置文件，它每次从文件内读取足够多的内容以填满一个大小为NGX_CONF_BUFFER(4096)的缓冲区(除了最后一次，配置文件本身剩余内容不足4096)，这个缓冲区在函数内申请并保存到引用变量cf-&gt;conf_file-&gt;buffer中，函数ngx_conf_read_token将会返回使用该缓存区，缓存区也有一些状态。&lt;/p&gt;

&lt;h5&gt;1.初始状态&lt;/h5&gt;

&lt;p&gt;函数ngx_conf_parse()内申请缓冲区后的初始状态&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/007.png&quot; alt=&quot;007&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;2.处理过程的中间状态&lt;/h5&gt;

&lt;p&gt;有一部分配置内容已经被解析为一个个token并保存起来，而有一部分内容主要被组合成token，还有一部分内容等待处理,已解析的字符和已扫描的字符都属于已处理的字符，但是已解析的字符已经被作为token额外保存起来，所以这些字符已经没有什么用处了，而已扫描的字符表示这些字符还没有组成一个完成的token，所以他们不能被丢弃。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/008.png&quot; alt=&quot;008&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;3.缓存区中字符都处理完状态&lt;/h5&gt;

&lt;p&gt;缓存区中字符都处理完时，需要继续从打开的配置文件中读取新的内容到缓存中此时的临界状态如图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/009.png&quot; alt=&quot;009&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为解析过的字符已经没有什么用了，所以我们将已经扫描但是还没有组成token的字符移动到缓存的前面，然后从配置文件读取内容填满缓存区剩下的空间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/010.png&quot; alt=&quot;010&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于最后一次读取，无法填满缓冲区的情况如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/011.png&quot; alt=&quot;011&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ngx_conf_read_token在读取了合适数量的标记token之后就开始下一个步骤，对这些标记进行实际的处理，读到多少才算合适呢？&lt;/p&gt;

&lt;p&gt;对于简单配置项，读取其全部标记，也就是遇到配置项结束标记分号为止;此时一条简单配置项的所有标记都已经被读取并存放在cf-&gt;args数组内，因此可以开始下一步，即执行回调函数进行实际性的解析处理;&lt;/p&gt;

&lt;p&gt;对于负载配置项则是读取完其配置块内所有的标记，即遇到大括号{为止，此时负载配置项处理函数所需要的标记都已经读取到，而对于配置块{}内的标记将在接下来的函数ngx_conf_parse递归调用中继续处理，这是个反复的过程，当然如果配置文件出错就会直接返回了。&lt;/p&gt;

&lt;p&gt;ngx_conf_parse函数识别并将token缓存到cf-&gt;args数组中,首先对配置文件临时缓存区内容调整,接着通过缓冲区从前往后扫描整个配置文件的内容,对每一个字符与前面已经扫描字符的组合进行有效性检测并进行一些状态旗标设置,比如d_quoted旗标置1则表示当前处于双引号字符串后,last_space置1则表示当前一个字符为空白字符,这些旗标能够大大方便接下来的字符有效性组合检测.&lt;/p&gt;

&lt;p&gt;再接下来就是判断当前已经扫描字符是否能够组成一个token标记,两个双引号,两个单引号,两个空白字符之间的字符就能组成一个token标记,此时cf-&gt;args数组内申请对应的存储空间并机型token标记字符串拷贝,从而完成了一个token标记的解析与读取工作,此时根据情况要么继续进行下一个token标记的解析与读取,要么返回到ngx_conf_parse函数进行实际处理.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;13 typedef struct ngx_conf_s        ngx_conf_t;

166 struct ngx_conf_s {
167     char                 *name;         /*  没有使用    */
168     ngx_array_t          *args;         /*  指令的参数 */
169 
170     ngx_cycle_t          *cycle;        /*  指向系统参数，在系统整个运行过程中，  */
171                                         /*  需要使用的一些参数、资源需要统一的管理   */
172     ngx_pool_t           *pool;         /*  内存池   */
173     ngx_pool_t           *temp_pool;    /*  分配临时数据空间的内存池    */
174     ngx_conf_file_t      *conf_file;    /*  配置文件的信息   */
175     ngx_log_t            *log;          /*  日志      */
176 
177     void                 *ctx;          /*  模块的配置信息   */
178     ngx_uint_t            module_type;  /*  当前指令的类型   */
179     ngx_uint_t            cmd_type;     /*  命令的类型 */
180 
181     ngx_conf_handler_pt   handler;      /*  指令处理函数，有自己行为的在这里实现  */
182     char                 *handler_conf; /*  指令处理函数的配置信息   */
183};

16 // 动态数组
17 struct ngx_array_s {
18                          
19     void        *elts;       /*  elts指向数组的首地址 */
20     
21     ngx_uint_t   nelts;      /* nelts是数组中已经使用的元素个数 */
22     
23     size_t       size;       /* 每个数组元素占用的内存大小 */
24     
25     ngx_uint_t   nalloc;     /* 当前数组中能够容纳元素个数的总大小 */
26     
27     ngx_pool_t  *pool;       /* 内存池对象  */
28 };
29 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是在ngx_conf_parse函数中打印的一些内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(gdb) p (*cf-&amp;gt;args)-&amp;gt;nelts
$6 = 2
(gdb) p *((ngx_str_t*)((*cf-&amp;gt;args)-&amp;gt;elts))
$7 = {len = 16, data = 0x80e33d8 &quot;worker_processes&quot;}
(gdb) p *((ngx_str_t*)((*cf-&amp;gt;args)-&amp;gt;elts+sizeof(ngx_str_t)))
$8 = {len = 1, data = 0x80e33ea &quot;2&quot;}
(gdb) p (*cf-&amp;gt;args)-&amp;gt;elts
$9 = (void *) 0x80e3388
(gdb) p (*cf-&amp;gt;args)-&amp;gt;nelts
$10 = 2
(gdb) p filename
$11 = (ngx_str_t *) 0x80e2ac8
(gdb) p *filename
$12 = {len = 32, data = 0x80e2b1f &quot;/usr/local/nginx/conf/nginx.conf&quot;}
(gdb) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时解析转换所需要的token都已经被保存到cf-&gt;args中了,接下来要将这些token转换为nginx内控制变量的值,ngx_conf_handler函数的作用便是如此&lt;/p&gt;

&lt;p&gt;nginx的每一个配置指令都对应一个ngx_command_s数据类型变量,记录这该配置指令的回调函数,转换值的存储位置等,而每一个模块又都把自身锁相关的所有指令以数组的形式组织起来,所以ngx_conf_handler首先做的就是查找当前指令所对应的ngx_command_s变量,通过循环遍历各个模块的指令数组即可,nginx的所有模块也是用数组形式组织的,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;281 static ngx_int_t
282 ngx_conf_handler(ngx_conf_t *cf, ngx_int_t last)
283 {
284     char           *rv;
285     void           *conf, **confp;
286     ngx_uint_t      i, multi;
287     ngx_str_t      *name;
288     ngx_command_t  *cmd;
289 
        /*  以work_process为例,elts类型为ngx_str_t    */
290     name = cf-&amp;gt;args-&amp;gt;elts;
291 
292     multi = 0;
293 
        /*  遍历各个模块,数组中结尾的是空结构的哨兵  */
294     for (i = 0; ngx_modules[i]; i++) {
295 
296         /* look up the directive in the appropriate modules */
297 
            /*  
            *   一定是在NGX_CONF_MODULE类型的模块中找
            *   并且模块类型与cf-&amp;gt;module_type的类型必须相同   
            */
298         if (ngx_modules[i]-&amp;gt;type != NGX_CONF_MODULE
299             &amp;amp;&amp;amp; ngx_modules[i]-&amp;gt;type != cf-&amp;gt;module_type)
300         {
301             continue;
302         }
303 
304         cmd = ngx_modules[i]-&amp;gt;commands;
305         if (cmd == NULL) {
306             continue;
307         }
308 
309         for ( /* void */ ; cmd-&amp;gt;name.len; cmd++) {
310             
                /*  首先比较长度,长度不同没有必要再去比较了  */
311             if (name-&amp;gt;len != cmd-&amp;gt;name.len) {
312                 continue;
313             }
314 
                /*  长度相同在比较具体的字符是否相同    */
315             if (ngx_strcmp(name-&amp;gt;data, cmd-&amp;gt;name.data) != 0) {
316                 continue;
317             }
318 
319 
320             /* is the directive&#39;s location right ? */
321 
322             if (!(cmd-&amp;gt;type &amp;amp; cf-&amp;gt;cmd_type)) {
323                 if (cmd-&amp;gt;type &amp;amp; NGX_CONF_MULTI) {
324                     multi = 1;
325                     continue;
326                 }
327 
328                 goto not_allowed;
329             }
330 
331             if (!(cmd-&amp;gt;type &amp;amp; NGX_CONF_BLOCK) &amp;amp;&amp;amp; last != NGX_OK) {
332                 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
333                                   &quot;directive \&quot;%s\&quot; is not terminated by \&quot;;\&quot;&quot;,
334                                   name-&amp;gt;data);
335                 return NGX_ERROR;
336             }
337 
338             if ((cmd-&amp;gt;type &amp;amp; NGX_CONF_BLOCK) &amp;amp;&amp;amp; last != NGX_CONF_BLOCK_START) {
339                 ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
340                                    &quot;directive \&quot;%s\&quot; has no opening \&quot;{\&quot;&quot;,
341                                    name-&amp;gt;data);
342                 return NGX_ERROR;
343             }
344 
345             /* is the directive&#39;s argument count right ? */
346 
347             if (!(cmd-&amp;gt;type &amp;amp; NGX_CONF_ANY)) {
348 
349                 if (cmd-&amp;gt;type &amp;amp; NGX_CONF_FLAG) {
350 
351                     if (cf-&amp;gt;args-&amp;gt;nelts != 2) {
352                         goto invalid;
353                     }
354 
355                 } else if (cmd-&amp;gt;type &amp;amp; NGX_CONF_1MORE) {
356 
357                     if (cf-&amp;gt;args-&amp;gt;nelts &amp;lt; 2) {
358                         goto invalid;
359                     }
360 
361                 } else if (cmd-&amp;gt;type &amp;amp; NGX_CONF_2MORE) {
362 
363                     if (cf-&amp;gt;args-&amp;gt;nelts &amp;lt; 3) {
364                         goto invalid;
365                     }
366 
367                 } else if (cf-&amp;gt;args-&amp;gt;nelts &amp;gt; NGX_CONF_MAX_ARGS) {
368 
369                     goto invalid;
370 
371                 } else if (!(cmd-&amp;gt;type &amp;amp; argument_number[cf-&amp;gt;args-&amp;gt;nelts - 1]))
372                 {
373                     goto invalid;
374                 }
375             }
376 
377             /* set up the directive&#39;s configuration context */
378 
379             conf = NULL;
380 
381             if (cmd-&amp;gt;type &amp;amp; NGX_DIRECT_CONF) {
382                 conf = ((void **) cf-&amp;gt;ctx)[ngx_modules[i]-&amp;gt;index];
383 
384             } else if (cmd-&amp;gt;type &amp;amp; NGX_MAIN_CONF) {
385                 conf = &amp;amp;(((void **) cf-&amp;gt;ctx)[ngx_modules[i]-&amp;gt;index]);
e if (cf-&amp;gt;ctx) {
388                 confp = *(void **) ((char *) cf-&amp;gt;ctx + cmd-&amp;gt;conf);
389 
390                 if (confp) {
391                     conf = confp[ngx_modules[i]-&amp;gt;ctx_index];
392                 }
393             }
394 
395             rv = cmd-&amp;gt;set(cf, cmd, conf);
396 
397             if (rv == NGX_CONF_OK) {
398                 return NGX_OK;
399             }
400 
401             if (rv == NGX_CONF_ERROR) {
402                 return NGX_ERROR;
403             }
404 
405             ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
406                                &quot;\&quot;%s\&quot; directive %s&quot;, name-&amp;gt;data, rv);
407 
408             return NGX_ERROR;
409         }
410     }
411 
412     if (multi == 0) {
413         ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
414                            &quot;unknown directive \&quot;%s\&quot;&quot;, name-&amp;gt;data);
415 
416         return NGX_ERROR;
417     }
418 
419 not_allowed:
420 
421     ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
422                        &quot;\&quot;%s\&quot; directive is not allowed here&quot;, name-&amp;gt;data);
423     return NGX_ERROR;
424 
425 invalid:
426 
427     ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
428                        &quot;invalid number of arguments in \&quot;%s\&quot; directive&quot;,
429                        name-&amp;gt;data);
430 
431     return NGX_ERROR;
432 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以worker_processes为例,当查找到worker_processes配置指令对应的ngx_command_s变量时,就开始调用回调函数进行处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 70     { ngx_string(&quot;worker_processes&quot;),
 71       NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,
 72       ngx_conf_set_num_slot,    /*      worker_processes的回调函数set  */
 73       0,
 74       offsetof(ngx_core_conf_t, worker_processes),
 75       NULL },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;worker_processes的回调函数是ngx_conf_set_num_slot,它的主要作用是找到在将cf中值的存储的位置,然后利用ngx_atoi来将字符串转换为数字,存储到对应的位置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1203 char *
1204 ngx_conf_set_num_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
1205 {
1206     char  *p = conf;
1207 
1208     ngx_int_t        *np;
1209     ngx_str_t        *value;
1210     ngx_conf_post_t  *post;
1211 
1212    /*  找到存储位置  */ 
1213     np = (ngx_int_t *) (p + cmd-&amp;gt;offset);
1214 
1215     if (*np != NGX_CONF_UNSET) {
1216         return &quot;is duplicate&quot;;
1217     }
1218 
1219     value = cf-&amp;gt;args-&amp;gt;elts;
        /*  value[0]存储的是worker_processes及其长度,value[1]中存储的就是worker_processes之后的配置参素    */
1220     *np = ngx_atoi(value[1].data, value[1].len); //把value后面的buffer强制转为一个str
1221     if (*np == NGX_ERROR) {
1222         return &quot;invalid number&quot;;
1223     }

1224    /*      post多数情况下都是NULL   */ 
1225     if (cmd-&amp;gt;post) {
1226         post = cmd-&amp;gt;post;
1227         return post-&amp;gt;post_handler(cf, post, np);
1228     }
1229 
1230     return NGX_CONF_OK;
1231 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nginx配置文件解析的流程图如下:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/012.png&quot; alt=&quot;012&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/06/nginx-config/&quot;&gt;nginx配置解析&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 06, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nginx的多核绑定]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/05/nginx-per-cpu/" />
  <id>http://localhost:4000/2014/05/05/nginx-per-cpu</id>
  <published>2014-05-05T00:00:00+00:00</published>
  <updated>2014-05-05T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;h4&gt;多核绑定&lt;/h4&gt;

&lt;p&gt;对于多核平台的优化，最核心的思路就是per-cpu处理，这样才能做到性能按cpu线性扩展。&lt;/p&gt;

&lt;p&gt;nginx在多核平台上针对负载均衡和优化所做的工作，就是提供了worker_cpu_affinity配置指令，该指令可以将工作进程固定在指定的CPU核上运行，这个又叫做cpu亲和性;&lt;/p&gt;

&lt;p&gt;CPU亲和性就是让某一段代码/数据尽量的在指定的一个或几个cpu核心上长时间运行/计算的机制。&lt;/p&gt;

&lt;p&gt;nginx将工作进程绑定到指定cpu是cpu affinity的一种应用&lt;/p&gt;

&lt;p&gt;nginx中配置cpu亲和性的使用配置首先根据系统CPU个数设定工作进程数目，我的CPU是4核，所以就设定为4,一般工作进程数目与CPU数目一致，否则太多可能导致进程切换频繁，使得整体性能下降。&lt;/p&gt;

&lt;p&gt;让0号工作进程运行在0号cpu上，一号进程运行在1号cpu上&lt;/p&gt;

&lt;p&gt;可以在配置文件中使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;5 worker_processes  4;                  #指定4个工作进程
6 worker_cpu_affinity 01 10 100 1000;   #指定各个工作进程使用哪个CPU
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;worker_cpu_affinity指令的配置值是位图表示法，从前往后分别是0号工作进程、1号工作进程的CPU二进制掩码(各个掩码之间使用空格隔开)，所以这里0号工作进程的CPU掩码为01,表示使用0号cpu，1号工作进程的cpu掩码为10,表示使用1号cpu，如果某个工作进程的掩码是11,则表示既使用0号CPU又使用1号cpu。&lt;/p&gt;

&lt;p&gt;其中PSR代表的是cpu编号，可以看到4个worker进程分别在0-3的cpu上
    [root@ sbin]# ps -elHF | grep UID  | grep -v grep
    F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN    RSS PSR STIME TTY          TIME CMD&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@ sbin]# ps -elHF | grep nginx | grep -v grep
1 S root      3473     1  0  80   0 -  1032 sigsus   480   2 10:15 ?        00:00:00   nginx: master process ./nginx
5 S nobody    3474  3473  0  80   0 -  1076 SyS_ep   828   0 10:15 ?        00:00:00     nginx: worker process
5 S nobody    3475  3473  0  80   0 -  1076 SyS_ep   828   1 10:15 ?        00:00:00     nginx: worker process
5 S nobody    3476  3473  0  80   0 -  1076 SyS_ep   828   2 10:15 ?        00:00:00     nginx: worker process
5 S nobody    3477  3473  0  80   0 -  1076 SyS_ep   828   3 10:15 ?        00:00:00     nginx: worker process
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者直接使用命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ps -eo pid,args,psr来查看那个每个进程所属CPU
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-o指定了ps的输出参数&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/05/nginx-per-cpu/&quot;&gt;nginx的多核绑定&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 05, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nginx负载均衡--加权轮询的实现]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/05/nginx-loadbalance-round-robin/" />
  <id>http://localhost:4000/2014/05/05/nginx-loadbalance-round-robin</id>
  <published>2014-05-05T00:00:00+00:00</published>
  <updated>2014-05-05T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;nginx根据每个工作进程的当前压力调整他们获取监听套接口的机率，那些当前比较空闲的工作进程有更多机会获取到监听套接口，从而当客户端的请求到达后也就相应的被他捕获并处理。这是客户端请求在多个Nginx进程之间的均衡。&lt;/p&gt;

&lt;p&gt;如果Nginx是以反向代理的形式配置运行，那么对于请求的实际处理需要转发到后端服务器进行，如果后端服务器有多台，如何选择一个合适的后端服务器来处理当前请求，这就是通常所说的负载均衡。&lt;/p&gt;

&lt;p&gt;可以看到这两个均衡是不相互冲突而且能同时生效。&lt;/p&gt;

&lt;p&gt;负载均衡是指将负载尽量均衡的分摊到多个不同的服务单元(比如多个后台服务器),以保证服务的可用和可靠性，提供给客户更好的用户体验。负载均衡的直接作用只有一个，尽量发挥多个服务单元的整体效能，实现1+1=2甚至大于2的效果。&lt;/p&gt;

&lt;p&gt;nginx提供的负载均衡策略主要包括:&lt;/p&gt;

&lt;h5&gt;加权轮询、weight、IP哈希、fair、一致哈希&lt;/h5&gt;

&lt;p&gt;其中fair和一致哈希都是第三方模块提供的，加权轮询、weight和IP哈希是Nginx内置的策略;&lt;/p&gt;

&lt;h4&gt;加权轮询(默认)&lt;/h4&gt;

&lt;p&gt;每个请求按照时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，则自动踢出这台服务器;默认每个权重都是1;&lt;/p&gt;

&lt;h4&gt;weight&lt;/h4&gt;

&lt;p&gt;与加权轮询配合使用，其实就是自己指定了轮询机率，weight和访问比率成正比，weight越大访问次数越多,用于后端服务器性能不均的情况;&lt;/p&gt;

&lt;h4&gt;ip_hash&lt;/h4&gt;

&lt;p&gt;每个请求按照ip的哈希结果分配，每个访客固定访问一个后端服务器&lt;/p&gt;

&lt;p&gt;Nginx默认采用的是加权轮询策略，如果要采用IP哈希策略，就必须在Nginx的配置文件中通过配置指令ip_hash明确指定(最好放在其他server指令之前，以便检查server的配置选项是否合理)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream backend{   
    ip_hash;
    server 192.168.8.1:8000; 
    server 192.168.8.2:9000;
}   



/*  通过执行不同的初始化函数，在后续实际负载时候采用的策略也就不同了    */
4651 static char *
4652 ngx_http_upstream_init_main_conf(ngx_conf_t *cf, void *conf)
4653 {
4665    ......
4666     for (i = 0; i &amp;lt; umcf-&amp;gt;upstreams.nelts; i++) {
4667 
4668         /* ngx_http_upstream_init_round_robin是加权轮询 */
4669         /* 如果用户没有做任何策略选择，那么负载均衡策略的初始化函数就是round_robin */
             /* 否则的话就执行对应的uscfp[i]-&amp;gt;peer.init_upstream指针函数 */
             /* 如果有配置ip_hash指令，则也就是行数ngx_http_upstream_init_ip_hash() */
4670         init = uscfp[i]-&amp;gt;peer.init_upstream ? uscfp[i]-&amp;gt;peer.init_upstream:
4671                                             ngx_http_upstream_init_round_robin;
4672    ......
4673 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;准备工作:&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;upstream backend {
    server  backend1.example.com    weight=5;
    server  127.0.0.1:8080  max_fails=3 fail_timeout=30s;
    server  UNIX:/temp/backend3 backup;
    server  192.168.0.1:9000 down;
}
指定的server可以是域名、ip或是UNIX域，他们代表不同的后端服务器

weigth:权重，默认是1,与加权轮询策略配合使用

max_fails与fail_timeout:他们需要配合使用，默认值分别是1和10s

具体的含义是:
如果某台服务器在fail_timeout时间内发生了max_fails次失败连接，那么该后端服务器在这fail_timeout时间内就不再残余被选择，直到fail_timeout时间后才重新加入从而有机会被再次选择，简单点就是先休息下，一会在工作。

backup:备机，平常不被选择，之后当其他所有非备机全部不可用(比如繁忙或宕机)时才会被使用。

down:主动标识其为宕机状态，不参与被选择
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;注意:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;backup选项不能用于ip_hash中，因为他会扰乱哈希的结果而违背ip_hash策略的初衷;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;某些参数只能和策略配合使用，如果发现某参数没有生效，则应该检测一下这一点，在配置解析过程中，这些选项设置都被转换为Nginx内部对应的变量值;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;path:/src/http/ngx_http_upstream.h&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;87 typedef struct {
88     ngx_addr_t                      *addrs;
89     ngx_uint_t                       naddrs;
90     ngx_uint_t                       weight;
91     ngx_uint_t                       max_fails;
92     time_t                           fail_timeout;
93 
94     unsigned                         down:1;
95     unsigned                         backup:1;
96 } ngx_http_upstream_server_t;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;addrs是一个数组指针，这是因为一个域名可以对应这多个IP地址;&lt;/p&gt;

&lt;p&gt;数组的元素由naddrs指定;&lt;/p&gt;

&lt;p&gt;域名解析中Nginx直接采用gethostbyname()阻塞函数获取，所以如果Nginx启动过程中发现卡住情况，可以检查下配置文件是否有配置域名并且系统当前的DNS解析是否正常。&lt;/p&gt;

&lt;p&gt;以下代码主要在/src/http/ngx_http_upstream_round_robin.h|c中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;17 typedef struct {
    /*  基本socket信息      */
18     struct sockaddr                *sockaddr;
19     socklen_t                       socklen;
20     ngx_str_t                       name;
21  /* 当前权重值和设定权重值 */
22     ngx_int_t                       current_weight;
23     ngx_int_t                       weight;
24  /* 失败次数和访问次数   */ 
25     ngx_uint_t                      fails;
    /*  失败访问时间，用于计算超时 */
26     time_t                          accessed;
27     time_t                          checked;
28  /*  失败次数上限和失败时间阀值 */
29     ngx_uint_t                      max_fails;
30     time_t                          fail_timeout;
31  /* 服务器是否被标记了down，标记了就不参与选择 */ 
32     ngx_uint_t                      down;          /* unsigned  down:1; */
33     
34 #if (NGX_HTTP_SSL)
35     ngx_ssl_session_t              *ssl_session;   /* local to a process */
36 #endif
37 } ngx_http_upstream_rr_peer_t;

current_weight和weight的主要区别是前者为权重排序的值，随着处理请求会动态变化，后面是配置文档中的值，用于恢复初始状态。

    /*  注意:与上面的不同，上面是peer_t，下面是peers_t*/
40 typedef struct ngx_http_upstream_rr_peers_s  ngx_http_upstream_rr_peers_t;
41     
42 struct ngx_http_upstream_rr_peers_s {
43     ngx_uint_t                      single;        /* unsigned  single:1; */
44     ngx_uint_t                      number;        /*  后台服务器的台数   */
45     ngx_uint_t                      last_cached;
46 
47  /* ngx_mutex_t                    *mutex; */
48     ngx_connection_t              **cached;
49     
50     ngx_str_t                      *name;
51 
52     ngx_http_upstream_rr_peers_t   *next;
53 
54     ngx_http_upstream_rr_peer_t     peer[1];
55 };
56 
57 
58 typedef struct {
59     ngx_http_upstream_rr_peers_t   *peers;
60     ngx_uint_t                      current;
61     uintptr_t                      *tried;
62     uintptr_t                       data;
63 } ngx_http_upstream_rr_peer_data_t;





加权轮询实现代码
598 static ngx_uint_t
599 ngx_http_upstream_get_peer(ngx_http_upstream_rr_peers_t *peers)
600 {
601     ngx_uint_t                    i, n, reset = 0;
602     ngx_http_upstream_rr_peer_t  *peer;
603 
604     peer = &amp;amp;peers-&amp;gt;peer[0];
605 
606     for ( ;; ) {
607         /*  i是后台机器的下标   */ 
608         for (i = 0; i &amp;lt; peers-&amp;gt;number; i++) {
609             /*  如果权重小于等于0,就跳过  */ 
610             if (peer[i].current_weight &amp;lt;= 0) {
611                 continue;            
612             }
613    
614             n = i;
615         
                /*  while查找当前权重最大的后端机器    */
616             while (i &amp;lt; peers-&amp;gt;number - 1) {
617 
618                 i++;
619 
620                 if (peer[i].current_weight &amp;lt;= 0) {
621                     continue;            
622                 }
623 
624                 if (peer[n].current_weight * 1000 / peer[i].current_weight
625                     &amp;gt; peer[n].weight * 1000 / peer[i].weight)
626                 {
627                     return n;            
628                 }
629 
630                 n = i;               
631             }
632             
                /*  如果while找到了current_weight&amp;gt;0的机器，则返回*/
633             if (peer[i].current_weight &amp;gt; 0) {
634                 n = i;
635             }
636 
637             return n;
638         }
639             
            /*  以下代码是恢复状态 */
640         if (reset++) {
641             return 0;
642         }
643         
            /*  peer[i].weigth是配置文件中手工设定的权重值    */
644         for (i = 0; i &amp;lt; peers-&amp;gt;number; i++) {
645             peer[i].current_weight = peer[i].weight;    
646         }
647     }
648 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ngx_http_upstream_init_round_robin()函数根据用户的配置执行不同的代码，用户配置有两种情况&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;第一种情况:

upstream backend {
    server 127.0.0.1:9001   backup;
    server 127.0.0.1:9000   weight=5;
    server 127.0.0.1:8000   max_fails=3 fail_timeout=30s;
    server 127.0.0.1:7000   max_fails=1 fail_timeout=10s;
}
    proxy_pass backend;

    对应代码if (us-&amp;gt;servers) {...}这一段

第二种情况:

    proxy_pass localhost:4000   #后面直接接后端服务器地址

    对应代码后半部分

/*  将配置解析后的结果转存到对应的变量  */
/*  创建后端服务器列表，将非后备服务器与后备服务器分开进行各自单独的列表    */
/*  每个后端服务器使用结构体ngx_http_upstream_rr_peer_t对应 */
/*  非后备服务器列表挂载在us-&amp;gt;ps.data字段下*/
/*  后备服务器列表挂载在非后备服务器列表head域中的next字段下*/

31 ngx_int_t
32 ngx_http_upstream_init_round_robin(ngx_conf_t *cf,
33     ngx_http_upstream_srv_conf_t *us)
34 {
35     ngx_url_t                      u;
36     ngx_uint_t                     i, j, n;
37     ngx_http_upstream_server_t    *server;
38     ngx_http_upstream_rr_peers_t  *peers, *backup;
39      /*  初始化操作 */ 
40     us-&amp;gt;peer.init = ngx_http_upstream_init_round_robin_peer;
41      /*  适用于情况一*/ 
42     if (us-&amp;gt;servers) {
43         server = us-&amp;gt;servers-&amp;gt;elts;
44 
45         n = 0;
46 
47         for (i = 0; i &amp;lt; us-&amp;gt;servers-&amp;gt;nelts; i++) {
48             if (server[i].backup) {  
49                 continue;
50             }
51 
52             n += server[i].naddrs;
53         }
54 
55         if (n == 0) {
56             ngx_log_error(NGX_LOG_EMERG, cf-&amp;gt;log, 0,
57                           &quot;no servers in upstream \&quot;%V\&quot; in %s:%ui&quot;,
58                           &amp;amp;us-&amp;gt;host, us-&amp;gt;file_name, us-&amp;gt;line);
59             return NGX_ERROR;
60         }
61       
62         peers = ngx_pcalloc(cf-&amp;gt;pool, sizeof(ngx_http_upstream_rr_peers_t)
63                               + sizeof(ngx_http_upstream_rr_peer_t) * (n - 1));
64         if (peers == NULL) {
65             return NGX_ERROR;
66         }
67          /*  如果只有一台服务器(非后备和后备服务器一共一台)则会对齐机型标识，
                这样在后续用户请求的时候更本无需在做选择，直接使用这一台即可*/
68         peers-&amp;gt;single = (n == 1);
69         peers-&amp;gt;number = n;
70         peers-&amp;gt;name = &amp;amp;us-&amp;gt;host;
71 
72         n = 0;
73          /*  将解析后的结果存储到对应的变量之中 */ 
74         for (i = 0; i &amp;lt; us-&amp;gt;servers-&amp;gt;nelts; i++) {
75             for (j = 0; j &amp;lt; server[i].naddrs; j++) {
76                 if (server[i].backup) {  
77                     continue;    /* 对与后备的服务器暂不操作 */
78                 }
79 
80                 peers-&amp;gt;peer[n].sockaddr = server[i].addrs[j].sockaddr;
81                 peers-&amp;gt;peer[n].socklen = server[i].addrs[j].socklen;
82                 peers-&amp;gt;peer[n].name = server[i].addrs[j].name;
83                 peers-&amp;gt;peer[n].max_fails = server[i].max_fails;
84                 peers-&amp;gt;peer[n].fail_timeout = server[i].fail_timeout;
85                 peers-&amp;gt;peer[n].down = server[i].down;
86                 peers-&amp;gt;peer[n].weight = server[i].down ? 0 : server[i].weight;
87                 peers-&amp;gt;peer[n].current_weight = peers-&amp;gt;peer[n].weight;
88                 n++;
89             }
90         }
91 
92         us-&amp;gt;peer.data = peers;   /*  peers是非后备服务器列表    */

93          /*  对peers列表中的服务器按照权重进行排序*/ 
94         ngx_sort(&amp;amp;peers-&amp;gt;peer[0], (size_t) n,
95                  sizeof(ngx_http_upstream_rr_peer_t),
96                  ngx_http_upstream_cmp_servers);
97 
98         /* backup servers */
99 
100         n = 0;
101 
102         for (i = 0; i &amp;lt; us-&amp;gt;servers-&amp;gt;nelts; i++) {
103             if (!server[i].backup) {
104                 continue;   /* 对非后备服务器不进行操作 */
105             }
106 
107             n += server[i].naddrs;
108         }
109 
110         if (n == 0) {
111             return NGX_OK;
112         }
113         /*  后备服务器的列表空间  */
114         backup = ngx_pcalloc(cf-&amp;gt;pool, sizeof(ngx_http_upstream_rr_peers_t)
115                               + sizeof(ngx_http_upstream_rr_peer_t) * (n - 1));
116         if (backup == NULL) {
117             return NGX_ERROR;
118         }
119         /*  why???  */
120         peers-&amp;gt;single = 0;
121         backup-&amp;gt;single = 0;
122         backup-&amp;gt;number = n;
123         backup-&amp;gt;name = &amp;amp;us-&amp;gt;host;
124 
125         n = 0;
126 
127         for (i = 0; i &amp;lt; us-&amp;gt;servers-&amp;gt;nelts; i++) {
128             for (j = 0; j &amp;lt; server[i].naddrs; j++) {
129                 if (!server[i].backup) {
130                     continue;   /* 跳过非后备服务器 */
131                 }
132 
133                 backup-&amp;gt;peer[n].sockaddr = server[i].addrs[j].sockaddr;
134                 backup-&amp;gt;peer[n].socklen = server[i].addrs[j].socklen;
135                 backup-&amp;gt;peer[n].name = server[i].addrs[j].name;
136                 backup-&amp;gt;peer[n].weight = server[i].weight;
137                 backup-&amp;gt;peer[n].current_weight = server[i].weight;
138                 backup-&amp;gt;peer[n].max_fails = server[i].max_fails;
139                 backup-&amp;gt;peer[n].fail_timeout = server[i].fail_timeout;
140                 backup-&amp;gt;peer[n].down = server[i].down;
141                 n++;
142             }
143         }
144 
145         peers-&amp;gt;next = backup;   /*  后备服务器 */
146         /* 对后备服务器进行权重排序  */
147         ngx_sort(&amp;amp;backup-&amp;gt;peer[0], (size_t) n,
148                  sizeof(ngx_http_upstream_rr_peer_t),
149                  ngx_http_upstream_cmp_servers);
150 
151         return NGX_OK;
152     }
153 
154 
155     /* an upstream implicitly defined by proxy_pass, etc. */
156     /*  实用于情况2，对于直接在proxy_pass等指令之后直接指定后端服务器地址的处理方式*/ 
157     if (us-&amp;gt;port == 0 &amp;amp;&amp;amp; us-&amp;gt;default_port == 0) {
158         ngx_log_error(NGX_LOG_EMERG, cf-&amp;gt;log, 0,
159                       &quot;no port in upstream \&quot;%V\&quot; in %s:%ui&quot;,
160                       &amp;amp;us-&amp;gt;host, us-&amp;gt;file_name, us-&amp;gt;line);
161         return NGX_ERROR;
162     }
163 
164     ngx_memzero(&amp;amp;u, sizeof(ngx_url_t));
165 
166     u.host = us-&amp;gt;host;
167     u.port = (in_port_t) (us-&amp;gt;port ? us-&amp;gt;port : us-&amp;gt;default_port);
168 
169     if (ngx_inet_resolve_host(cf-&amp;gt;pool, &amp;amp;u) != NGX_OK) {
170         if (u.err) {
171             ngx_log_error(NGX_LOG_EMERG, cf-&amp;gt;log, 0,
172                           &quot;%s in upstream \&quot;%V\&quot; in %s:%ui&quot;,
173                           u.err, &amp;amp;us-&amp;gt;host, us-&amp;gt;file_name, us-&amp;gt;line);
174         }
175 
176         return NGX_ERROR;
177     }
178 
179     n = u.naddrs;
180 
181     peers = ngx_pcalloc(cf-&amp;gt;pool, sizeof(ngx_http_upstream_rr_peers_t)
182                               + sizeof(ngx_http_upstream_rr_peer_t) * (n - 1));
183     if (peers == NULL) {
184         return NGX_ERROR;
185     }
186 
187     peers-&amp;gt;single = (n == 1);
188     peers-&amp;gt;number = n;
189     peers-&amp;gt;name = &amp;amp;us-&amp;gt;host;
190 
191     for (i = 0; i &amp;lt; u.naddrs; i++) {
192         peers-&amp;gt;peer[i].sockaddr = u.addrs[i].sockaddr;
193         peers-&amp;gt;peer[i].socklen = u.addrs[i].socklen;
194         peers-&amp;gt;peer[i].name = u.addrs[i].name;
195         peers-&amp;gt;peer[i].weight = 1;
196         peers-&amp;gt;peer[i].current_weight = 1;
197         peers-&amp;gt;peer[i].max_fails = 1;
198         peers-&amp;gt;peer[i].fail_timeout = 10;
199     }
200 
201     us-&amp;gt;peer.data = peers;
202 
203     /* implicitly defined upstream has no backup servers */
204 
205     return NGX_OK;
206 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/001.png&quot; alt=&quot;001&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当全局初始准备工作做好以后，当一个客户请求过来时候，Nginx就要选择适合的后端服务器来处理该请求，在正式开始选择前，Nginx还要单独为本轮选择做一些初始化，比如设置回调函数,回调函数是在每个请求选择后端服务器之前被调用。&lt;/p&gt;

&lt;h4&gt;注意:&lt;/h4&gt;

&lt;p&gt;针对一个客户端请求，Nginx会进行多次尝试，尝试全部失败才会返回502错误，所以要注意一轮选择与一次选择的区别。&lt;/p&gt;

&lt;h4&gt;选择后端服务器&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;/*  选择后端服务器   */
221 ngx_int_t
222 ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r,
223     ngx_http_upstream_srv_conf_t *us)
224 {
225     ngx_uint_t                         n;
226     ngx_http_upstream_rr_peer_data_t  *rrp;
227     
228     rrp = r-&amp;gt;upstream-&amp;gt;peer.data;
229 
230     if (rrp == NULL) {
231         rrp = ngx_palloc(r-&amp;gt;pool, sizeof(ngx_http_upstream_rr_peer_data_t));
232         if (rrp == NULL) {
233             return NGX_ERROR;
234         }
235 
236         r-&amp;gt;upstream-&amp;gt;peer.data = rrp;
237     }
238     
        /*  非后备服务器  */
239     rrp-&amp;gt;peers = us-&amp;gt;peer.data;
240     rrp-&amp;gt;current = 0;
241     
        /*  n要选择后备服务器和非后备服务器中数量较大的那一个   */
242     n = rrp-&amp;gt;peers-&amp;gt;number;
243 
244     if (rrp-&amp;gt;peers-&amp;gt;next &amp;amp;&amp;amp; rrp-&amp;gt;peers-&amp;gt;next-&amp;gt;number &amp;gt; n) {
245         n = rrp-&amp;gt;peers-&amp;gt;next-&amp;gt;number;
246     }
247 
248     if (n &amp;lt;= 8 * sizeof(uintptr_t)) {
249         rrp-&amp;gt;tried = &amp;amp;rrp-&amp;gt;data;
250         rrp-&amp;gt;data = 0;
251 
252     } else {
253         n = (n + (8 * sizeof(uintptr_t) - 1)) / (8 * sizeof(uintptr_t));
254 
255         rrp-&amp;gt;tried = ngx_pcalloc(r-&amp;gt;pool, n * sizeof(uintptr_t));
256         if (rrp-&amp;gt;tried == NULL) {
257             return NGX_ERROR;
258         }
259     }

260     /*  设置回调函数  */
261     r-&amp;gt;upstream-&amp;gt;peer.get = ngx_http_upstream_get_round_robin_peer; /*  对后端服务器进行一次选择    */ 
262     r-&amp;gt;upstream-&amp;gt;peer.free = ngx_http_upstream_free_round_robin_peer;
        /*  初始状态    */
263     r-&amp;gt;upstream-&amp;gt;peer.tries = rrp-&amp;gt;peers-&amp;gt;number;
264 #if (NGX_HTTP_SSL)
265     r-&amp;gt;upstream-&amp;gt;peer.set_session =
266                                ngx_http_upstream_set_round_robin_peer_session;
267     r-&amp;gt;upstream-&amp;gt;peer.save_session =
268                                ngx_http_upstream_save_round_robin_peer_session;
269 #endif
270 
271     return NGX_OK;
272 }
273 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;注意:&lt;/h4&gt;

&lt;p&gt;rrp-&gt;tried是一个位图，用来标识在一轮选择中多个后端服务器是否已经被选择过;&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;p&gt;假设有3台后端服务器，此时来了一个客户端请求，因此Nginx要针对该请求进行一轮选择，第一次选择了第一台服务器，结果后续连接失败，因此需要进行第二次选择，此时就不能在选择第一台服务器了，因为它已经被选择并尝试过了，所以只能选择第二台或第三台服务器，这个位图只是针对本轮选择，也就是如果又来了一个客户端请求，那么针对它的一轮选择对应的rrp-&gt;tried位图又是全新的，如果后端服务器个数少于一个nt类型变量可以表示的范围(32位就是32台)(因为要同时让非后备服务器和后备服务器两个列表都能使用，所以取两个列表中个数较大的那个值)，那么就直接使用已有的指针类型的data变量做位图即可，否则使用ngx_pcalloc函数申请对应的内存空间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*  对后端服务器进行一次选择    */
/*  关于前面的last_cached相关代码是未实现的陈旧代码，不用去管它 */
376 ngx_int_t
377 ngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc, void *data)
378 {
379     ngx_http_upstream_rr_peer_data_t  *rrp = data;
380 
381     time_t                         now;
382     uintptr_t                      m;
383     ngx_int_t                      rc;
384     ngx_uint_t                     i, n;
385     ngx_connection_t              *c;
386     ngx_http_upstream_rr_peer_t   *peer;
387     ngx_http_upstream_rr_peers_t  *peers;
388 
389     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc-&amp;gt;log, 0,
390                    &quot;get rr peer, try: %ui&quot;, pc-&amp;gt;tries);
391 
392     now = ngx_time();
393 
394     /* ngx_lock_mutex(rrp-&amp;gt;peers-&amp;gt;mutex); */
395 
396     /*  未实现的陈旧代码，不用去管他    */
397     if (rrp-&amp;gt;peers-&amp;gt;last_cached) {
398 
399         /* cached connection */
400         ...... 
415     }
416 
417     pc-&amp;gt;cached = 0;
418     pc-&amp;gt;connection = NULL;
419 
420     /*  判断是否只有一台后端服务器  */
421     if (rrp-&amp;gt;peers-&amp;gt;single) {
422         peer = &amp;amp;rrp-&amp;gt;peers-&amp;gt;peer[0];
423 
424     } else {
425 
426         /* there are several peers */
427     
            /*  判断是否是第一次选择,第一次选择的机器数量就是后端服务器的数量*/
            /*  表示在连接一个远端服务器时，当前连接出现异常失败后可以重试的次数，
                也就是允许的最多失败次数,第一次链接时候可以重试的次数就是主机数  */
428         if (pc-&amp;gt;tries == rrp-&amp;gt;peers-&amp;gt;number) {  /*  number是后端服务器的个数   */
429 
430             /* it&#39;s a first try - get a current peer */
431 
432             i = pc-&amp;gt;tries;
433 
434             for ( ;; ) {
                    /*  返回权值最大的服务器下标，rrp-&amp;gt;current是经过选择的后端服务器的下标   */
435                 rrp-&amp;gt;current = ngx_http_upstream_get_peer(rrp-&amp;gt;peers);  /*  get_peer是加权轮选的具体实现  */
436                 /*  
437                 ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc-&amp;gt;log, 0,
438                                &quot;get rr peer, current: %ui %i&quot;,
439                                rrp-&amp;gt;current,
440                                rrp-&amp;gt;peers-&amp;gt;peer[rrp-&amp;gt;current].current_weight);
441
                    /*  如果机器数大于了32,那么就返回的是该后端服务器在位图中的第几个int块中，小于32就返回0    */
442                 n = rrp-&amp;gt;current / (8 * sizeof(uintptr_t));

                    /*  m代表的是该后端服务器在位图中的第几位 */
443                 m = (uintptr_t) 1 &amp;lt;&amp;lt; rrp-&amp;gt;current % (8 * sizeof(uintptr_t));
444 
                    /*  对rrp-&amp;gt;tried的具体使用    */
                    /*  判断tried位图中该机器是否可用，如果tried[n]为0则表示可用   */
                    /*  位图标记过的就不要再去选择了，处于down机状态的也被排除 */
445                 if (!(rrp-&amp;gt;tried[n] &amp;amp; m)) {
446                     peer = &amp;amp;rrp-&amp;gt;peers-&amp;gt;peer[rrp-&amp;gt;current];
447                     
448                     if (!peer-&amp;gt;down) {      /*  非down */ 
449                             
                            /*  一段时间内的最大失败次数进行判断    */
450                         if (peer-&amp;gt;max_fails == 0
451                             || peer-&amp;gt;fails &amp;lt; peer-&amp;gt;max_fails)   /*  fails是已经失败的次数*/
452                         {
453                             break;  
454                         }
455 
456                         if (now - peer-&amp;gt;checked &amp;gt; peer-&amp;gt;fail_timeout) {
457                             peer-&amp;gt;checked = now;
458                             break;
459                         }
460                         
                            /*  有问题的服务器，将权重设为0，让他先休息一会    */
461                         peer-&amp;gt;current_weight = 0;
462 
463                     } else {    /*  down设置位图标记???   */
464                         rrp-&amp;gt;tried[n] |= m;     /*  设置位图标记  */
465                     }
466                     
                        /*  如果执行到这里说明没有执行break,表示检验不通过  */
                        /*  tries表示该连接失败，可以重试机器数-1            */
467                     pc-&amp;gt;tries--;    
468                 }
469                 
                    /*  如果没有可以重试的机器了则错误   */
470                 if (pc-&amp;gt;tries == 0) {
471                     goto failed;
472                 }
473 
474                 if (--i == 0) {
475                     ngx_log_error(NGX_LOG_ALERT, pc-&amp;gt;log, 0,
476                                   &quot;round robin upstream stuck on %ui tries&quot;,
477                                   pc-&amp;gt;tries);
478                     goto failed;
479                 }
480             }
481             /*  break直接跳出来，当前权重减一，时时改变    */ 
482             peer-&amp;gt;current_weight--;
483 
484         } else {
485 
                /*  非第一次进行选择,不是使用轮询，而是利用current进行遍历了    */
486             i = pc-&amp;gt;tries;
487 
488             for ( ;; ) {
                    /*rrp-&amp;gt;current此时是之前返回的权值最大的服务器下标+1(如果是第二次的话)*/
489                 n = rrp-&amp;gt;current / (8 * sizeof(uintptr_t));
490                 m = (uintptr_t) 1 &amp;lt;&amp;lt; rrp-&amp;gt;current % (8 * sizeof(uintptr_t));
491 
492                 if (!(rrp-&amp;gt;tried[n] &amp;amp; m)) {
493 
494                     peer = &amp;amp;rrp-&amp;gt;peers-&amp;gt;peer[rrp-&amp;gt;current];
495                     
                        /*  与上面的判断类似    */
496                     if (!peer-&amp;gt;down) {
497 
498                         if (peer-&amp;gt;max_fails == 0
499                             || peer-&amp;gt;fails &amp;lt; peer-&amp;gt;max_fails)
500                         {
501                             break;
502                         }
503 
504                         if (now - peer-&amp;gt;checked &amp;gt; peer-&amp;gt;fail_timeout) {
505                             peer-&amp;gt;checked = now;
506                             break;
507                         }
508 
509                         peer-&amp;gt;current_weight = 0;
510 
511                     } else {
512                         rrp-&amp;gt;tried[n] |= m;
513                     }
514 
515                     pc-&amp;gt;tries--;
516                 }
517 
518                 rrp-&amp;gt;current++;     /*  没有释放，所以要在这里自增 */
519 
                    /*  超过主机数量，就要从头开始 */
520                 if (rrp-&amp;gt;current &amp;gt;= rrp-&amp;gt;peers-&amp;gt;number) {
521                     rrp-&amp;gt;current = 0;
522                 }
523                 
                    /*  可以尝试的主机数为0    */
524                 if (pc-&amp;gt;tries == 0) {
525                     goto failed;
526                 }
527 
528                 if (--i == 0) {
529                     ngx_log_error(NGX_LOG_ALERT, pc-&amp;gt;log, 0,
530                                   &quot;round robin upstream stuck on %ui tries&quot;,
531                                   pc-&amp;gt;tries);
532                     goto failed;
533                 }
534             }
535             
                /*  权重值减少一  */
536             peer-&amp;gt;current_weight--;
537         }
538         /*  无论是第一次还是第二次，都要将选择了的进行标记   */ 
539         rrp-&amp;gt;tried[n] |= m;
540     }
541 
542     pc-&amp;gt;sockaddr = peer-&amp;gt;sockaddr;
543     pc-&amp;gt;socklen = peer-&amp;gt;socklen;
544     pc-&amp;gt;name = &amp;amp;peer-&amp;gt;name;
545 
546     /* ngx_unlock_mutex(rrp-&amp;gt;peers-&amp;gt;mutex); */
547 
548     if (pc-&amp;gt;tries == 1 &amp;amp;&amp;amp; rrp-&amp;gt;peers-&amp;gt;next) {
549         pc-&amp;gt;tries += rrp-&amp;gt;peers-&amp;gt;next-&amp;gt;number;
550 
551         n = rrp-&amp;gt;peers-&amp;gt;next-&amp;gt;number / (8 * sizeof(uintptr_t)) + 1;
552         for (i = 0; i &amp;lt; n; i++) {
553              rrp-&amp;gt;tried[i] = 0;
554         }
555     }
556 
557     return NGX_OK;
558 
    /*  使用后备服务器(如果有的话)对错误情况进行处理   */
559 failed:
560 
561     peers = rrp-&amp;gt;peers;
562     
        /*  如果非后备服务器都出错了，
            此时如果有后备服务器就切换到后备服务器
            如果连后备服务器都搞不定就返回NGX_BUSY   
        */
563     if (peers-&amp;gt;next) {
564 
565         /* ngx_unlock_mutex(peers-&amp;gt;mutex); */
566 
567         ngx_log_debug0(NGX_LOG_DEBUG_HTTP, pc-&amp;gt;log, 0, &quot;backup servers&quot;);
568 
569         rrp-&amp;gt;peers = peers-&amp;gt;next;
570         pc-&amp;gt;tries = rrp-&amp;gt;peers-&amp;gt;number;
571         
            /*  rrp-&amp;gt;peers-&amp;gt;number是后备服务器的数量   */
572         n = rrp-&amp;gt;peers-&amp;gt;number / (8 * sizeof(uintptr_t)) + 1;
573         for (i = 0; i &amp;lt; n; i++) {
574              rrp-&amp;gt;tried[i] = 0; /*  位图清0  */
575         }
576 
            /*  
                对后备服务器执行函数ngx_http_upstream_get_round_robin_peer
                对后备服务器进行相关非后备服务器的类似操作
                如果连后备服务器都失败则rc==NGX_BUSY
            */
577         rc = ngx_http_upstream_get_round_robin_peer(pc, rrp);
578              
579         if (rc != NGX_BUSY) {
580             return rc;
581         }
582 
583         /* ngx_lock_mutex(peers-&amp;gt;mutex); */
584     }
585 
586     /* all peers failed, mark them as live for quick recovery */
587 
588     for (i = 0; i &amp;lt; peers-&amp;gt;number; i++) {
589         peers-&amp;gt;peer[i].fails = 0;
590     }
591 
592     /* ngx_unlock_mutex(peers-&amp;gt;mutex); */
593 
594     pc-&amp;gt;name = peers-&amp;gt;name;
595 
596     return NGX_BUSY;
597 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;核心流程:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/002.png&quot; alt=&quot;002&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于只有一台后端服务器的情况，Nginx直接选择它并返回，如果有多台后端服务器，对于第一次选择，Nginx会循环调用函数ngx_http_upstream_get_peer()按照各台服务器的当前值进行选择，如果第一次选择的服务器因链接失败或是其他情况导致需要重新选择另外一台服务器，Nginx采用的就是简单的遍历，起始节点为rrp-&gt;current，但是这个值会在对第一次选择结果进行释放时自增1,也就是说起始节点和第一次选择节点并没有重复。&lt;/p&gt;

&lt;p&gt;图中没有给出对非后备服务器全部选择failed失败的情况，如果出现这种情况，则此时将尝试后备服务器，同样是对服务器列表进行选择，所以处理的情况与非后备服务器相似，只是将相关变量进行了切换,如果此时后备服务器也选择失败，那么函数将返回NGX_BUSY，这意味这没有后端服务器来处理该请求，Nginx将获得502错误，Nginx可以直接将这个错误发送到客户端，或者对它做替换处理。&lt;/p&gt;

&lt;h4&gt;后端服务器的权值计算&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;600 static ngx_uint_t
601 ngx_http_upstream_get_peer(ngx_http_upstream_rr_peers_t *peers)
602 {
603     ngx_uint_t                    i, n, reset = 0;
604     ngx_http_upstream_rr_peer_t  *peer;
605 
606     peer = &amp;amp;peers-&amp;gt;peer[0];
607 
608     for ( ;; ) {
609 
610         for (i = 0; i &amp;lt; peers-&amp;gt;number; i++) {
611             
                /*  已经休息的服务器不用计算    */
612             if (peer[i].current_weight &amp;lt;= 0) {
613                 continue;
614             }
615 
616             n = i;
617 
618             while (i &amp;lt; peers-&amp;gt;number - 1) {
619 
620                 i++;
621                 
                    /*  
                        如果都小于0,则都跳过了，此时i等于peers-&amp;gt;number-1，
                        在执行for中的i++，i变为peers-&amp;gt;number
                    */

622                 if (peer[i].current_weight &amp;lt;= 0) {
623                     continue;       
624                 }
625 
                    /*  权重的核心计算   
                        初始状态中peer[n].current_weight等于peer[n].weight
                        peer[i].current_weight等于peer[i].weight
                        乘以1000的目的是避免浮点运算，直接将除数放大1000倍，也就是间接的将精度提升到小数点后三位
                        由于是比较大小，所以同时提高1000倍不会影响结果。
                    */
626                 if (peer[n].current_weight * 1000 / peer[i].current_weight
627                     &amp;gt; peer[n].weight * 1000 / peer[i].weight)
628                 {
629                     return n;
630                 }
631 
632                 n = i;
633             }
634 
635             if (peer[i].current_weight &amp;gt; 0) {
636                 n = i;
637             }
638             /*  如果权值都小于0,此处不会被执行    */ 
639             return n;
640         }   /*  for结束   */
641
            /*  当所有权值都小于0的时候，将他们进行重置，重置为配置文件中的权值  */
642         if (reset++) {
643             return 0;
644         }
645         /*  重置权值    */ 
646         for (i = 0; i &amp;lt; peers-&amp;gt;number; i++) {
647             peer[i].current_weight = peer[i].weight;
648         }
649     }
650 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设有三台后端服务器A、B、C,他们的初始权值为5、3、1,则初始状态中peer[n].current_weight等于peer[n].weight并且peer[i].current_weight等于peer[i].weight，所以Nginx选择服务器C，不过随着后续current_weight权重的改变，各个服务器的权值将会发生变化，客户端的请求也会按照5:3:1的形式分布到A、B、C上，并且相对空闲的服务器会有更多机会被选中&lt;/p&gt;

&lt;h4&gt;释放后端服务器&lt;/h4&gt;

&lt;p&gt;分两种情况:&lt;/p&gt;

&lt;p&gt;1.连接后端服务器并且正常处理当前客户请求后释放后端服务器。这种的处理工作比较简单。&lt;/p&gt;

&lt;p&gt;2.在某一轮选择中，某次选择的服务器因连接失败或请求处理失败二需要重新进行选择。这就需要一些额外的处理了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;653 void
654 ngx_http_upstream_free_round_robin_peer(ngx_peer_connection_t *pc, void *data,
655     ngx_uint_t state)
656 {
657     ngx_http_upstream_rr_peer_data_t  *rrp = data;
658 
659     time_t                       now;
660     ngx_http_upstream_rr_peer_t  *peer;
661 
662     ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc-&amp;gt;log, 0,
663                    &quot;free rr peer %ui %ui&quot;, pc-&amp;gt;tries, state);
664
        /*  正常情况，直接返回了，对应情况1  */
665     if (state == 0 &amp;amp;&amp;amp; pc-&amp;gt;tries == 0) {
666         return;
667     }
668 
669     /* TODO: NGX_PEER_KEEPALIVE */
670 
671     if (rrp-&amp;gt;peers-&amp;gt;single) {
672         pc-&amp;gt;tries = 0;
673         return;
674     }
675 
676     peer = &amp;amp;rrp-&amp;gt;peers-&amp;gt;peer[rrp-&amp;gt;current];
677
        /*  一下都是对失败情况进行处理,对应情况2       */
678     if (state &amp;amp; NGX_PEER_FAILED) {
679         now = ngx_time();
680 
681         /* ngx_lock_mutex(rrp-&amp;gt;peers-&amp;gt;mutex); */
682 
683         peer-&amp;gt;fails++;              /*  已经失败的次数   */
684         peer-&amp;gt;accessed = now;
685         peer-&amp;gt;checked = now;
686         
            /*  设置了max_fails非0的话，默认就是1    */
688             peer-&amp;gt;current_weight -= peer-&amp;gt;weight / peer-&amp;gt;max_fails;
689         }
690 
691         ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc-&amp;gt;log, 0,
692                        &quot;free rr peer failed: %ui %i&quot;,
693                        rrp-&amp;gt;current, peer-&amp;gt;current_weight);
694         
            /*  权重&amp;lt;0也将它置0,让他去休息吧！ */
695         if (peer-&amp;gt;current_weight &amp;lt; 0) {
696             peer-&amp;gt;current_weight = 0;
697         }
698 
699         /* ngx_unlock_mutex(rrp-&amp;gt;peers-&amp;gt;mutex); */
700
701     } else {
702 
703         /* mark peer live if check passed */
704         /*  ???     */ 
705         if (peer-&amp;gt;accessed &amp;lt; peer-&amp;gt;checked) {
706             peer-&amp;gt;fails = 0;
707         }
708     }
709 
710     rrp-&amp;gt;current++; /*  自增1，current与第二次选择有关，可以看下第二次选择 */
711     
        /*  越界了，重新置为0,从头开始选择服务器   */
712     if (rrp-&amp;gt;current &amp;gt;= rrp-&amp;gt;peers-&amp;gt;number) {
713         rrp-&amp;gt;current = 0;
714     }
715     /*  可以尝试的次数又减少了   */ 
716     if (pc-&amp;gt;tries) {
717         pc-&amp;gt;tries--;
718     }
719 
720     /* ngx_unlock_mutex(rrp-&amp;gt;peers-&amp;gt;mutex); */
721 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果连接失败(不管是连接失败还是请求处理失败)，此时需要更新fails等变量;&lt;/p&gt;

&lt;p&gt;如果成功，则需要判断一个fail_timeout时间段已过，才能重置fails的值，如果不这样做，那么可能得到值两个错误&lt;/p&gt;

&lt;p&gt;要么将当前fail_timeout时间段内的失败次数统计错误，要么将当前fail_timeout时间段内的失败次数累加到下一个fail_timeout时间段。&lt;/p&gt;

&lt;p&gt;默认情况下。在一轮选择中，如果是链接错误或者是链接超时导致的失败，那么Nginx会尽量尝试每一台后端服务器进行请求处理，直到全部失败才会返回502错误。当然在配置文件中可以修改，例如proxy_next_upstream或是fastcgi_next_upstream.&lt;/p&gt;

&lt;p&gt;例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fastcgi_next_upstream http_404;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使得Nginx仅仅在上一台后端服务器返回404错误的情况下，才会尝试重新选择，否中直接返回对应的错误，500或是502。
也就是说只有返回的错误类型与指定的相同，才会尝试重新选择。&lt;/p&gt;

&lt;p&gt;这部分由ngx_http_upstream_next来实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2814 static void
2815 ngx_http_upstream_next(ngx_http_request_t *r, ngx_http_upstream_t *u,
2816     ngx_uint_t ft_type)
2817 {
                ......
                /*  全部尝试完毕了，或者是u-&amp;gt;conf-&amp;gt;next_upstream与配置文件中指定的类型不同  */
2883         if (u-&amp;gt;peer.tries == 0 || !(u-&amp;gt;conf-&amp;gt;next_upstream &amp;amp; ft_type)) {
2884    
                /*  最终的返回 */
2904             ngx_http_upstream_finalize_request(r, u, status);
2905             return;
2906         }
2907     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个加权轮询的大体流程图:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/003.png&quot; alt=&quot;003&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/05/nginx-loadbalance-round-robin/&quot;&gt;nginx负载均衡--加权轮询的实现&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 05, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nginx负载均衡--客户端请求的均衡与惊群问题]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/05/nginx-loadbalance-request/" />
  <id>http://localhost:4000/2014/05/05/nginx-loadbalance-request</id>
  <published>2014-05-05T00:00:00+00:00</published>
  <updated>2014-05-05T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;一般情况下，配置Nginx执行时候，工作进程会有多个，由于各个工作进程相互独立的接收客户端请求、处理、响应，所以就出现了负载不均衡的情况，比如极端的情况会是1个工作进程当前有3000个请求等待处理;而另一个进程当前也之后300个请求等待处理。&lt;/p&gt;

&lt;h4&gt;客户端请求均衡&lt;/h4&gt;

&lt;h5&gt;惊群问题&lt;/h5&gt;

&lt;p&gt;Nginx工作进程的主要任务就是处理事件，而事件的最初源头来自监听套接口，所以一旦末个工作进程独自拥有末个监听套接口，那么所有来自该监听套接口的客户端请求都将被这个工作线程处理。&lt;/p&gt;

&lt;p&gt;如果多个工作进程同时拥有某个监听套接字，那么一旦该监听套接字出现某客户端请求，此时就将引发所有拥有该监听套接字的工作进程去争抢这个请求，但是能够抢到的肯定只有某一个工作进程，而其他工作进程注定无功而返，这就是惊群现象。&lt;/p&gt;

&lt;p&gt;在高版本的Linux内核中已经解决了这个问题。&lt;/p&gt;

&lt;p&gt;Nginx中有一个ngx_use_accept_mutex的全局变量，这个变量可以说是Nginx均衡措施的根本所在，该变量是一个整形变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;54 ngx_uint_t            ngx_use_accept_mutex;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ngx_use_accept_mutex变量的赋值在ngx_event_process_init中，也就是每个工作进程开始时的初始化函数。&lt;/p&gt;

&lt;p&gt;调用关系如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ngx_worker_process_cycyle()---&amp;gt;ngx_worker_process_init()---&amp;gt;ngx_event_process_init()


584 ngx_event_process_init(ngx_cycle_t *cycle)
585 {
586     ngx_uint_t           m, i;
587     ngx_event_t         *rev, *wev;
588     ngx_listening_t     *ls;
589     ngx_connection_t    *c, *next, *old;
590     ngx_core_conf_t     *ccf;
591     ngx_event_conf_t    *ecf;
592     ngx_event_module_t  *module;
593 
594     ccf = (ngx_core_conf_t *) ngx_get_conf(cycle-&amp;gt;conf_ctx, ngx_core_module);
595     ecf = ngx_event_get_conf(cycle-&amp;gt;conf_ctx, ngx_event_core_module);
596 
597     if (ccf-&amp;gt;master &amp;amp;&amp;amp; ccf-&amp;gt;worker_processes &amp;gt; 1 &amp;amp;&amp;amp; ecf-&amp;gt;accept_mutex) {
598         ngx_use_accept_mutex = 1;
599         ngx_accept_mutex_held = 0;
600         ngx_accept_mutex_delay = ecf-&amp;gt;accept_mutex_delay;
601 
602     } else {
603         ngx_use_accept_mutex = 0;
604     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到(1)只有在多进程的模型下，并且(2)工作进程数大于1的情况下，(3)用户配置开启负载均衡的情况下,才会设置开启负载均衡。否则是不开启的(ngx_use_accept_mutex为0)&lt;/p&gt;

&lt;p&gt;对于ecf-&gt;accept_mutex主要是提供用户便利，可以让用户关闭该功能，因为难保某些情况下因为本身的消耗得不偿失。所以可以让用户关闭这个功能。&lt;/p&gt;

&lt;p&gt;这个字段默认为1,在初始化函数ngx_event_core_init_conf()内;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1252     ngx_conf_init_value(ecf-&amp;gt;multi_accept, 0);
1253     ngx_conf_init_value(ecf-&amp;gt;accept_mutex, 1); /*  将accept_mutex设置为1.  */
1254     ngx_conf_init_msec_value(ecf-&amp;gt;accept_mutex_delay, 500);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将ngx_use_accept_mutex值设置为1,也就开启了Nginx负载均衡策略，此时在每个工作进程的初始化函数ngx_event_process_init内，所有监听套接字都不会被加入到工作进程的事件监控机制里了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;826         rev-&amp;gt;handler = ngx_event_accept;
827         
            /*  如果开启了负载均衡，就跳过，不会将其加入到事件监控 */
828         if (ngx_use_accept_mutex) {
829             continue;
830         }
831 
832         if (ngx_event_flags &amp;amp; NGX_USE_RTSIG_EVENT) {
833             if (ngx_add_conn(c) == NGX_ERROR) {
834                 return NGX_ERROR;
835             }
836 
            /*  没有开启，就将其加入到事件监控中去 */
837         } else {
838             if (ngx_add_event(rev, NGX_READ_EVENT, 0) == NGX_ERROR) {
839                 return NGX_ERROR;
840             }
841         }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;真正将监听套接口加入到时间监控机制实在函数ngx_process_event_and_timers函数中.&lt;/p&gt;

&lt;p&gt;工作进程的主要一个执行体就是一个无限for循环，而该循环内最重要的调用就是ngx_process_event_and_timers。&lt;/p&gt;

&lt;p&gt;在该函数内动态的添加与删除监听套接口是一种很灵活的方式。&lt;/p&gt;

&lt;p&gt;如果当前的工作的负载均衡比较小，就将监听套接字加入到自身的事件监控机制中，从而带来新的客户端请求;&lt;/p&gt;

&lt;p&gt;如果当前工作进程负载比较大，就将套接字从自身的事件监控机制中删除，避免引入新的客户端请求而带来的更大的负载。&lt;/p&gt;

&lt;p&gt;当然，加入、删除需要锁机制来做互斥与同步，既要避免监听套接字同时被加入到多个进程的事件监控机制里，又要避免监听套接字在某一时刻没有任何进程监控。&lt;/p&gt;

&lt;h4&gt;负载均衡&lt;/h4&gt;

&lt;h5&gt;post事件处理机制&lt;/h5&gt;

&lt;p&gt;nginx设计了两个队列:ngx_posted_accept_events(存放新链接事件的队列)和ngx_posted_events队列(存放普通事件的队列)，这两个队列都是ngx_event_t类型的双链表。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;200 void
201 ngx_process_events_and_timers(ngx_cycle_t *cycle)
202 {
203     ngx_uint_t  flags;
204     ngx_msec_t  timer, delta;
205 
206     if (ngx_timer_resolution) {
207         timer = NGX_TIMER_INFINITE;
208         flags = 0;
209 
210     } else {
211         timer = ngx_event_find_timer();
212         flags = NGX_UPDATE_TIME;
213 
214 #if (NGX_THREADS)
215 
216         if (timer == NGX_TIMER_INFINITE || timer &amp;gt; 500) {
217             timer = 500;
218         }
219 
220 #endif
221     }
222     
        /*  负载均衡的真正实现 */
        /*  必须开启了才可以使用  */
223     if (ngx_use_accept_mutex) {
            /*  ngx_accept_disabled&amp;gt;0则处于过载状态  */
224         if (ngx_accept_disabled &amp;gt; 0) {
                /*  没有去抢那把锁，而是静静的去处理原来的负载，所以说自减1  */
225             ngx_accept_disabled--;
226 
            /*  否则便是没有过载    */
227         } else {
                /*  没有过载就努力去争取锁   */
228             if (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) {
229                 return;
230             }
231                 
                /*  争取失败，判断是否本来就拥有锁   */
                /*  如果当前拥有锁，那么就给flags加入标识NGX_POST_EVENTS,表示所有发生的事件都将咽喉处理  */
232             if (ngx_accept_mutex_held) {
233                 flags |= NGX_POST_EVENTS;
234 
235             } else {
236                 if (timer == NGX_TIMER_INFINITE
237                     || timer &amp;gt; ngx_accept_mutex_delay)
238                 {
239                     timer = ngx_accept_mutex_delay;
240                 }
241             }
242         }
243     }   // if end
244 
245     delta = ngx_current_msec;
246         
        /*  这个函数将所有的事件缓存了 */
247     (void) ngx_process_events(cycle, timer, flags);
248 
249     delta = ngx_current_msec - delta;
250 
251     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&amp;gt;log, 0,
252                    &quot;timer delta: %M&quot;, delta);
253 
        /*  
            如果其不为空链表，则处理新建链接的缓存事件
            ngx_epoll_process_events函数中对这个链表进行了缓存，使得其不为空
            先处理新建链接上的事件缓存，在处理其他的事件缓存

        */
254     if (ngx_posted_accept_events) {
255         ngx_event_process_posted(cycle, &amp;amp;ngx_posted_accept_events);
256     }
257 
        /*  处理完后就赶紧释放锁  */
258     if (ngx_accept_mutex_held) {
259         ngx_shmtx_unlock(&amp;amp;ngx_accept_mutex);
260     }
261 
262     if (delta) {
263         ngx_event_expire_timers();
264     }
265 
266     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&amp;gt;log, 0,
267                    &quot;posted events %p&quot;, ngx_posted_events);
268
        /*  处理原本延时的事件队列(如果有的话)  */
269     if (ngx_posted_events) {
270         if (ngx_threaded) {
271             ngx_wakeup_worker_thread(cycle);
272 
273         } else {
274             ngx_event_process_posted(cycle, &amp;amp;ngx_posted_events);
275         }
276     }
277 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ngx_accept_disabled的值的含义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;18 void
19 ngx_event_accept(ngx_event_t *ev)
20 {
107         ngx_accept_disabled = ngx_cycle-&amp;gt;connection_n / 8
108                               - ngx_cycle-&amp;gt;free_connection_n;
109 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中ngx_cycle-&gt;connection_n表示一个工作进程的最大可承受连接数，可以通过配置文件的work_connections指令配置，默认值是512,在函数ngx_event_core_init_conf()中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;13 #define DEFAULT_CONNECTIONS  512

1156 static char *
1157 ngx_event_core_init_conf(ngx_cycle_t *cycle, void *conf)
1158 {
        /*  默认初始化成512了    */
1244     ngx_conf_init_uint_value(ecf-&amp;gt;connections, DEFAULT_CONNECTIONS);
1245     cycle-&amp;gt;connection_n = ecf-&amp;gt;connections;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个ngx_cycle-&gt;free_connection_n表示当前可用连接数，假设当前活动连接数为x，那么该值为ngx_cycyle-&gt;connection_n - x;
所以此时ngx_accept_disabled的值为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ngx_accept_disabled = ngx_cycle-&amp;gt;connection_n/8 - (ngx_cycle-&amp;gt;connection_n - x)
                    = x - (ngx_cycle-&amp;gt;connection_n * 7/8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果ngx_accept_disabled &gt; 0表示过载，意思就是x - (ngx_cycle-&gt;connection_n * 7/8) &gt; 0，也就是说当前活动连接数(x)的值如果超过ngx_cycle-&gt;connection_n的7/8，则表示发生过载。变量ngx_accept_disabled将大于0,并且该值越大表示过载越大，当前进程负载越重。&lt;/p&gt;

&lt;p&gt;当工作进程的负载达到这个临界点的时候他就不会尝试去获取互斥锁，从而让新来的负载可以均衡到其他工作进程。&lt;/p&gt;

&lt;p&gt;可以看到只有在开启了负载均衡(ngx_use_accept_mutex=1)后才会生效。&lt;/p&gt;

&lt;p&gt;首先判断变量ngx_accept_disabled是否大于0来判断当前进程是否已经过载。为什么这样继续向下看;&lt;/p&gt;

&lt;p&gt;当处于过载状态的时候，所做的工作是使ngx_accept_disabled自减1,这表示既然经过了一轮处理，那么负载一定是减小的，所以要相应改变ngx_accept_disabled的值。&lt;/p&gt;

&lt;p&gt;经过一段时间ngx_accept_disabled将会降到0以下，便又可以去争取新的请求连接。
所以如下文所说的最大可承受连接数的7/8便是一个负载均衡点，当某进程的负载达到了这个临界点的时候它就不会去尝试获取互斥锁，从而让新增加的负载可以均衡到其他工作进程上去。&lt;/p&gt;

&lt;p&gt;如果进程并没有处理过载状态，那么就会去争锁，实际上争取的是套接字接口的监控权，争锁成功就会把所有监听套接字加入到自身的事件监控机制中(如果原本不在);&lt;/p&gt;

&lt;p&gt;如果争锁失败就会将所有监听套接字从自身的时间监控机制里删除(如果原本有的话),&lt;/p&gt;

&lt;p&gt;注意:是所有套接字，因为他们总是作为一个整体本加入或是删除&lt;/p&gt;

&lt;p&gt;NGX_POST_EVENTS标记表示所有发生的事件都将会延后处理,因为要尽快的释放锁。&lt;/p&gt;

&lt;h4&gt;任何架构设计都必须遵守的约定，就是持锁者必须尽量缩短自身持有锁的时间,所以发生的大部分事件都要延迟到释放锁之后再去处理，以便把锁尽快释放，缩短自身持有锁的时间可以让其他进程尽可能的有机会获取到锁。&lt;/h4&gt;

&lt;p&gt;如果当前进程没有获取到锁，那么就将监控机制阻塞点(例如epoll_wait)的超时时间限制在一个比较短的时间范围内，也就是ngx_accept_mutex_delay，默认是500毫秒.超时时间短了，所以超时更快，那么也就可以更频繁的从阻塞中跳出，也就有更多的机会去争取到锁了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;294 ngx_int_t
295 ngx_trylock_accept_mutex(ngx_cycle_t *cycle)
296 {
297     if (ngx_shmtx_trylock(&amp;amp;ngx_accept_mutex)) {
298 
299         ngx_log_debug0(NGX_LOG_DEBUG_EVENT, cycle-&amp;gt;log, 0,
300                        &quot;accept mutex locked&quot;);
301 
302         if (ngx_accept_mutex_held
303             &amp;amp;&amp;amp; ngx_accept_events == 0
304             &amp;amp;&amp;amp; !(ngx_event_flags &amp;amp; NGX_USE_RTSIG_EVENT))
305         {
306             return NGX_OK;
307         }
308 
309         if (ngx_enable_accept_events(cycle) == NGX_ERROR) {
310             ngx_shmtx_unlock(&amp;amp;ngx_accept_mutex);
311             return NGX_ERROR;
312         }
313 
314         ngx_accept_events = 0;
315         ngx_accept_mutex_held = 1;
316 
317         return NGX_OK;
318     }
319 
320     ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&amp;gt;log, 0,
321                    &quot;accept mutex lock failed: %ui&quot;, ngx_accept_mutex_held);
322 
323     if (ngx_accept_mutex_held) {
324         if (ngx_disable_accept_events(cycle) == NGX_ERROR) {
325             return NGX_ERROR;
326         }
327 
328         ngx_accept_mutex_held = 0;
329     }
330 
331     return NGX_OK;
332 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ngx_trylock_accept_mutex的内部流程
&lt;img src=&quot;/uploads/2014/05/006.png&quot; alt=&quot;006&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拥有锁的进程对时间的处理，也就是之前所说的延迟处理，当一个事件发生时候，一般处理(不做延迟的话)会立即调用事件对应的回调函数，而延迟处理则会将该时间以链表的形式缓存起来&lt;/p&gt;

&lt;p&gt;在函数ngx_process_events_and_timers中的ngx_process_events函数已经将所有事件都缓存了起来，接下来先处理新建链接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    static ngx_int_t
558 ngx_epoll_process_events(ngx_cycle_t *cycle, ngx_msec_t timer, ngx_uint_t flags)
559 {
            ......
                /*  如果标记了延迟处理，则执行事件缓存 */
672             if (flags &amp;amp; NGX_POST_EVENTS) {
673                 queue = (ngx_event_t **) (rev-&amp;gt;accept ?
674                                &amp;amp;ngx_posted_accept_events : &amp;amp;ngx_posted_events);
                        /*  
                                将其添加到ngx_posted_accept_events链表中
                                新建连接事件，就是监听套接字上发生的可读事件
                                在ngx_process_events_and_timers中的ngx_posted_accept_events就不为空了
                        */
675 
676                 ngx_locked_post_event(rev, queue);
677 
                /*  否则直接调用对应的回调函数 */
678             } else {
679                 rev-&amp;gt;handler(rev);
680             }
681         }
682 
683         wev = c-&amp;gt;write;
684 
685         if ((revents &amp;amp; EPOLLOUT) &amp;amp;&amp;amp; wev-&amp;gt;active) {
686 
687             if (c-&amp;gt;fd == -1 || wev-&amp;gt;instance != instance) {
688 
689                 /*
690                  * the stale event from a file descriptor
691                  * that was just closed in this iteration
692                  */
693 
694                 ngx_log_debug1(NGX_LOG_DEBUG_EVENT, cycle-&amp;gt;log, 0,
695                                &quot;epoll: stale event %p&quot;, c);
696                 continue;
697             }
698 
699             if (flags &amp;amp; NGX_POST_THREAD_EVENTS) {
700                 wev-&amp;gt;posted_ready = 1;
701 
702             } else {
703                 wev-&amp;gt;ready = 1;
704             }
705             /*  对于标记了的单独进行处理    */ 
706             if (flags &amp;amp; NGX_POST_EVENTS) {
707                 ngx_locked_post_event(wev, &amp;amp;ngx_posted_events);
708 
709             } else {
710                 wev-&amp;gt;handler(wev);
711             }
712         }
713     }
714 
715     ngx_mutex_unlock(ngx_posted_events_mutex);
716 
717     return NGX_OK;
718 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ngx_process_events_and_timers函数中先处理新建连接缓存事件链表ngx_posted_accept_events，此时还不能释放锁，因为我们还在处理监听套接字上的事情，还要读取上面的请求数据，所以此时必须独占，一旦缓存的新链接事件表被全部处理完了就必须马上释放现有的锁了，因为连接套接字只可能被某一个进程自始至终占用，不会出现进程之间的相互冲突，所以对于链接套接口上事件ngx_posted_events的处理可以在释放锁之后进行，虽然对于他们的具体处理与响应是非常消耗时间的，但是在此之前已经释放了持有的锁，所以即使是慢一点也不会影响到其他进程，最多客户感觉慢了一点吧！&lt;/p&gt;

&lt;h3&gt;注意:&lt;/h3&gt;

&lt;p&gt;1.如果在办理新建链接时间的过程中，在监听套接字上又来了新的请求的时候怎么办？&lt;/p&gt;

&lt;p&gt;当前进程只会处理已经缓存的事件，新的请求将会被阻塞在监听套接字中，由于监听套接字是以水平方式加入到时间监控机制中的，所以等到下一轮的被那个进程争取到锁并且加到时间监控机制里时候才会被触发从而被抓取出来。&lt;/p&gt;

&lt;p&gt;2.第259行ngx_shmtx_unlock(&amp;amp;ngx_accept_mutex)只是释放锁，而并没有将监听套接字从事件监控机制中删除，所以有可能在接下来处理ngx_posted_events缓存时间的过程中，互斥锁被另外一个进程争抢到并且把所有的监听套接字加入到他的事件监控机制里面，因此严格来说，在同一时刻，监听套接字可能被多个进程拥有，但是在同一时刻，监听套接字只可能被一个进程监控(也就是epoll_wait这种)，因此进程在处理完ngx_posted_events缓存事件后去争抢锁，发现锁被其他进程占用而争用失败，会把所有监听套接字从自身的事件监控机制里删除，然后才进行事件监控。但在同一时刻，监听套接字只能被一个进程监控，这也就意味着Nginx根本不会受到惊群问题的影响。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/05/nginx-loadbalance-request/&quot;&gt;nginx负载均衡--客户端请求的均衡与惊群问题&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 05, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nginx负载均衡--ip_hash的实现]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/05/nginx-loadbalance-ip_hash/" />
  <id>http://localhost:4000/2014/05/05/nginx-loadbalance-ip_hash</id>
  <published>2014-05-05T00:00:00+00:00</published>
  <updated>2014-05-05T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;根据IP的哈希值来获取对应的后端服务器，Nginx1.2.0仅支持IPv4&lt;/p&gt;

&lt;p&gt;加权轮询是Nginx负载均衡的基础策略，所以一些初始化工作，比如配置值转储(配置文件中相关值存储到变量中),所以其他策略可以直接复用加权轮询的初始化工作。&lt;/p&gt;

&lt;p&gt;path:src/http/modules/ngx_http_upstream_ip_hash_module.c&lt;/p&gt;

&lt;h4&gt;初始化工作&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;79 ngx_int_t
80 ngx_http_upstream_init_ip_hash(ngx_conf_t *cf, ngx_http_upstream_srv_conf_t *us)
81 {
        /*  直接使用round_robin的全局初始化   */
82     if (ngx_http_upstream_init_round_robin(cf, us) != NGX_OK) {
83         return NGX_ERROR;
84     }
85  
        /*  设定客户端请求到来时候的初始化函数 */
86     us-&amp;gt;peer.init = ngx_http_upstream_init_ip_hash_peer;
87 
88     return NGX_OK;
89 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第86行是针对单个请求进行初始化的回调函数指针，当一个客户请求过来时，就调用ngx_http_upstream_init_ip_hash_peer做初始化。&lt;/p&gt;

&lt;h4&gt;选择后端服务器&lt;/h4&gt;

&lt;p&gt;客户端请求到来后，函数ngx_http_upstream_ip_hash_module进行初始化，它调用了加权轮询策略的初始函数ngx_http_upstream_init_round_robin_peer，之所以这样是因为在多次哈希选择失败之后，&lt;em&gt;Nginx将会选择策略退化为加权轮询&lt;/em&gt;,针对IP哈希锁做的初始化工作主要是将对应的客户端IP转存出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;92 static ngx_int_t
93 ngx_http_upstream_init_ip_hash_peer(ngx_http_request_t *r,
94     ngx_http_upstream_srv_conf_t *us)
95 {
96     u_char                                 *p;
97     struct sockaddr_in                     *sin;
98     ngx_http_upstream_ip_hash_peer_data_t  *iphp;
99 
100     iphp = ngx_palloc(r-&amp;gt;pool, sizeof(ngx_http_upstream_ip_hash_peer_data_t));
101     if (iphp == NULL) {
102         return NGX_ERROR;
103     }
104 
105     r-&amp;gt;upstream-&amp;gt;peer.data = &amp;amp;iphp-&amp;gt;rrp;
106 
107     if (ngx_http_upstream_init_round_robin_peer(r, us) != NGX_OK) {
108         return NGX_ERROR;
109     }
110     
        /*  设置回调函数  */          /*  获取使用ip_hash策略   */
        /*  修改了原本在ngx_http_upstream_init_round_robin_peer函数中的值    */
111     r-&amp;gt;upstream-&amp;gt;peer.get = ngx_http_upstream_get_ip_hash_peer;
112 
113     /* AF_INET only */  /*  仅仅支持IPV4    */
114 
115     if (r-&amp;gt;connection-&amp;gt;sockaddr-&amp;gt;sa_family == AF_INET) {
116 
117         sin = (struct sockaddr_in *) r-&amp;gt;connection-&amp;gt;sockaddr;
118         p = (u_char *) &amp;amp;sin-&amp;gt;sin_addr.s_addr;

            /*  哈希方法仅仅需要ip地址的前三个字节即可    */
119         iphp-&amp;gt;addr[0] = p[0];
120         iphp-&amp;gt;addr[1] = p[1];
121         iphp-&amp;gt;addr[2] = p[2];
122 
123     } else {
            /*  IPV6的全部置为0,都分配到同一台机器了 */
124         iphp-&amp;gt;addr[0] = 0;
125         iphp-&amp;gt;addr[1] = 0;
126         iphp-&amp;gt;addr[2] = 0;
127     }
128 
        /*  哈希初始值 */
129     iphp-&amp;gt;hash = 89;
130     iphp-&amp;gt;tries = 0;
        /*  哈希失败20次以上就会退化成加权轮询模式，调用iphp-&amp;gt;get_rr_peer  */
131     iphp-&amp;gt;get_rr_peer = ngx_http_upstream_get_round_robin_peer;
132 
133     return NGX_OK;
134 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数ngx_http_upstream_get_ip_hash_peer的实现&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*  选择后端服务器   */
137 static ngx_int_t
138 ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc, void *data)
139 {
140     ngx_http_upstream_ip_hash_peer_data_t  *iphp = data;
141 
142     time_t                        now;
143     uintptr_t                     m; 
144     ngx_uint_t                    i, n, p, hash;
145     ngx_http_upstream_rr_peer_t  *peer;
146 
147     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, pc-&amp;gt;log, 0,
148                    &quot;get ip hash peer, try: %ui&quot;, pc-&amp;gt;tries);
149 
150     /* TODO: cached */
151     
        /*  哈希失败20次以上，或是单机模式    */
152     if (iphp-&amp;gt;tries &amp;gt; 20 || iphp-&amp;gt;rrp.peers-&amp;gt;single) {
            /*  退化为加权轮询   */
153         return iphp-&amp;gt;get_rr_peer(pc, &amp;amp;iphp-&amp;gt;rrp);
154     }
155 
156     now = ngx_time();
157 
158     pc-&amp;gt;cached = 0;
159     pc-&amp;gt;connection = NULL;
160 
        /*      iphp-&amp;gt;hash初始值为89，质数       */
161     hash = iphp-&amp;gt;hash;
162 
163     for ( ;; ) {
164 
            /*  一下是哈希的计算方法  */
            /*  只需要ip的前三个字节所以i &amp;lt; 3    */
165         for (i = 0; i &amp;lt; 3; i++) {
166             hash = (hash * 113 + iphp-&amp;gt;addr[i]) % 6271;
167         }
168 
            /*  p就是最后的哈希值，得到的p一定小于机器数量  */
169         p = hash % iphp-&amp;gt;rrp.peers-&amp;gt;number;
170             
            /*  检测p机器在位图中是否被使用过了  */
171         n = p / (8 * sizeof(uintptr_t));
172         m = (uintptr_t) 1 &amp;lt;&amp;lt; p % (8 * sizeof(uintptr_t));
173 
            /*  对应的位为0表示没有使用过   */
174         if (!(iphp-&amp;gt;rrp.tried[n] &amp;amp; m)) {
175 
176             ngx_log_debug2(NGX_LOG_DEBUG_HTTP, pc-&amp;gt;log, 0,
177                            &quot;get ip hash peer, hash: %ui %04XA&quot;, p, m);
178 
179             peer = &amp;amp;iphp-&amp;gt;rrp.peers-&amp;gt;peer[p];
180 
181             /* ngx_lock_mutex(iphp-&amp;gt;rrp.peers-&amp;gt;mutex); */
182             
                /*  如果机器可用，break便会跳出执行代码207行代码  */
183             if (!peer-&amp;gt;down) {
184 
185                 if (peer-&amp;gt;max_fails == 0 || peer-&amp;gt;fails &amp;lt; peer-&amp;gt;max_fails) {
186                     break;
187                 }
188 
189                 if (now - peer-&amp;gt;checked &amp;gt; peer-&amp;gt;fail_timeout) {
190                     peer-&amp;gt;checked = now;
191                     break;
192                 }
193             }
194 
195             iphp-&amp;gt;rrp.tried[n] |= m;
196 
197             /* ngx_unlock_mutex(iphp-&amp;gt;rrp.peers-&amp;gt;mutex); */
198 
199             pc-&amp;gt;tries--;
200         }
201         
            /*  失败了20次机上就退化   */
202         if (++iphp-&amp;gt;tries &amp;gt;= 20) {
203             return iphp-&amp;gt;get_rr_peer(pc, &amp;amp;iphp-&amp;gt;rrp);
204         }
205     }
206 
207     iphp-&amp;gt;rrp.current = p;
208 
209     pc-&amp;gt;sockaddr = peer-&amp;gt;sockaddr;
210     pc-&amp;gt;socklen = peer-&amp;gt;socklen;
211     pc-&amp;gt;name = &amp;amp;peer-&amp;gt;name;
212 
213     /* ngx_unlock_mutex(iphp-&amp;gt;rrp.peers-&amp;gt;mutex); */
214 
215     iphp-&amp;gt;rrp.tried[n] |= m;
216     iphp-&amp;gt;hash = hash;
217 
218     return NGX_OK;
219 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;哈希的计算很简单，就是通常的哈希规则，也就是相关数值，比如3、89、113、6271都是质数，这样使得哈希结果更加散列;&lt;/p&gt;

&lt;p&gt;根据哈希值得到被选中的后端服务器，判断其是否可用，如果可用则break跳出，执行207行代码，否则将可重试次数减少1,再在上次哈希结果hash的基础上再进行哈希(就是那个for死循环的作用)！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/2014/05/005.png&quot; alt=&quot;005&quot; /&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/05/nginx-loadbalance-ip_hash/&quot;&gt;nginx负载均衡--ip_hash的实现&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 05, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[nginx负载均衡两种策略的比较]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/2014/05/05/nginx-loadbalance-compare/" />
  <id>http://localhost:4000/2014/05/05/nginx-loadbalance-compare</id>
  <published>2014-05-05T00:00:00+00:00</published>
  <updated>2014-05-05T00:00:00+00:00</updated>
  <author>
    <name>Neo</name>
    <uri>http://localhost:4000</uri>
    <email>ucshell.neo@gmail.com</email>
  </author>
  <content type="html">&lt;h4&gt;加权轮询&lt;/h4&gt;

&lt;h5&gt;优势:&lt;/h5&gt;

&lt;p&gt;加权轮询的适用性更强，它不依赖于客户端的任何信息，而完全依靠后端服务器的情况进行选择;
能把客户端的请求更合理更均匀的分配到各个后端服务器处理;&lt;/p&gt;

&lt;h5&gt;劣势:&lt;/h5&gt;

&lt;p&gt;同一个客户端的多次请求可能会被分配到不同的后端服务器进行处理，所以无法满足做会话保持的应用的需求。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4&gt;IP哈希&lt;/h4&gt;

&lt;h5&gt;优势:&lt;/h5&gt;

&lt;p&gt;能较好的将同一个客户的多次请求分配到同一后台服务器处理，避免了加权轮询策略无法使用会话保持的需求。&lt;/p&gt;

&lt;h5&gt;劣势:&lt;/h5&gt;

&lt;p&gt;IP哈希是根据客户端的IP地址来对后端服务器选择，如果某个时刻，来自某个IP的请求特别多，那么将导致谋台后端服务器的压力非常大，而其他后端服务器却还是很空闲的不均匀情况。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/05/05/nginx-loadbalance-compare/&quot;&gt;nginx负载均衡两种策略的比较&lt;/a&gt; was originally published by Neo at &lt;a href=&quot;http://localhost:4000&quot;&gt;高手之路&lt;/a&gt; on May 05, 2014.&lt;/p&gt;</content>
</entry>

</feed>
