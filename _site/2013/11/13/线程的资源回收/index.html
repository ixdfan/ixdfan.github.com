<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>线程的资源回收 &#8211; 高手之路</title>
<meta name="description" content="">
<meta name="keywords" content="线程">


<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="线程的资源回收">
<meta property="og:description" content="专注于linux下程序设计">
<meta property="og:url" content="http://localhost:4000/2013/11/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6/">
<meta property="og:site_name" content="高手之路">





<link rel="canonical" href="http://localhost:4000/2013/11/13/%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="高手之路 Feed">
<link rel="author" href="https://plus.google.com/ucshell.neo@gmail.com?rel=author">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Google Webfonts -->
<link href='http://fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700|PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.min.css">

<meta http-equiv="cleartype" content="on">

<!-- HTML5 Shiv and Media Query Support -->
<!--[if lt IE 9]>
	<script src="http://localhost:4000/assets/js/vendor/html5shiv.min.js"></script>
	<script src="http://localhost:4000/assets/js/vendor/respond.min.js"></script>
<![endif]-->

<!-- Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="post">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="http://localhost:4000">高手之路</a>
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" id="site-nav" class="nav">
		    <ul>
		        
				<li><a href="http://localhost:4000" >Home</a></li>
		        
				<li><a href="http://localhost:4000/posts/" >Posts</a></li>
		        
				<li><a href="http://localhost:4000/about/" >About</a></li>
		        
				<li><a href="http://localhost:4000/comment/" >Leave a message</a></li>
		        
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->



<div id="main" role="main">
  <div class="article-author-side">
    <img src="http://localhost:4000/images/Neo.jpg" class="bio-photo" alt="Neo bio photo"></a>
<h3>Neo</h3>
<p>每一个优秀的人,都会有一段沉默的时光. 那一段时光,是付出了很多努力,忍受孤独和寂寞,不抱怨不诉苦. 日后说起时,连自己都能被感动的日子.</p>


<a href="https://plus.google.com/ucshell.neo@gmail.com" class="author-social" target="_blank"><i class="icon-google-plus"></i> Google+</a>










  </div>
  <article>
    <div class="headline-wrap">
      <h1>线程的资源回收</h1>
    </div><!--/ .headline-wrap -->
    <div class="article-wrap">
      <p>线程的分离状态</p>

<p>由于线程和进程一样，在内核中拥有进程控制结构存储线程结束状态之类的信息，所以系统中同样会出现僵尸线程，不过当进程结束时，这种僵尸线程就会随着进程的消失而消失，所以影响不是很严重，如果想避免僵尸线程，则应将线程设置为结束状态分离，这是线程的结束状态将不能再被进程中的其他线程得到，同时保持线程结束状态信息的存储区域也将变得不可用</p>

<p><strong>在创建线程的时候，可以指定线程的结束状态和线程分离。</strong></p>

<p>实例：</p>

<pre><code>void* tfn1(void* arg)
{
        printf("the thread\n");
        return NULL;
}

int main()
{
        int err;
        pthread_t tid;
        pthread_attr_t attr;

    //初始化线程属性
        err = pthread_attr_init(&amp;attr);
        if(0 != err){
                printf("can't init attr %s\n", strerror(err));
                exit(1);
        }

    //将线程属性设置为线程结束状态信息分离
        err = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);
        if(0 != err){
                printf("can't set attr %s\n", strerror(err));
                exit(1);
        }

        err = pthread_create(&amp;tid, &amp;attr, tfn1, NULL);
        if(0 != err){
                printf("can't create thread %s\n", strerror(err));
                exit(1);
        }
    //由于线程是分离状态，所以不能够得到该线程的结束状态信息，pthread_join将会出错
        err = pthread_join(tid, NULL);
        if(0 != err){
                printf("thread has been detached\n");
        }
        return 0;
}
</code></pre>

<p>**分离一个已经创建的线程</p>

<p>**在创建一个线程时，可以通过设置创建线程属性的方法将一个线程设置为状态分离，但是如果需要将一个已经创建的线程设置为状态分离时，可以使用Linux系统的支持。该系统支持将一个已经运行线程设置为状态分离。</p>

<p>Linux中使用pthread_detach函数使一个已经创建的线程进入分离状态。</p>

<p><strong>pthread_detach() 函数用于指示应用程序在线程 tid 终止时回收其存储空间。如果 tid 尚未终止，pthread_detach() 不会终止该线程。</strong></p>

<pre><code>int pthread_detach(pthread_t thread);
</code></pre>

<p>pthread_detach的参数就是要分离的线程ID</p>

<pre><code>void* tfn1(void* arg)
{
        printf("1the thread\n");
        sleep(2);
        printf("2the thread done\n");
        return NULL;
}

int main()
{
        int err;
        pthread_t tid;

        err = pthread_create(&amp;tid, NULL, tfn1, NULL);
        if(0 != err){
                printf("can't create thread %s\n", strerror(err));
                exit(1);
        }

        err = pthread_detach(tid);
        if(0 != err){
                printf("can't detach thread %s\n", strerror(err));
                exit(1);
        }

        err = pthread_join(tid, NULL);
        if(0 != err){
                printf("thread has been detached\n");
        }
        sleep(5);
        printf("the main thread done\n");
        return 0;
}




[root@localhost 06]# cc detach.c -lpthread -omain
[root@localhost 06]# ./main
thread has been detached
1the thread
2the thread done
the main thread done
</code></pre>

<h5>注意：</h5>

<p>如果main函数中不使用sleep(5）休眠5秒，则看不到2the thread done，因为主线程结束了该线程，线程直接退出</p>

<p>分离状态的线程会导致pthread_join函数出错，所以主线程不能依靠该函数来等待线程执行完毕，而必须使用sleep休眠来等待线程执行完毕</p>

<p>线程创建的时候<strong>默认处于joinable状态</strong>，<strong>joinable状态线程结束的时候不会自动回收线程资源，需要pthread_join函数来回收；</strong>
pthread_detach可以将线程转换为detached状态，子线程运行完成之后可以自行回收资源。
一般情况下，进程中各个线程的运行都是相互独立的，线程的终止并不会通知，也不会影响其他线程，终止的线程所占用的资源也并不会随着线程的终止而得到释放。
正如进程之间可以用wait()系统调用来同步终止并释放资源一样，线程之间也有类似机制，那就是pthread_join()函数。</p>

<pre><code>void pthread_exit(void *retval) 
int pthread_join(pthread_t th, void **thread_return)
int pthread_detach(pthread_t th)
</code></pre>

<p>pthread_join()的调用者将挂起并等待th线程终止，retval是pthread_exit()调用者线程（线程ID为th）的返回值，如果thread_return不为NULL，则*thread_return=retval。</p>

<h5>注意：</h5>

<p><strong>一个线程仅允许唯一的一个线程使用pthread_join()等待它的终止</strong>，并且被等待的线程应该处于可join状态，即非DETACHED状态。</p>

<p>如果进程中的某个线程执行了pthread_detach(th)，则th线程将处于DETACHED状态，这使得th线程在结束运行时自行释放所占用的内存资源，同时也无法由pthread_join()同步，pthread_detach()执行之后，对th请求pthread_join()将返回错误。</p>

<h5>注意：</h5>

<p><strong>joinable线程所占用的内存仅当有线程对其执行了pthread_join()后才会释放</strong>，因此为了<strong>避免内存泄漏</strong>，所有线程的终止，要么已设为DETACHED，要么就需要使用pthread_join()来回收。</p>

<pre><code>int pthread_join(pthread_t tid, void **status);
</code></pre>

<p>tid 是希望等待的线程的线程号，status 是指向线程返回值的指针，线程的返回值就是pthread_exit 中的value_ptr 参数，或者是return语句中的返回值。该函数可用于线程间的同步</p>

<pre><code>int pthread_detach( pthread_t pid );
</code></pre>

<p>tid 是希望等待的线程的线程号, 把指定的线程转变为分离状态</p>

<p>一个线程是可汇合的（joinable，缺省值）或者是分离的（detached）。</p>

<p><strong>joinable线程终止时，它的线程ID和退出状态将留到另一个线程对它调用pthread_join。</strong></p>

<p>分离线程却象守护进程：当它们终止的时，所有相关资源都被释放，我们不能等待它们终止。</p>

<p>如果一个线程需要知道另一个线程什么时候终止，那就最好将第二个线程设置为joinable状态。</p>

<p>实例:</p>

<pre><code>#define THREAD_NUMBER 2
int     retval_hello1= 1,
        retval_hello2 = 2;

void* hello1(void *arg)
{
        char* hello_str = (char *)arg;

        sleep(2);

        printf("%s\n", hello_str);

        pthread_exit(&amp;retval_hello1);
}

void* hello2(void *arg)
{
        char* hello_str = (char *)arg;

        sleep(1);

        printf("%s\n", hello_str);

        pthread_exit(&amp;retval_hello2);
}

int main(int argc, char *argv[])
{
        int     i;
        int     ret_val;
        int*    retval_hello[2];

        pthread_t pth[THREAD_NUMBER];

        const char* arg[THREAD_NUMBER];

        arg[0] = "hello world from thread1";
        arg[1] = "hello world from thread2";

        printf("Begin to create threads...\n");

        ret_val = pthread_create(&amp;pth[0], NULL, hello1, (void *)arg[0]);
        if (ret_val != 0 ) {

                printf("pthread_create error!\n");
                exit(1);
        }

        ret_val = pthread_create(&amp;pth[1], NULL, hello2, (void *)arg[1]);
        if (ret_val != 0 ) {

                printf("pthread_create error!\n");
                exit(1);
        }

        printf("Begin to wait for threads...\n");

        for(i = 0; i &lt; THREAD_NUMBER; i++) {
                ret_val = pthread_join(pth[i], (void **)&amp;retval_hello[i]);

                if (ret_val != 0) {

                        printf("pthread_join error!\n");
                        exit(1);
                } else {

                        printf("return value is %d\n", *retval_hello[i]);
                }
        }

        printf("Now, the main thread returns.\n");
        return 0;
}

执行结果为：




[root@localhost 07]# ./main
Begin to create threads...
Begin to wait for threads...
hello world from thread2
hello world from thread1
return value is 1
return value is 2
Now, the main thread returns.
</code></pre>

<p>线程1，2的执行顺序可以通过sleep来调节，但是主线程必须在子线程完成之后才能执行，即打印Now, the main thread returns.。</p>

<p>因为<strong>调用pthread_join()的顺序</strong>，必定是线程1先执行“return value is xx”，不管线程2是否先执行完。</p>

<p>实例：</p>

<pre><code>#define THREAD_NUMBER 2
int     retval_hello1= 1,
        retval_hello2 = 2;

void* hello1(void *arg)
{
        char* hello_str = (char *)arg;

        sleep(2);

        printf("%s\n", hello_str);

        pthread_exit(&amp;retval_hello1);
}

void* hello2(void *arg)
{
        char* hello_str = (char *)arg;

        sleep(1);

        printf("%s\n", hello_str);

        pthread_exit(&amp;retval_hello2);
}

int main(int argc, char *argv[])
{
        int     i;
        int     ret_val;
        int*    retval_hello[2];

        pthread_t pth[THREAD_NUMBER];

        const char* arg[THREAD_NUMBER];

        arg[0] = "hello world from thread1";
        arg[1] = "hello world from thread2";

        printf("Begin to create threads...\n");

        ret_val = pthread_create(&amp;pth[0], NULL, hello1, (void *)arg[0]);
        if (ret_val != 0 ) {

                printf("pthread_create error!\n");
                exit(1);
        }

        ret_val = pthread_create(&amp;pth[1], NULL, hello2, (void *)arg[1]);
        if (ret_val != 0 ) {

                printf("pthread_create error!\n");
                exit(1);
        }

        printf("Begin to wait for threads...\n");

        for(i = 0; i &lt; THREAD_NUMBER; i++) {
        ret_val = pthread_detach(pth[i]);

                if (ret_val != 0) {

                        printf("pthread_detach error!\n");
                        exit(1);
                } else {
                        printf("return value is %d\n", *retval_hello[i]);
                }
        }

        printf("Now, the main thread returns.\n");
        return 0;
}

执行结果为

[root@localhost 07]# ./main
Begin to create threads...
Begin to wait for threads...
return value is 1474660693
return value is -1990267599
Now, the main thread returns.
</code></pre>

<p>线程1，2没有执行（也可能执行），因为子线程为可分离的，主线程在执行完之后即将进程销毁，资源收回，导致子线程未运行。</p>

<p>可以在return 0 语句之前加入sleep(5)，这样执行结果为</p>

<pre><code>[root@localhost 07]# ./main
Begin to create threads...
Begin to wait for threads...
return value is 1474660693
return value is -1990267599
Now, the main thread returns.
hello world from thread2
hello world from thread1
</code></pre>

<p>注意：</p>

<p><strong>pthread_join()会挂起父线程，直至子线程完成才可以执行后面的代码；</strong></p>

<p><strong>PTHREAD_CREATE_JOINABLE状态的子线程不会自动释放该线程的内存资源，包括线程描述符和其使用的栈；</strong></p>

<p><strong>主线程调用pthread_detach()时，无需等待子线程的完成，它可以立即执行后面的代码</strong>，也有可能主线程执行完之后销毁进程，导致子线程未能执行，此外，一个PTHREAD_CREATE_DETACH状态的子线程拥有自我回收内存资源的功能。</p>

<p>线程处于两种状态下，退出时（也就是调用pthread_exit()函数）,对资源的释放情况。</p>

<p>通过查看线程号，判断线程退出时，是否释放了资源</p>

<pre><code>void *print_msg_fun(void *ptr)
{
    //pthread_detach(pthread_self());
    /*保留此句表示线程处于分离, 注释掉表示线程处于非分离*/
        /*注意pthread_t的类型为unsigned long 所以打印时候要使用%lu否则打印结果是错误的*/
        printf("%lu\n",pthread_self());
    pthread_exit(NULL);
}

int main()
{
        pthread_t th;

        while(1)
        {
                if( 0 != (pthread_create(&amp;th,NULL,print_msg_fun,NULL))){
                        perror("create th1");
                        return;
                }
                sleep(3);
                printf("%d\n",th);
        }

        return 0;
}
</code></pre>

<p>通常是主线程使用pthread_create()创建子线程以后，一般可以调用pthread_detach(threadid)分离刚刚创建的子线程，这里的threadid是指子线程的threadid；该子线程终止时底层资源立即被回收；</p>

<p>被创建的子线程也可以自己分离自己，子线程调用pthread_detach(pthread_self())就是分离自己，因为pthread_self()这个函数返回的就是自己本身的线程ID；</p>

<h5>注意：</h5>

<p>一个可<strong>join的线程所占用的内存仅当有线程对其执行了pthread_join()后才会释放</strong>，因此为了避免内存泄漏，所有线程的终止，要么已设为DETACHED，要么就需要使用pthread_join()来回收。</p>

<p>函数调用<strong>pthread_join解决的是线程资源释放的问题</strong>，但是这个时候每次调用子进程都是要等待线程结束才能继续运行的。</p>

<p><strong>pthread_join是一个线程阻塞的函数，调用它的函数将一直等待到被等待的线程结束为止，当函数返回时，被等待线程的资源被收回。</strong></p>

<p>建议使用设置线程属性的方法来实现资源回收：PTHREAD_CREATE_DETACHED</p>

      <hr />
      <footer role="contentinfo">
        <div class="article-author-bottom">
          <img src="http://localhost:4000/images/Neo.jpg" class="bio-photo" alt="Neo bio photo"></a>
<h3>Neo</h3>
<p>每一个优秀的人,都会有一段沉默的时光. 那一段时光,是付出了很多努力,忍受孤独和寂寞,不抱怨不诉苦. 日后说起时,连自己都能被感动的日子.</p>


<a href="https://plus.google.com/ucshell.neo@gmail.com" class="author-social" target="_blank"><i class="icon-google-plus"></i> Google+</a>










        </div>
        <p class="byline"><strong>线程的资源回收</strong> was published on <time datetime="2013-11-13T01:17:51Z">November 13, 2013</time> by <a href="http://localhost:4000/about" title="About Neo">Neo</a>.</p>
      </footer>
    </div><!-- /.article-wrap -->
  </article>
</div><!-- /#main -->

<div class="footer-wrap">
  <div class="related-articles">
  <h4>You might also enjoy <small class="pull-right">(<a href="http://localhost:4000/posts/">View all posts</a>)</small></h4>
    <ul>
    
      <li><a href="http://localhost:4000/2014/05/05/nginx-per-cpu/" title="nginx的多核绑定">nginx的多核绑定</a></li>
    
      <li><a href="http://localhost:4000/2014/05/05/nginx-loadbalance-round-robin/" title="nginx的负载均衡--加权轮询的实现">nginx的负载均衡--加权轮询的实现</a></li>
    
      <li><a href="http://localhost:4000/2014/05/05/nginx-loadbalance-request/" title="Nginx负载均衡--客户端请求的均衡与惊群问题">Nginx负载均衡--客户端请求的均衡与惊群问题</a></li>
    
    </ul>
    <hr />
        <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'ucshellcom'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
  </div><!-- /.related-articles -->
  <footer>
    <br></br>
<br></br>
<span>&copy; 2013 - 2014 高手之路 ucshell.com , All Rights Reserved.   </span>

  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>
	        

</body>
</html>