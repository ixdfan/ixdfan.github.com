<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>IO操作 &#8211; 高手之路</title>
<meta name="description" content="">
<meta name="keywords" content="">


<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="IO操作">
<meta property="og:description" content="专注于linux下程序设计">
<meta property="og:url" content="http://localhost:4000/2013/12/17/Cpp-IO/">
<meta property="og:site_name" content="高手之路">





<link rel="canonical" href="http://localhost:4000/2013/12/17/Cpp-IO/">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="高手之路 Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Google Webfonts -->
<link href='http://fonts.googleapis.com/css?family=PT+Sans+Narrow:400,700|PT+Serif:400,700,400italic' rel='stylesheet' type='text/css'>
<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.min.css">

<meta http-equiv="cleartype" content="on">

<!-- HTML5 Shiv and Media Query Support -->
<!--[if lt IE 9]>
	<script src="http://localhost:4000/assets/js/vendor/html5shiv.min.js"></script>
	<script src="http://localhost:4000/assets/js/vendor/respond.min.js"></script>
<![endif]-->

<!-- Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.7.1.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.png">

</head>

<body class="post">

<!--[if lt IE 9]><div class="browser-upgrade alert alert-info">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</div><![endif]-->

<div class="navigation-wrapper">
	<div class="site-name">
		<a href="http://localhost:4000">高手之路</a>
	</div><!-- /.site-name -->
	<div class="top-navigation">
		<nav role="navigation" id="site-nav" class="nav">
		    <ul>
		        
				<li><a href="http://localhost:4000" >Home</a></li>
		        
				<li><a href="http://localhost:4000/category/" >Category</a></li>
		        
				<li><a href="http://localhost:4000/posts/" >Posts</a></li>
		        
				<li><a href="http://localhost:4000/about/" >About</a></li>
		        
				<li><a href="http://localhost:4000/comment/" >Leave a message</a></li>
		        
		    </ul>
		</nav>
	</div><!-- /.top-navigation -->
</div><!-- /.navigation-wrapper -->



<div id="main" role="main">
  <div class="article-author-side">
    <img src="http://localhost:4000/images/Neo.jpg" class="bio-photo" alt="Neo bio photo"></a>
<h3>Neo</h3>
<p>每一个优秀的人,都会有一段沉默的时光. 那一段时光,是付出了很多努力,忍受孤独和寂寞,不抱怨不诉苦. 日后说起时,连自己都能被感动的日子.</p>
















  </div>
  <article>
    <div class="headline-wrap">
      <h1>IO操作</h1>
    </div><!--/ .headline-wrap -->
    <div class="article-wrap">
      <p><strong>继承的关系是'是'的关系，子类对象一定是父类对象</strong></p>

<p>使用父类对象的地方一定可以是用子类对象来代替；</p>

<p>例如适用istream的地方就一定可以使用ifstring！即用cin的地方一定可以使用呢ifstream或istringstream对象来代替；</p>

<pre><code>in.getline()    输入一行
in.ignore() 抛弃缓冲区中的内容
in.putback()    退回刚刚读取到的字符到缓冲区
in.peek()   预先探测下一个字符
in.get()    (1)无参，读取成功返回读取字符的ANSIIC码，失败返回EOF(就是-1);
        (2)参数为char类型引用；

out.put()   输出整数对应的ANSIIC码字符
</code></pre>

<hr />

<pre><code>int n = cin.get();/*返回字符的ANSIIC码，也就是int型的*/
char c, d;
cin.get(c).get(d);

char buf[100];
cin.getline(buf, sizeof(buf));
string name;
std::getline(cin, name);
</code></pre>

<p>如果输入的时候输入多了，那么程序只会读它所能读到的最大长度，但是<strong>最后一个字符一定是'\0'</strong>，剩余的留着下一个读取函数来读取；</p>

<hr />

<pre><code>char ch;
cin &gt;&gt; ch;
cout &lt;&lt; "ch = " &lt;&lt; ch &lt;&lt; endl;

char c, d;
cin.get(c).get(d);
cout &lt;&lt; "c = " &lt;&lt; c &lt;&lt; endl &lt;&lt; "d = " &lt;&lt; d &lt;&lt; endl;
</code></pre>

<p>如果这样的话如果在输入时候输入asdfgh,那么输出 ch = a c = s d = d;</p>

<p>但是这不是我们想要的，我们仅仅想要为ch输入，如何清空缓冲区呢？</p>

<p>使用cin.ignore();</p>

<pre><code>cin.ignore(200, '\n');
</code></pre>

<p>200的含义是最多清空200个字符；</p>

<p>'\n'的含义是遇到'\n'后则停止清除，但是'\n'本身也会清除；</p>

<p>这两个参数本身都有默认值，第一个参数默认值为1，第二个默认值为文件结束符EOF；</p>

<hr />

<p><strong>cin.get(c)与cin >> c的区别</strong></p>

<p>cin >> c会跳过所有空白字符，类似于scanf(" %c");%号前有空格</p>

<p>cin.get(c)不会跳过空格，类似于c中的getchar()或fget();</p>

<hr />

<p>int n = cin.get();对于这个get我们可以使用返回值EOF检测他是否出错；</p>

<p>cin.get(c);</p>

<p>我们如何检测？</p>

<pre><code>cout &lt;&lt; cin &lt;&lt; endl;
cout &lt;&lt; cout &lt;&lt; endl;
cout &lt;&lt; &amp;cin &lt;&lt; endl;
cout &lt;&lt; &amp;cout&lt;&lt; endl;
</code></pre>

<p>输出</p>

<pre><code>[root@localhost IO]# ./main
0x804a1a8
0x804a244
0x804a1a0
0x804a240
</code></pre>

<p>可以看到cin、cout输入的像是地址但又不是地址</p>

<p>c++要求IO对象能够转换成bool类型，就可以表示真假了，转换的对象只要能表示真假就可以了，地址也是真假，所以转换成什么地址并没有规定。</p>

<p>如果一切正常测为true，否则为false；</p>

<pre><code>int n;
cin &gt;&gt; n;
cout &lt;&lt; cin &lt;&lt; endl;
cout &lt;&lt; cout &lt;&lt; endl;
</code></pre>

<p>如果输入123则cin输出正常；</p>

<p>如果输入agc则cin输出为0；</p>

<p>他应该读一个整数，但是abc并不是整数，cin就没有读取，所以出于错误状态</p>

<p>若输入123.4没有问题，他会读取123，留下.4;</p>

<p>但是若输入.4那么没有读取到整数，也会出错，输入0.4是正确的</p>

<hr />

<pre><code>if(cin) 
    cout &lt;&lt; "平安无事" &lt;&lt; endl;
else    
    cout &lt;&lt; "cin出错" &lt;&lt; endl;
</code></pre>

<p>一般使用这种方式来判断是否出错</p>

<hr />

<pre><code>int n;
cin &gt;&gt; n;
string s;
cin &gt;&gt; s;
cout &lt;&lt; "s = [" &lt;&lt; s &lt;&lt; "]" &lt;&lt; endl;
</code></pre>

<p>输入123.456发现s = [.456]，因为123被n读取了</p>

<pre><code>cin &gt;&gt; oct  //以八进制的方式输入
cin &gt;&gt; hex  //以十六进制的方式输入
cin &gt;&gt; dec  //以十进制的方式输入
cin &gt;&gt; ws   //跳过空白字符
</code></pre>

<p>如果我们输入的是asdf，那么输出的n=0,s=[];</p>

<p><strong>因为IO对象一旦处于错误状态，他就会拒绝读写(IO)</strong></p>

<hr />

<pre><code>cin.clear():
</code></pre>

<p><strong>清除cin的错误状态，注意不是清空缓冲区</strong>,要想<strong>清空缓冲区必须用cin.ignore();</strong></p>

<hr />

<p>in.getline()的两种用法：</p>

<pre><code>in.getline(char* buf, int bufsize)  //成员函数
</code></pre>

<p>如果<strong>输入超过bufsize的大小，那么他会按最大数量读取，但是最后一个一定是'\0'</strong>, 如果没有成功读取一行，则他会把IO设为错误状态，后面的也就没有办法读取了！因此数组要尽可能的大。</p>

<pre><code>getline( istream&amp; is, string&amp; s, char delimiter = '/n' )    //非成员函数
</code></pre>

<p>这个getline是一个全局函数在string中声明；</p>

<h5>注意:</h5>

<p><strong>第二个参数必须使用string类对象；</strong></p>

<p>最后一个参数指定的是结束字符，也就是遇到这个字符就结束输入，默认为'/n'，也可以自己指定；</p>

<p>这个用处很大，比如有的配置文件是xxxx=xxxx格式的，那么我们就可以使用getline指定读取到=结束，然后再读取到末尾</p>

<h5>注意：</h5>

<p><strong>对于最后一个参数指定的读取到哪个字符结束，getline不会去读取结束的哪个字符，而是将他扔掉了</strong></p>

<pre><code>int main()
{
        char buf[10];
        if(!cin.getline(buf, sizeof(buf))){
                cout &lt;&lt; "error" &lt;&lt; endl;
                cin.clear();    // 去除错误状态
                cin.ignore(100, '\n');  //去除缓冲区中内容
        }

        string value;
    string data;
        getline(cin, value, '=');
    getline(cin, data);
        cout &lt;&lt; "buf = [" &lt;&lt; buf &lt;&lt; ']' &lt;&lt; endl;
        cout &lt;&lt; "value = [" &lt;&lt; s &lt;&lt; ']' &lt;&lt; endl;
    cout &lt;&lt; "data  = [" &lt;&lt; data &lt;&lt; ']' &lt;&lt; endl;
        printf("%s\n", s.c_str());

        return 0;
}




[root@localhost IO]# ./main
12
getline=1234
buf = [12]
s = [getline]
data = [1234]
getline
</code></pre>

<hr />

<pre><code>int main()
{
    char buf[100];
    //cin &gt;&gt; ws;
    char c = cin.get();
    if(isdigit(c)){
        double d;
        cin &gt;&gt; d;
        cout &lt;&lt; "d = " &lt;&lt; d &lt;&lt; endl;         
    }else{                 
        string s;                 
        cin &gt;&gt; s;
        cout &lt;&lt; "s = " &lt;&lt; s &lt;&lt; endl;
    }
        return 0;
}
</code></pre>

<p>如果输入的是空格12345,那么会输出s = 12345;</p>

<p>如何<strong>去掉空格？使用cin >> ws;</strong></p>

<hr />

<pre><code>cin.peek() 仅读不取
cin.get()  直接读取

int main()
{
    char buf[100];
    //cin &gt;&gt; ws;
    char c = cin.get();
    if(cin.peek() &gt; '0' and cin.peek() &lt; '9'){                
        double d;                 
        cin &gt;&gt; d;
        cout &lt;&lt; "d = " &lt;&lt; d &lt;&lt; endl;         
    }else{      
        string s;               
        cin &gt;&gt; s;
        cout &lt;&lt; "s = " &lt;&lt; s &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>cin.peek没有参数；</p>

<p><strong>cin.peek查看缓冲区中的第一个字符，返回的是字符的ANSIIC码；</strong></p>

<hr />

<pre><code>/*需要sstream头文件*/
int main()
{
    string s = "1234 6.78 x hello 234 100";
    istringstream is(s);
    ostringstream os;   //与cout一样，只不过不输出到屏幕上而已；

    int a, b, c;
    double d;
    char e;
    char buf[100];
    is &gt;&gt; a &gt;&gt; d &gt;&gt; e &gt;&gt; buf &gt;&gt; oct &gt;&gt; b &gt;&gt; hex &gt;&gt; c;
    /*将字符串中对应的内容输入到对应变量中*/
    cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; " c = "
        &lt;&lt; c &lt;&lt; " d = " &lt;&lt; d &lt;&lt; " e = " &lt;&lt; e
        &lt;&lt; " buf = " &lt;&lt; buf &lt;&lt; endl;

    /*合并到一个中*/
    os &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; " c = "
        &lt;&lt; c &lt;&lt; " d = " &lt;&lt; d &lt;&lt; " e = " &lt;&lt; e
        &lt;&lt; " buf = " &lt;&lt; buf &lt;&lt; endl;

    cout &lt;&lt; "==============================" &lt;&lt; endl;
    cout &lt;&lt; os.str() &lt;&lt; endl;
    cout &lt;&lt; "==============================" &lt;&lt; endl;
    cout &lt;&lt; os.str()[0] &lt;&lt; endl;    //输出第1个字符像数组一样的使用；

    return 0;
}


[root@localhost IO]# ./main
a = 1234 b = 156 c = 256 d = 6.78 e = x buf = hello
==============================
a = 1234 b = 156 c = 256 d = 6.78 e = x buf = hello

==============================
a
</code></pre>

<p>由于我们的os最后已经有了一个endl,而输出os.str()又加了一个endl所以输出了两个换行；</p>

<p>**注意：</p>

<p><strong>**对于自定义类型的输出要重载运算符才可以；</strong></p>

<p><strong> ostringstream::str()返回的是c++风格的字符串，也可以后面接.c_str()将他转换为c类型字符串,例如:os.str().c_str();</strong></p>

<p><strong> ostringstream对象将数据保存到了c++风格的字符串中！</strong></p>

<pre><code>/*需要sstream头文件*/
class Point
{
    int x, y;
    public:
    Point(int x, int y):x(x), y(y){}

    friend ostream&amp; operator&lt;&lt; (ostream&amp; out, const Point&amp; P)
    {
        return out &lt;&lt; '(' &lt;&lt; P.x &lt;&lt; ',' &lt;&lt; P.y &lt;&lt; ')';  //不能忘记return         
    } 
};
int main() {         
    string s = "1234 6.78 x hello 234 100";         
    istringstream is(s);    
    ostringstream os;   //与cout一样，只不过不输出到屏幕上而已；         
    int a, b, c;         
    double d;         
    char e;         
    char buf[100];  
    Point P(3, 5);         
    is &gt;&gt; a &gt;&gt; d &gt;&gt; e &gt;&gt; buf &gt;&gt; oct &gt;&gt; b &gt;&gt; hex &gt;&gt; c;

    cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; " c = "
        &lt;&lt; c &lt;&lt; " d = " &lt;&lt; d &lt;&lt; " e = " &lt;&lt; e
        &lt;&lt; " buf = " &lt;&lt; buf &lt;&lt; endl;

    os &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " b = " &lt;&lt; b &lt;&lt; " c = "
        &lt;&lt; c &lt;&lt; " d = " &lt;&lt; d &lt;&lt; " e = " &lt;&lt; e
        &lt;&lt; " buf = " &lt;&lt; buf &lt;&lt; " P = " &lt;&lt; P &lt;&lt; endl;//加入了P

    cout &lt;&lt; "==============================" &lt;&lt; endl;
    cout &lt;&lt; os.str() &lt;&lt; endl;
    cout &lt;&lt; "==============================" &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>注意：istringstream可以读读停停，比如将</p>

<pre><code>is &gt;&gt; a &gt;&gt; d &gt;&gt; e &gt;&gt; buf &gt;&gt; oct &gt;&gt; b &gt;&gt; hex &gt;&gt; c;
</code></pre>

<p>改为</p>

<pre><code>is &gt;&gt; a &gt;&gt; d &gt;&gt; e &gt;&gt; buf; 
is &gt;&gt; oct &gt;&gt; b &gt;&gt; hex &gt;&gt; c;
</code></pre>

<p>仍然正确的输入了，分开他并不会导致又从头开始读取，只要is对象还在，就可以一直的输入下去；</p>

<hr />

<p>无论是读文件还是写文件都需要头文件fstream</p>

<pre><code>int main()
{
    string path = "sstream.cpp";
    ifstream fin(path.c_str());//比较搞笑的是明明是c++，但是参数却一定要用c风格字符串！
    /*等价于以下两条语句
    *ifstream fin;
    *fin.open(path.c_str());
    */
    if(!fin){
        cout &lt;&lt; "open error" &lt;&lt; endl;                 
        return -1;        
    }         
     char ch; 
    //while(fin &gt;&gt; ch){         //如果使用这个则fin会跳过空白字符导致输出的结果不便查看
    //while(EOF != (ch = fin.get()))    //这样比较难写，打字太多
    while(fin.get(ch)){         //一般使用这种方式
        cout &lt;&lt; ch;
    }
    fin.close();//显性的关闭文件比较好

    return 0;
}
</code></pre>

<p>c语言中控制台当做文件stdout、stdin、stderr;</p>

<p>c++中对应的是cout、cin、cerr</p>

<p>由于ifstream是istream的子类，因此可以使用操作cin的方法操作fin,这就是继承；</p>

<p>fin.peek()、fin.get()、fin.putback()等等都可以使用！</p>

<hr />

<p>使用ofstream复制文件</p>

<pre><code>int main()
{
    string path = "sstream.cpp";
    ifstream fin(path.c_str());
    /*ifstream fin;
    *fin.open(path.c_str());
    */
    if(!fin){
        cout &lt;&lt; "fin open error" &lt;&lt; endl;
        return -1;
    }
    ofstream fout("copy.cpp");
    /*等价
    *ofstream fout;
    *fout.open("copy.cpp");
    */
    if(!fout){
        cout &lt;&lt; "fout open error" &lt;&lt; endl;                 
        return -1;         
    }         
    char ch;         
    //while(fin &gt;&gt; ch){
    while(fin.get(ch)){
        cout &lt;&lt; ch; //输出到屏幕
        fout &lt;&lt; ch; //输出到文件copy.cpp
    }
    fin.close();
    fout.close();

    return 0;
}
</code></pre>

<p>可以使用wc来统计复制文件与源文件，两个文件完全相同</p>

<pre><code>while(fin.get(ch)){
    cout &lt;&lt; ch; //输出到屏幕
    fout &lt;&lt; ch; //输出到文件copy.cpp
}
改为
while(fin){
    fin.get(ch)
    cout &lt;&lt; ch; //输出到屏幕
    fout &lt;&lt; ch; //输出到文件copy.cpp
}
</code></pre>

<p>会发现拷贝的文件多出了一个字符，原因在于，当fin.get(ch)读取到最后一个的时候没有遇到EOF，所以while中的fin正确；</p>

<p>当下次读取时没有读取到内容，所以出于错误状态，导致ch没有改变紧接着是fout &lt;&lt; ch;所以讲最后的一个字符输入了两次；</p>

<h5>注意：</h5>

<p>ifstream fin(path)</p>

<p>他会自动打开path的文件<strong>,path一定要是c风格的字符串，否则出错；</strong></p>

<p><strong>文件打开一定要检查</strong>，使用if(fin)，打开文件不去判断那么你会被直接淘汰的</p>

<p>对于打开的文件记得显性的关闭，虽然析构函数也可以关闭，但是最好还是写上去！</p>

<p>c语言中的fscanf()对应c++中的fin >>, fgetc()对应fin.getline()/getline();</p>

<hr />

<pre><code>fin.read(char* buf, bufsize);
</code></pre>

<p>从文件中读取了放入内存中；</p>

<pre><code>fin.write(char* buf, bufsize);
</code></pre>

<p><strong>注意:参数必须强制装换为char</strong>*</p>

<pre><code>reinterpret_cast&lt;char*&gt;(&amp; int_type_value);

(char*)&amp;int_type_value;
</code></pre>

<p><strong>fin.gcount();返回上一次fin.read中读取的字符个数</strong></p>

<p>比如读取一个文件，每次读取100字符，最后一次读取一般不满100字符，我们便可以使用.gcount()来统计最后一次到底读取了多少个字符。</p>

<hr />

<pre><code>int main(int argc, char** argv)
{
        if(3 != argc){
                cout &lt;&lt; "argc : " &lt;&lt; argc &lt;&lt; endl;
                return -1;
        }

        //fstream fin_out(argv[1], ios::binary | ios::in | ios::out);//又读又写
        ifstream fin(argv[1], ios::binary | ios::in);   
        ofstream fout(argv[2], ios::binary | ios::out);

        if(!fin){
                cout &lt;&lt; "fin error" &lt;&lt; endl;
                return -1;
        }
        if(!fout){
                cout &lt;&lt; "fout error" &lt;&lt; endl;
                return -1;
        }
        char buf[100];  //如果将buf改为int类型，那么在read、write中要加强制转换
        while(fin){ //当fin处于错误状态的时候说明已经读取完毕了！
                fin.read(buf, sizeof(buf));
                fout.write(buf, fin.gcount());  //这里不能使用.gcount()，因为
        }
        fin.clear();    //清除fin的错误状态
        fin.close();
        fout.close();

        return 0;
}
</code></pre>

<p>ios::binary|ios::in 以二进制的方式写
ios::binary|ios::out 以二进制方式读
ios::app 打开文件后不会覆盖文件，而是在末尾去追加
如果想要又读又写，那么应该使用fstream类
fstream::seekg(位置， ios::beg/ios::end/ios::cur);定位去读
fstream::seekp(位置，ios::beg/ios::end/ios::cur);定位去写
tellg();获取当前读位置，相对于文件头的位置
tellp();获取当前写位置，相对于文件头的位置
如果想要又读又写的话使用</p>

<pre><code>fstream f(path, ios::binary | ios::in | ios::out);
</code></pre>

<hr />

<p>cout.width(10)；//输出格式控制，仅对后面的一次有效</p>

<p>注意：<strong>带参数的格式控制符都需要头文件iomanop</strong>；</p>

<p>setw(10); //输出格式控制，仅对后面的一次有效</p>

      <hr />
      <footer role="contentinfo">
        <div class="article-author-bottom">
          <img src="http://localhost:4000/images/Neo.jpg" class="bio-photo" alt="Neo bio photo"></a>
<h3>Neo</h3>
<p>每一个优秀的人,都会有一段沉默的时光. 那一段时光,是付出了很多努力,忍受孤独和寂寞,不抱怨不诉苦. 日后说起时,连自己都能被感动的日子.</p>
















        </div>
        <p class="byline"><strong>IO操作</strong> was published on <time datetime="2013-12-17T00:00:00+00:00">December 17, 2013</time> by <a href="http://localhost:4000/about" title="About Neo">Neo</a>.</p>
      </footer>
    </div><!-- /.article-wrap -->
  </article>
</div><!-- /#main -->

<div class="footer-wrap">
  <div class="related-articles">
  <h4>You might also enjoy <small class="pull-right">(<a href="http://localhost:4000/posts/">View all posts</a>)</small></h4>
    <ul>
    
      <li><a href="http://localhost:4000/2014/06/05/shell-debug/" title="shell脚本的调试">shell脚本的调试</a></li>
    
      <li><a href="http://localhost:4000/2014/06/05/kernel-memory-align/" title="内存对齐的实现">内存对齐的实现</a></li>
    
      <li><a href="http://localhost:4000/2014/06/02/nginx-share-memory/" title="nginx的slab机制">nginx的slab机制</a></li>
    
    </ul>
    <hr />
        <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'ucshellcom'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
  </div><!-- /.related-articles -->
  <footer>
    <br></br>
<br></br>
<span>&copy; 2013 - 2014 高手之路 ucshell.com , All Rights Reserved.   </span>

  </footer>
</div><!-- /.footer-wrap -->

<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>
	        

</body>
</html>